<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Resolve scroll offsets per\n * https://drafts.csswg.org/scroll-animations-1/#effective-scroll-offsets-algorithm\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @param scrollOffsets {Array}\n * @param fns {Array}\n * @returns {Array}\n */\nexport function resolveScrollOffsets(\n  scrollSource,\n  orientation,\n  scrollOffsets,\n  fns\n) {\n  // 1. Let effective scroll offsets be an empty list of effective scroll\n  // offsets.\n  let effectiveScrollOffsets = [];\n  // 2. Let first offset be true.\n  let firstOffset = true;\n\n  // 3. If scrollOffsets is empty\n  if(scrollOffsets.length == 0) {\n    // 3.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 3.2 Set first offset to false.\n    firstOffset = false;\n    // 3.3 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(100, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n  }\n  // 4. If scrollOffsets has exactly one element\n  else if(scrollOffsets.length == 1) {\n    // 4.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 4.2 Set first offset to false.\n    firstOffset = false;\n  }\n  // 5. For each scroll offset in the list of scrollOffsets, perform the\n  // following steps:\n  for (let i = 0; i < scrollOffsets.length; i++) {\n    // 5.1 Let effective offset be the result of applying the procedure\n    // to resolve a scroll timeline offset for scroll offset with the is\n    // first flag set to first offset.\n    let effectiveOffset = calculateScrollOffset(\n      firstOffset ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'),\n      scrollSource,\n      orientation,\n      scrollOffsets[i],\n      fns[i]);\n    //  5.2 If effective offset is null, the effective scroll offsets is empty and abort the remaining steps.\n    if(effectiveOffset === null)\n      return [];\n    // 5.3 Add effective offset into effective scroll offsets.\n    effectiveScrollOffsets.push(effectiveOffset);\n    // 5.4 Set first offset to false.\n    firstOffset = false;\n  }\n  // 6. Return effective scroll offsets.\n  return effectiveScrollOffsets;\n}\n\n/**\n * Compute scroll timeline progress per\n * https://drafts.csswg.org/scroll-animations-1/#progress-calculation-algorithm\n * @param offset {number}\n * @param scrollOffsets {Array}\n * @returns {number}\n */\nexport function ComputeProgress(\n  offset,\n  scrollOffsets\n) {\n  // 1. Let scroll offsets be the result of applying the procedure to resolve\n  // scroll timeline offsets for scrollOffsets.\n  // 2. Let offset index correspond to the position of the last offset in\n  // scroll offsets whose value is less than or equal to offset and the value\n  // at the following position greater than offset.\n  let offsetIndex;\n  for (offsetIndex = scrollOffsets.length - 2;\n       offsetIndex >= 0 && \n         !(scrollOffsets[offsetIndex] <= offset && offset < scrollOffsets[offsetIndex + 1]);\n       offsetIndex--) {\n  }\n  // 3. Let start offset be the offset value at position offset index in\n  // scroll offsets.\n  let startOffset = scrollOffsets[offsetIndex];\n  // 4. Let end offset be the value of next offset in scroll offsets after\n  // start offset.\n  let endOffset = scrollOffsets[offsetIndex + 1];\n  // 5. Let size be the number of offsets in scroll offsets.\n  let size = scrollOffsets.length;\n  // 6. Let offset weight be the result of evaluating 1 / (size - 1).\n  let offsetWeight = 1 / (size - 1);\n  // 7. Let interval progress be the result of evaluating\n  // (offset - start offset) / (end offset - start offset).\n  let intervalProgress =  (offset - startOffset) / (endOffset - startOffset);\n  // 8. Return the result of evaluating\n  // (offset index + interval progress) × offset weight.\n  return (offsetIndex + intervalProgress) * offsetWeight;\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      scrollOffsets: [],\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n    updateInternal(this);\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  get duration() {\n    return CSS.percent(100);\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n\n    //   if source's effective scroll range is null\n    if (effectiveScrollOffsets.length == 0)\n      return \"inactive\";\n\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return CSS.percent(0);\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return CSS.percent(100);\n\n    // Step 5\n    let progress = ComputeProgress(\n      currentScrollOffset,\n      effectiveScrollOffsets\n    );\n    return CSS.percent(100 * progress);\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\n// Converts a time from its internal representation to a percent. For a\n// monotonic timeline, time is reported as a double with implicit units of\n// milliseconds. For progress-based animations, times are reported as\n// percentages.\nfunction toCssNumberish(details, value) {\n  if (value === null)\n    return value;\n\n  if (typeof value !== 'number') {\n      throw new DOMException(\n          `Unexpected value: ${value}.  Cannot convert to CssNumberish`,\n          \"InvalidStateError\");\n  }\n\n  const limit = effectEnd(details);\n  const percent = limit ? 100 * value / limit : 0;\n  return CSS.percent(percent);\n}\n\n// Covnerts a time to its internal representation. Progress-based animations\n// use times expressed as percentages. Each progress-based animation is backed\n// by a native animation with a document timeline in the polyfill. Thus, we\n// need to convert the timing from percent to milliseconds with implicit units.\nfunction fromCssNumberish(details, value) {\n  if (!details.timeline) {\n    // Document timeline\n    if (value == null || typeof value === 'number')\n      return value;\n\n    const convertedTime = value.to('ms');\n    if (convertTime)\n      return convertedTime.value;\n\n    throw new DOMException(\n        \"CSSNumericValue must be either a number or a time value for \" +\n        \"time based animations.\",\n        \"InvalidStateError\");\n  } else {\n    // Scroll timeline.\n    if (value === null)\n      return value;\n\n    if (value.unit === 'percent') {\n      const duration = effectEnd(details);\n      return value.value * duration / 100;\n    }\n\n    throw new DOMException(\n        \"CSSNumericValue must be a percentage for progress based animations.\",\n        \"NotSupportedError\");\n  }\n}\n\nfunction normalizedTiming(details) {\n  // Used normalized timing in the case of a progress-based animation or\n  // specified timing with a document timeline.  The normalizedTiming property\n  // is initialized and cached when fetching the timing information.\n  const timing = details.proxy.effect.getTiming();\n  return details.normalizedTiming || timing;\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = fromCssNumberish(details, details.timeline.currentTime);\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n\n  details.animation.pause();\n\n  // Event times are speced as doubles in web-animations-1.\n  // Cannot dispatch a proxy to an event since the proxy is not a fully\n  // transparent replacement. As a workaround, use a custom event and inject\n  // the necessary getters.\n  const finishedEvent =\n    new CustomEvent('finish',\n                    { detail: {\n                      currentTime: details.proxy.currentTime,\n                      timelineTime: details.proxy.timeline.currentTime\n                    }});\n  Object.defineProperty(finishedEvent, 'currentTime', {\n    get: function() { return this.detail.currentTime; }\n  });\n  Object.defineProperty(finishedEvent, 'timelineTime', {\n    get: function() { return this.detail.timelineTime; }\n  });\n\n  requestAnimationFrame(() => {\n    queueMicrotask(() => {\n      details.animation.dispatchEvent(finishedEvent);\n    });\n  });\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  let unconstrainedCurrentTime =\n      didSeek ? fromCssNumberish(details, details.proxy.currentTime)\n              : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = fromCssNumberish(details,\n                                                 details.proxy.currentTime);\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = normalizedTiming(details);\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n\n  return Math.max(0, totalDuration);\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n    details.animation.currentTime =\n        (timelineTime - details.startTime) *\n            details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = fromCssNumberish(details,\n                                             details.proxy.currentTime);\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    details.animation.currentTime =\n        (timelineTimeMs - fromCssNumberish(details, this.startTime)) *\n            this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\nfunction createProxyEffect(details) {\n  const effect = details.animation.effect;\n  const nativeUpdateTiming = effect.updateTiming;\n\n  // Generic pass-through handler for any method or attribute that is not\n  // explicitly overridden.\n  const handler = {\n    get: function(obj, prop) {\n      const result = obj[prop];\n      if (typeof result === 'function')\n        return result.bind(effect);\n      return result;\n    },\n\n    set: function(obj, prop, value) {\n      obj[prop] = value;\n      return true;\n    }\n  };\n  // Override getComputedTiming to convert to percentages when using a\n  // progress-based timeline.\n  const getComputedTimingHandler = {\n    apply: function(target) {\n      // Ensure that the native animation is using normalized values.\n      effect.getTiming();\n\n      const timing = target.apply(effect);\n\n      if (details.timeline) {\n        const preConvertLocalTime = timing.localTime;\n        timing.localTime = toCssNumberish(details, timing.localTime);\n        timing.endTime = toCssNumberish(details, timing.endTime);\n        timing.activeDuration =\n            toCssNumberish(details, timing.activeDuration);\n        const limit = effectEnd(details);\n        const iteration_duration = timing.iterations ?\n            (limit - timing.delay - timing.endDelay) / timing.iterations : 0;\n        timing.duration = limit ?\n            CSS.percent(100 * iteration_duration / limit) :\n            CSS.percent(0);\n\n        // Correct for timeline phase.\n        const phase = details.timeline.phase;\n        const fill = timing.fill;\n\n        if(phase == 'before' && fill != 'backwards' && fill != 'both') {\n          timing.progress = null;\n        }\n        if (phase == 'after' && fill != 'forwards' && fill != 'both') {\n          timing.progress = null;\n        }\n\n        // Correct for inactive timeline.\n        if (details.timeline.currentTime === undefined) {\n          timing.localTime = null;\n        }\n      }\n      return timing;\n    }\n  };\n  // Override getTiming to normalize the timing. EffectEnd for the animation\n  // align with the timeline duration.\n  const getTimingHandler = {\n    apply: function(target, thisArg) {\n      // Arbitrary conversion of 100% to ms.\n      const INTERNAL_DURATION_MS = 100000;\n\n      if (details.specifiedTiming)\n        return details.specifiedTiming;\n\n      details.specifiedTiming = target.apply(effect);\n      let timing = Object.assign({}, details.specifiedTiming);\n\n      let totalDuration;\n\n      // Duration 'auto' case.\n      if (timing.duration === null || timing.duration === 'auto') {\n        if (details.timeline) {\n          // TODO: start and end delay are specced as doubles and currently\n          // ignored for a progress based animation. Support delay and endDelay\n          // once CSSNumberish.\n          timing.delay = 0;\n          timing.endDelay = 0;\n          totalDuration = timing.iterations ? INTERNAL_DURATION_MS : 0;\n          timing.duration =\n              timing.iterations ? totalDuration / timing.iterations : 0;\n          // Set the timing on the native animation to the normalized values\n          // while preserving the specified timing.\n          nativeUpdateTiming.apply(effect, [timing]);\n        }\n      }\n      details.normalizedTiming = timing;\n      return details.specifiedTiming;\n    }\n  };\n  const updateTimingHandler = {\n    apply: function(target, thisArg, argumentsList) {\n      // Additional validation that is specific to scroll timelines.\n      if (details.timeline) {\n        const options = argumentsList[0];\n        const duration = options.duration;\n        if (duration === Infinity) {\n          throw TypeError(\n              \"Effect duration cannot be Infinity when used with Scroll \" +\n              \"Timelines\");\n        }\n        const iterations = options.iterations;\n        if (iterations === Infinity) {\n          throw TypeError(\n            \"Effect iterations cannot be Infinity when used with Scroll \" +\n            \"Timelines\");\n        }\n      }\n\n      // Apply updates on top of the original specified timing.\n      if (details.specifiedTiming) {\n        target.apply(effect, [details.specifiedTiming]);\n      }\n      target.apply(effect, argumentsList);\n      // Force renormalization.\n      details.specifiedTiming = null;\n    }\n  };\n  proxy = new Proxy(effect, handler);\n  proxy.getComputedTiming = new Proxy(effect.getComputedTiming,\n                                      getComputedTimingHandler);\n  proxy.getTiming = new Proxy(effect.getTiming, getTimingHandler);\n  proxy.updateTiming = new Proxy(effect.updateTiming, updateTimingHandler);\n  return proxy;\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position. These values are represented as floating point\n      // numbers in milliseconds.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      // Record the specified timing since it may be different than the timing\n      // actually used for the animation. When fetching the timing, this value\n      // will be returned, however, the native animation will use normalized\n      // values.\n      specifiedTiming: null,\n      // The normalized timing has the corrected timing with the intrinsic\n      // iteration duration resolved.\n      normalizedTiming: null,\n      // Effect proxy that performs the necessary time conversions when using a\n      // progress-based timelines.\n      effect: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.effect;\n\n    // Proxy the effect to support timing conversions for progress based\n    // animations.\n    if (!details.effect)\n      details.effect = createProxyEffect(details);\n\n    return details.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n    // Reset proxy to force re-initialization the next time it is accessed.\n    details.effect = null;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    const details = proxyAnimations.get(this);\n    const end = effectEnd(details);\n    const progress =\n        end > 0 ? fromCssNumberish(details, previousCurrentTime) / end : 0;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime =\n              fromCssNumberish(details, CSS.percent(100 * progress));\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = progress * effectEnd(details);\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return toCssNumberish(details, details.startTime);\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return toCssNumberish(details, details.holdTime);\n\n    return toCssNumberish(details, calculateCurrentTime(details));\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = fromCssNumberish(details, this.currentTime);\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = toCssNumberish(details, limit);\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ?\n            null : fromCssNumberish(details, this.currentTime);\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = fromCssNumberish(details,\n                                              details.timeline.currentTime);\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","MathOperation","operator","opt_name","opt_delimiter","set","this","name","delimiter","toString","details","get","join","cssOMTypes","value","unit","toLowerCase","displayUnit","CSSKeywordValue","arguments","CSSMathProduct","CSSMathNegate","window","CSS","Reflect","defineProperty","Error","type","forEach","installCSSOM","AUTO","scrollTimelineOptions","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolveScrollOffsets","scrollOffsets","fns","effectiveScrollOffsets","firstOffset","push","effectiveOffset","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","input","parse","evaluate","parsed","data","percent","scrollerStyle","display","overflow","maxOffset","startOffset","endOffset","phase","progress","offsetIndex","ComputeProgress","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","toCssNumberish","limit","effectEnd","fromCssNumberish","duration","convertedTime","to","convertTime","commitFinishedNotification","finishedPromise","proxy","playState","pause","finishedEvent","CustomEvent","detail","Object","queueMicrotask","dispatchEvent","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","effect","getTiming","normalizedTiming","max","delay","endDelay","iterations","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","Infinity","play","bind","pendingTask","proxyAnimations","timelineTimeMs","cancel","readyTime","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","specifiedTiming","finish","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","event","nativeUpdateTiming","updateTiming","getComputedTimingHandler","apply","target","localTime","endTime","activeDuration","fill","getTimingHandler","thisArg","assign","updateTimingHandler","argumentsList","Proxy","prop","getComputedTiming","createProxyEffect","newEffect","newTimeline","oldTimeline","previousPlayState","end","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","edge","threshold","rootMargin","clamp","parseFloat","map","margin","margins","split","parsedMargins","parsedValue","positions","j","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","keyframes","proxyAnimation"],"mappings":"8tCAAgBA,EAAYC,EAAKC,GAC/B,GAAID,aAAeE,cAAgBF,aAAeG,WAChD,OAAOH,EACT,IAAKC,EACH,YACF,IAAIG,EAAUJ,EAAIK,OAAOC,MAAM,+BAC/B,OAAIF,MAISF,aAHCE,EAAQ,GAEK,KAAdA,EAAQ,GAAY,UAAYA,EAAQ,2BCSjDG,EAAiB,IAAIC,QAmBzB,SAASC,EAAkBC,GAEzB,IADA,IAPsBC,EAOhBC,EAAS,GACNC,EAAI,EAAGA,EAAIH,EAAOI,OAAQD,IACjCD,EAAOC,GARQ,iBADKF,EASOD,EAAOG,QAPvBX,aAAaS,EAAG,UACtBA,EAQP,OAAOC,EA5BoB,IA+BvBG,aACJ,WAAYL,EAAQM,EAAUC,EAAUC,GACtCX,EAAeY,IAAIC,KAAM,CACvBV,OAAQD,EAAkBC,GAC1BM,SAAUA,EACVK,KAAMJ,GAAYD,EAClBM,UAAWJ,GAAiB,0BAYhCK,SAAA,WACE,IAAMC,EAAUjB,EAAekB,IAAIL,MACnC,OAAUI,EAAQH,SAAQG,EAAQd,OAAOgB,KAAKF,EAAQF,yCAVxD,WACE,OAAOf,EAAekB,IAAIL,MAAMJ,6BAGlC,WACE,OAAQT,EAAekB,IAAIL,MAAMV,gBAS/BiB,OACJzB,wBACE,WAAY0B,EAAOC,GACjBtB,EAAeY,IAAIC,KAAM,CACvBQ,MAAOA,EACPC,KAAMA,uBAgBVN,SAAA,WACE,IAAMC,EAAUjB,EAAekB,IAAIL,MACnC,SAAUI,EAAQI,MAxExB,SAAqBC,GACnB,OAAOA,GACL,IAAK,UACH,MAAO,IACT,IAAK,SACH,MAAO,GACT,QACE,OAAOA,EAAKC,eAiEcC,CAAYP,EAAQK,6BAdhD,WACE,OAAOtB,EAAekB,IAAIL,MAAMQ,WAGlC,SAAUA,GACRrB,EAAekB,IAAIL,MAAMQ,MAAQA,oBAGnC,WACE,OAAQrB,EAAekB,IAAIL,MAAMS,cASrCG,2BACE,WAAYJ,GACVR,KAAKQ,MAAQA,qBAGfL,SAAA,WACE,YAAYK,MAAML,iBAItBpB,uBACE,WAAYO,sBACJuB,UAAW,MAAO,OAAQ,aAFpC,iBAA4BlB,GAM5BmB,2BACE,WAAYxB,sBACJuB,UAAW,UAAW,OAAQ,aAFxC,iBAAgClB,GAMhCoB,0BACE,WAAYzB,sBACJ,CAACuB,UAAU,IAAK,SAAU,WAFpC,iBAA+BlB,+BAO7B,WAAYL,sBACJ,CAAC,EAAGuB,UAAU,IAAK,SAAU,OAAQ,aAzDjC,iBAuDiBlB,KAvDjB,uBA8DZ,gCACQkB,UAAW,aA/DP,iBA6DclB,KA7Dd,uBAoEZ,gCACQkB,UAAW,aArEP,iBAmEclB,MAO9B,IAAKqB,OAAOC,MACLC,QAAQC,eAAeH,OAAQ,MAAO,CAAER,MAAO,KAClD,MAAMY,wCAgDV,IAAK,IAAIC,KA7CJL,OAAOlC,cACV,CACE,SACA,UAEA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,OACA,OACA,OACA,KAEA,MACA,MACA,OACA,OAEA,KACA,IACA,KACA,MAEA,OACA,MACA,OAEA,MACAwC,QAAQ,SAACrB,GAIT,IAAKiB,QAAQC,eAAeF,IAAKhB,EAAM,CAAEO,MAH9B,SAACA,GACV,WAAW1B,aAAa0B,EAAOP,MAG/B,MAAMmB,8BAA8BnB,KAIzBM,EACf,KAAIc,KAAQL,UAEPE,QAAQC,eAAeH,OAAQK,EAAM,CAAEb,MAAOD,EAAWc,KAC5D,MAAMD,4CAA4CC,GCpLxDE,GAEA,IAAMC,EAAO,IAAIZ,gBAAgB,QAE7Ba,EAAwB,IAAIrC,QAC5BsC,EAAiC,GAErC,SAASC,EAAkBC,GACzB,OAAIA,IAAiBC,SAASC,iBAAyBD,SAChDD,EAOT,SAASG,EAAeC,GACtB,IAAIC,EAAaR,EAAsBpB,IAAI2B,GAAwBC,WACnE,GAA0B,IAAtBA,EAAWvC,OAGf,IAFA,IAAIwC,EAAeF,EAAuBG,YAEjC1C,EAAI,EAAGA,EAAIwC,EAAWvC,OAAQD,IACrCwC,EAAWxC,GAAG2C,cAAcF,GAWhC,SAASG,EAA2BT,EAAcU,GAChD,IAKMC,EAA6C,iBALrCC,iBAAiBZ,GAKKa,YAChCC,EAAuBd,EAAae,UAWxC,OAVmB,cAAfL,GACe,UAAfA,GAA2BC,GACZ,SAAfD,IAA2BC,KAM7BG,EAAsBE,KAAKC,IAAIjB,EAAakB,aAEvCJ,EAgDT,SAASK,EAAUC,EAAUC,GAC3B,GAAID,aAAoBlE,aAAc,CACpC,GAAqB,WAAjBkE,EAASvC,KACX,OAAOuC,EAASxC,MAAQyC,EAAiB,OACjB,MAAjBD,EAASvC,KAChB,OAAOuC,EAASxC,YAEV0C,UAAU,uBAAyBF,EAASvC,SAC3CuC,aAAoBjE,WAAY,CAEzC,IADA,MAAIoE,EAAQ,MACMH,EAAS1D,uBACzB6D,GAASJ,UAAiBE,GAE5B,OAAOE,EAET,MAAMD,UAAU,kCAAoCF,YAGtCI,EACdC,EACAzB,EACAU,EACAgB,EACAC,GAEA,GAAIA,EACF,OAAOA,EACL3B,EACAU,EACAgB,EACmB,GAAnBD,EAAU7C,MAAa,QAAU,OAGjB,UAAhB8B,EAAyBA,EAAc,WAClB,WAAhBA,IAA0BA,EAAc,cAEjD,IAAIkB,EACc,aAAhBlB,EACIV,EAAa6B,aAAe7B,EAAa8B,aACzC9B,EAAa+B,YAAc/B,EAAagC,YAE9C,OAAOb,EADMpE,EAAY2E,IAAW9B,EAAO6B,EAAYC,GAC9BE,YAYXK,EACdjC,EACAU,EACAwB,EACAC,GAIA,IAAIC,EAAyB,GAEzBC,GAAc,EAGS,GAAxBH,EAAcpE,QAIfsE,EAAuBE,KACrBd,EACE,IAAItE,aAAa,EAAG,WACpB8C,EACAU,EACAd,IAGJyC,GAAc,EAIdD,EAAuBE,KACrBd,EACE,IAAItE,aAAa,IAAK,WACtB8C,EACAU,EACAd,KAI0B,GAAxBsC,EAAcpE,SAIpBsE,EAAuBE,KACrBd,EACE,IAAItE,aAAa,EAAG,WACpB8C,EACAU,EACAd,IAGJyC,GAAc,GAIhB,IAAK,IAAIxE,EAAI,EAAGA,EAAIqE,EAAcpE,OAAQD,IAAK,CAI7C,IAAI0E,EAAkBf,EACpBa,EAAc,IAAInF,aAAa,EAAG,WAAa,IAAIA,aAAa,IAAK,WACrE8C,EACAU,EACAwB,EAAcrE,GACdsE,EAAItE,IAEN,GAAuB,OAApB0E,EACD,MAAO,GAETH,EAAuBE,KAAKC,GAE5BF,GAAc,EAGhB,OAAOD,WAiDOI,EAAgBC,EAAgBC,GAE9C,IADA,IAAIrC,EAAaR,EAAsBpB,IAAIgE,GAAgBpC,WAClDxC,EAAI,EAAGA,EAAIwC,EAAWvC,OAAQD,IACjCwC,EAAWxC,GAAG6E,WAAaA,GAC7BrC,EAAWsC,OAAO9E,EAAG,YAWX+E,EAAaH,EAAgBC,EAAWlC,GAEtD,IADA,IAAIH,EAAaR,EAAsBpB,IAAIgE,GAAgBpC,WAClDxC,EAAI,EAAGA,EAAIwC,EAAWvC,OAAQD,IACrC,GAAIwC,EAAWxC,GAAG6E,WAAaA,EAC7B,OAGJrC,EAAWiC,KAAK,CACdI,UAAWA,EACXlC,cAAeA,IAEjBL,EAAesC,OAQJI,aACX,WAAYC,GACVjD,EAAsB1B,IAAIC,KAAM,CAC9B4B,aAAc,KACdU,YAAa,QACbwB,cAAe,GAGf7B,WAAY,GACZ0C,gBAAiB,KAEnB3E,KAAK4B,aACH8C,QAAoCE,IAAzBF,EAAQ9C,aAA6B8C,EAAQ9C,aAAeC,SAASC,iBAClF9B,KAAKsC,YAAeoC,GAAWA,EAAQpC,aAAgB,QACvDtC,KAAK8D,cAAgBY,QAAqCE,IAA1BF,EAAQZ,cAA8BY,EAAQZ,cAAgB,UAdlGe,6BA+BE,WACE,OAAOpD,EAAsBpB,IAAIL,MAAM4B,kBAfzC,SAAiBkD,cACX9E,KAAK4B,cACPD,EAAkB3B,KAAK4B,cAAcmD,oBAAoB,SAAU,kBACjEhD,EAAeiD,KAEnBvD,EAAsBpB,IAAIL,MAAM4B,aAAekD,EAC3CA,GACFnD,EAAkBmD,GAASG,iBAAiB,SAAU,kBACpDlD,EAAeiD,KAGnBjD,EAAe/B,+BAiBjB,WACE,OAAOyB,EAAsBpB,IAAIL,MAAMsC,iBAXzC,SAAgBA,GACd,IAC0E,IAAxE,CAAC,QAAS,SAAU,aAAc,YAAY4C,QAAQ5C,GAEtD,MAAMY,UAAU,uBAElBzB,EAAsBpB,IAAIL,MAAMsC,YAAcA,EAC9CP,EAAe/B,iCA2CjB,WAEE,OADWyB,EAAsBpB,IAAIL,MACzB8D,mBAtCd,SAAkBtD,GAGhB,IAFA,MAAI2E,EAAU,GACVpB,EAAM,OACQvD,kBAAO,KAAhB4E,UACH7B,EAAK,KACLD,OAASsB,EACA,QAATQ,IACFA,EAAQ5D,GACV,IAAK,IAAI/B,EAAI,EAAGA,EAAIiC,EAA+BhC,OAAQD,IAAK,CAC9D,IAAID,EAASkC,EAA+BjC,GAAG4F,MAAMD,GACrD,QAAeR,IAAXpF,EAAsB,CACxB8D,EAAS9D,EACT+D,EAAK7B,EAA+BjC,GAAG6F,SACvC,OAGJ,IAAK/B,EAAI,CACP,GAAI6B,GAAS5D,EAAM,CACjB,IAAI+D,EAAS5G,EAAYyG,GAEzB,IAAKG,GAAWA,aAAkBzG,cAA+B,UAAfyG,EAAO9E,KACvD,MAAMyC,UAAU,gCAEpBI,EAAS8B,EAEXD,EAAQjB,KAAKZ,GACbS,EAAIG,KAAKX,GAEX,GAAsB,GAAlB4B,EAAQzF,QAAeyF,EAAQ,IAAM3D,EACvC,MAAM0B,UAAU,gCAClB,IAAIsC,EAAO/D,EAAsBpB,IAAIL,MACrCwF,EAAK1B,cAAgBqB,EACrBK,EAAKb,gBAAkBZ,EACvBhC,EAAe/B,4BAQjB,WACE,OAAOiB,IAAIwE,QAAQ,wBAGrB,WAKE,IAAKzF,KAAK4B,aAAc,MAAO,WAC/B,IAAI8D,EAAgBlD,iBAAiBxC,KAAK4B,cAG1C,GAA6B,QAAzB8D,EAAcC,QAChB,MAAO,WAGT,GAAI3F,KAAK4B,cAAgBC,SAASC,mBACH,WAA1B4D,EAAcE,UACY,QAA1BF,EAAcE,UACf,MAAO,WAGX,IAAI5B,EAAyBH,EAC3B7D,KAAK4B,aACL5B,KAAKsC,YACLtC,KAAK8D,cACLrC,EAAsBpB,IAAIL,MAAM2E,iBAIlC,GAAqC,GAAjCX,EAAuBtE,OACzB,MAAO,WAET,IAAImG,EAAYzC,EACd,IAAItE,aAAa,IAAK,WACtBkB,KAAK4B,aACL5B,KAAKsC,YACL,IAAIxD,aAAa,IAAK,WACtB,MAEEgH,EAAc9B,EAAuB,GACrC+B,EAAY/B,EAAuBA,EAAuBtE,OAAS,GAGjEgD,EACFL,EAA2BrC,KAAK4B,aAAc5B,KAAKsC,aAGvD,OAAII,EAAsBoD,EACjB,SACLpD,GAAuBqD,GAAaA,EAAYF,EAC3C,QACF,kCAGT,WAIE,IAAK7F,KAAK4B,aAAc,OADP,KAEjB,GAAkB,YAAd5B,KAAKgG,MACP,OAHe,KAKjB,IAAIhC,EAAyBH,EAC3B7D,KAAK4B,aACL5B,KAAKsC,YACLtC,KAAK8D,cACLrC,EAAsBpB,IAAIL,MAAM2E,iBAE9BmB,EAAc9B,EAAuB,GACrC+B,EAAY/B,EAAuBA,EAAuBtE,OAAS,GAGjEgD,EACFL,EAA2BrC,KAAK4B,aAAc5B,KAAKsC,aAGvD,GAAII,EAAsBoD,EACxB,OAAO7E,IAAIwE,QAAQ,GAGrB,GAAI/C,GAAuBqD,EACzB,OAAO9E,IAAIwE,QAAQ,KAGrB,IAAIQ,WAxPN3C,EACAQ,GAOA,IAAIoC,EACJ,IAAKA,EAAcpC,EAAcpE,OAAS,EACrCwG,GAAe,KACXpC,EAAcoC,IAAgB5C,GAAUA,EAASQ,EAAcoC,EAAc,IACjFA,KAIL,IAAIJ,EAAchC,EAAcoC,GAahC,OAAQA,GAHiB5C,EAASwC,IAPlBhC,EAAcoC,EAAc,GAOkBJ,KAH3C,GAFRhC,EAAcpE,OAEM,IAiOdyG,CACbzD,EACAsB,GAEF,OAAO/C,IAAIwE,QAAQ,IAAMQ,2BAG3B,WACE,kBCtfEG,EAAuBpF,OAAOqF,QAAQC,UAAUC,QAChDC,EAAkBxF,OAAOyF,UAEzBC,aACJ,wBACE1G,KAAK2G,MAAQ,UACb3G,KAAK4G,cAAgB5G,KAAK6G,aAAe,KACzC7G,KAAK8G,QAAU,IAAIC,QAAQ,SAACC,EAASC,GACnCjC,EAAK4B,cAAgBI,EACrBhC,EAAK6B,aAAeI,+BAGxBD,QAAA,SAAQxG,GACNR,KAAK2G,MAAQ,WACb3G,KAAK4G,cAAcpG,MAErByG,OAAA,SAAOC,GACLlH,KAAK2G,MAAQ,WAEb3G,KAAK8G,cAAc,cACnB9G,KAAK6G,aAAaK,SAItB,SAASC,EAAmB/G,GAC1BA,EAAQgH,aAAe,IAAIV,EAE3BW,sBAAsB,WAEC,OADAjH,EAAQkH,SAASnF,aAEpCoF,EAAYnH,KAIlB,SAASoH,IACP,WAAWC,aAAa,6BAA8B,cAOxD,SAASC,EAAetH,EAASI,GAC/B,GAAc,OAAVA,EACF,OAAOA,EAET,GAAqB,iBAAVA,EACP,UAAUiH,kCACejH,sCACrB,qBAGR,IAAMmH,EAAQC,EAAUxH,GAExB,OAAOa,IAAIwE,QADKkC,EAAQ,IAAMnH,EAAQmH,EAAQ,GAQhD,SAASE,EAAiBzH,EAASI,GACjC,GAAKJ,EAAQkH,SAaN,CAEL,GAAc,OAAV9G,EACF,OAAOA,EAET,GAAmB,YAAfA,EAAMC,KAAoB,CAC5B,IAAMqH,EAAWF,EAAUxH,GAC3B,OAAOI,EAAMA,MAAQsH,EAAW,IAGlC,UAAUL,aACN,sEACA,qBAvBJ,GAAa,MAATjH,GAAkC,iBAAVA,EAC1B,OAAOA,EAET,IAAMuH,EAAgBvH,EAAMwH,GAAG,MAC/B,GAAIC,YACF,OAAOF,EAAcvH,MAEvB,UAAUiH,aACN,qFAEA,qBA8HR,SAASS,EAA2B9H,GAClC,GAAKA,EAAQ+H,iBAAoD,WAAjC/H,EAAQ+H,gBAAgBxB,OAGzB,YAA3BvG,EAAQgI,MAAMC,UAAlB,CAGAjI,EAAQ+H,gBAAgBnB,QAAQ5G,EAAQgI,OAExChI,EAAQkE,UAAUgE,QAMlB,IAAMC,EACJ,IAAIC,YAAY,SACA,CAAEC,OAAQ,CACRtG,YAAa/B,EAAQgI,MAAMjG,YAC3BD,aAAc9B,EAAQgI,MAAMd,SAASnF,eAEzDuG,OAAOvH,eAAeoH,EAAe,cAAe,CAClDlI,IAAK,WAAa,YAAYoI,OAAOtG,eAEvCuG,OAAOvH,eAAeoH,EAAe,eAAgB,CACnDlI,IAAK,WAAa,YAAYoI,OAAOvG,gBAGvCmF,sBAAsB,WACpBsB,eAAe,WACbvI,EAAQkE,UAAUsE,cAAcL,QAKtC,SAASM,EAAsBzI,GAC7B,OAAoC,OAAhCA,EAAQ0I,oBACH1I,EAAQ0I,oBACV1I,EAAQkE,UAAUyE,aAG3B,SAASC,EAAyB5I,GACI,OAAhCA,EAAQ0I,sBACV1I,EAAQkE,UAAUyE,aAAe3I,EAAQ0I,oBACzC1I,EAAQ0I,oBAAsB,MAIlC,SAASG,EAAqB7I,GAC5B,IAAKA,EAAQkH,SACX,YAEF,IAAMpF,EAAe2F,EAAiBzH,EAASA,EAAQkH,SAASnF,aAChE,GAAqB,OAAjBD,EACF,YAEF,GAA0B,OAAtB9B,EAAQ8I,UACV,YAEF,IAAI/G,GACCD,EAAe9B,EAAQ8I,WAAa9I,EAAQkE,UAAUyE,aAM3D,OAHoB,GAAhB5G,IACFA,EAAc,GAETA,EAGT,SAASgH,EAAmB/I,EAAS+B,GACnC,IAAK/B,EAAQkH,SACX,YAEF,IAAMpF,EAAe2F,EAAiBzH,EAASA,EAAQkH,SAASnF,aAChE,OAAoB,MAAhBD,OAGGA,EAAeC,EAAc/B,EAAQkE,UAAUyE,aAGxD,SAASK,EAAoBhJ,EAASiJ,EAASC,GAC7C,GAAKlJ,EAAQkH,SAAb,CAQA,IAAIiC,EACAF,EAAUxB,EAAiBzH,EAASA,EAAQgI,MAAMjG,aACxC8G,EAAqB7I,GAGnC,GAAImJ,GAAiD,MAArBnJ,EAAQ8I,YACnC9I,EAAQgI,MAAMoB,QAAS,CAQ1B,IAAMT,EAAeF,EAAsBzI,GACrCqJ,EAAa7B,EAAUxH,GACzBsJ,EAAWtJ,EAAQuJ,oBAEnBZ,EAAe,GAAKQ,GAA4BE,IACjC,OAAbC,GAAqBA,EAAWD,KAClCC,EAAWD,GACbrJ,EAAQwJ,SAAWP,EAAUE,EAA2BG,GAC/CX,EAAe,GAAKQ,GAA4B,IACzC,MAAZG,GAAoBA,EAAW,KACjCA,EAAW,GACbtJ,EAAQwJ,SAAWP,EAAUE,EAA2BG,GAC/B,GAAhBX,IAELM,GAAgC,OAArBjJ,EAAQwJ,WACrBxJ,EAAQ8I,UAAYC,EAAmB/I,EAASA,EAAQwJ,WAC1DxJ,EAAQwJ,SAAW,MAMvBC,EAAgBzJ,GAGhBA,EAAQuJ,oBAAsB9B,EAAiBzH,EACAA,EAAQgI,MAAMjG,aAK5C,YAFC/B,EAAQgI,MAAMC,WAGzBjI,EAAQ+H,kBACX/H,EAAQ+H,gBAAkB,IAAIzB,GACK,WAAjCtG,EAAQ+H,gBAAgBxB,QAEtB2C,EACFpB,EAA2B9H,GAE3B2G,QAAQC,UAAU8C,KAAK,WACrB5B,EAA2B9H,QAO7BA,EAAQ+H,iBACyB,YAAjC/H,EAAQ+H,gBAAgBxB,QAC1BvG,EAAQ+H,gBAAkB,IAAIzB,GAEG,UAA/BtG,EAAQkE,UAAU+D,WACpBjI,EAAQkE,UAAUgE,UAIxB,SAASV,EAAUxH,GAEjB,IAAM2J,EA9QR,SAA0B3J,GAIxB,IAAM2J,EAAS3J,EAAQgI,MAAM4B,OAAOC,YACpC,OAAO7J,EAAQ8J,kBAAoBH,EAyQpBG,CAAiB9J,GAIhC,OAAOwC,KAAKuH,IAAI,EAFbJ,EAAOK,MAAQL,EAAOM,SAAWN,EAAOO,WAAaP,EAAOjC,UASjE,SAAS+B,EAAgBzJ,GACvB,GAAKA,EAAQkH,SAGb,GAA0B,OAAtBlH,EAAQ8I,UAAoB,CAC9B,IAAMhH,EAAe2F,EAAiBzH,EACAA,EAAQkH,SAASnF,aACvD/B,EAAQkE,UAAUnC,aACbD,EAAe9B,EAAQ8I,WACpB9I,EAAQkE,UAAUyE,kBACI,OAArB3I,EAAQwJ,WACjBxJ,EAAQkE,UAAUnC,YAAc/B,EAAQwJ,UA6B5C,SAASW,EAAanK,EAASoK,GAC7B,GAAKpK,EAAQkH,SAAb,CAMA,IAAMmD,EACwB,UAA3BrK,EAAQgI,MAAMC,WAAyBjI,EAAQgI,MAAMoB,QAIpDkB,GAAyB,EAGzBC,EAAW,KA+BXhB,EAAsB9B,EAAiBzH,EACAA,EAAQgI,MAAMjG,aAIrD/B,EAAQwK,2BACVjB,EAAsB,KACtBvJ,EAAQwK,0BAA2B,GAGrC,IAAM7B,EAAeF,EAAsBzI,GACrCqJ,EAAa7B,EAAUxH,GAC7B,GAAI2I,EAAe,GAAKyB,IAAsC,MAAvBb,GACAA,EAAsB,GACtBA,GAAuBF,GAC5DkB,EAAW,UACF5B,EAAe,GAAKyB,IACI,MAAvBb,GAA+BA,GAAuB,GACvDA,EAAsBF,GAAa,CAC5C,GAAkBoB,UAAdpB,EAGF,YADArJ,EAAQkE,UAAUwG,OAGpBH,EAAWlB,OACc,GAAhBV,GAA4C,MAAvBY,IAC9BgB,EAAW,GAOG,MAAZA,IACFvK,EAAQ8I,UAAYyB,EACpBvK,EAAQwJ,SAAW,KACnBZ,EAAyB5I,IAI3BoE,EAAapE,EAAQkH,SAAUlH,EAAQkE,UAC1BlC,EAAc2I,KAAK3K,EAAQgI,QAIpChI,EAAQwJ,WACVxJ,EAAQ8I,UAAY,MAMlB9I,EAAQ4K,cACV5K,EAAQ4K,YAAc,KACtBN,GAAyB,IASF,OAArBtK,EAAQwJ,UAAkC,OAAbe,GAC5BF,GAAgD,OAAhCrK,EAAQ0I,uBAKzB1I,EAAQgH,eAAiBsD,IAC3BtK,EAAQgH,aAAe,MAIzByC,EAAgBzJ,GAGXA,EAAQgH,cACXD,EAAmB/G,GACrBA,EAAQ4K,YAAc,OAKtB5B,EAAoBhJ,GAAoB,GAAyB,KAGnE,SAASgC,EAAcF,GACrB,IAAM9B,EAAU6K,EAAgB5K,IAAIL,MACpC,GAAoB,MAAhBkC,EAAJ,CAQI9B,EAAQ4K,aACVzD,EAAYnH,GAGd,IAAMiI,EAAYrI,KAAKqI,UACvB,GAAiB,WAAbA,GAAuC,YAAbA,EAAyB,CACrD,IAAM6C,EAAiBrD,EAAiBzH,EAAS8B,GAEjD9B,EAAQkE,UAAUnC,aACb+I,EAAiBrD,EAAiBzH,EAASJ,KAAKkJ,YAC7ClJ,KAAK+I,aAII,YAAbV,GAA6D,GAAlCQ,EAAsBzI,KACnDA,EAAQwJ,SAAW,MACrBR,EAAoBhJ,GAAS,GAAO,QArBD,QAA/BA,EAAQkE,UAAU+D,WACpBjI,EAAQkE,UAAU6G,SAwBxB,SAAS5D,EAAYnH,GACQ,SAAvBA,EAAQ4K,YA5Zd,SAA4B5K,GAO1B,IAAMgL,EAAYvD,EAAiBzH,EAASA,EAAQkH,SAASnF,aAKpC,MAArB/B,EAAQ8I,WAAyC,MAApB9I,EAAQwJ,WACvCxJ,EAAQwJ,UACHwB,EAAYhL,EAAQ8I,WAAa9I,EAAQkE,UAAUyE,cAI1DC,EAAyB5I,GAGzBA,EAAQ8I,UAAY,KAGpB9I,EAAQgH,aAAaJ,QAAQ5G,EAAQgI,OAKrCgB,EAAoBhJ,GAAS,GAAO,GAGpCyJ,EAAgBzJ,GAChBA,EAAQ4K,YAAc,KA4XpBK,CAAmBjL,GACa,QAAvBA,EAAQ4K,aA/drB,SAA2B5K,GAIzB,IAAM8B,EAAe2F,EAAiBzH,EAASA,EAAQkH,SAASnF,aAChE,GAAwB,MAApB/B,EAAQwJ,SAUVZ,EAAyB5I,GACa,GAAlCA,EAAQkE,UAAUyE,aACpB3I,EAAQ8I,UAAYhH,GAEpB9B,EAAQ8I,UACFhH,EACE9B,EAAQwJ,SAAWxJ,EAAQkE,UAAUyE,aAC7C3I,EAAQwJ,SAAW,cAEU,OAAtBxJ,EAAQ8I,WACwB,OAAhC9I,EAAQ0I,oBAA8B,CAc/C,IAAMwC,GACDpJ,EAAe9B,EAAQ8I,WAAa9I,EAAQkE,UAAUyE,aAC3DC,EAAyB5I,GACzB,IAAM2I,EAAe3I,EAAQkE,UAAUyE,aACnB,GAAhBA,GACF3I,EAAQwJ,SAAW,KACnBxJ,EAAQ8I,UAAYhH,GAEpB9B,EAAQ8I,UAAYhH,EAAeoJ,EAAqBvC,EAKxD3I,EAAQgH,cAA8C,WAA9BhH,EAAQgH,aAAaT,OAC9CvG,EAAQgH,aAAaJ,QAAQ5G,EAAQgI,OAKxCgB,EAAoBhJ,GAAS,GAAO,GAGpCyJ,EAAgBzJ,GAChBA,EAAQ4K,YAAc,KAkapBO,CAAkBnL,GA0ItB,IAAI6K,EAAkB,IAAI7L,QAEboM,aACX,WAAYxB,EAAQ1C,GAClB,IAAMhD,EACD0F,aAAkBxD,EAChBwD,EAAS,IAAIxD,EAAgBwD,EAAQyB,GACtCC,EAAoBpE,aAAoB7C,EACxCgH,EAAoBC,OAAoB9G,EAAY0C,EAC1D2D,EAAgBlL,IAAIC,KAAM,CACxBsE,UAAWA,EACXgD,SAAUoE,EAAoBpE,OAAW1C,EACzCyD,UAAWqD,EAAoB,OAAS,KACxCtE,aAAc,KACde,gBAAiB,KAQjBe,UAAW,KACXU,SAAU,KACVD,oBAAqB,KAGrBiB,0BAA0B,EAK1B9B,oBAAqB,KACrBkC,YAAa,KAKbW,gBAAiB,KAGjBzB,iBAAkB,KAGlBF,OAAQ,KACR5B,MAAOpI,OA3Cb,2BAgcE4L,OAAA,WACE,IAAMxL,EAAU6K,EAAgB5K,IAAIL,MACpC,GAAKI,EAAQkH,SAAb,CAQA,IAAMyB,EAAeF,EAAsBzI,GACrC0H,EAAWF,EAAUxH,GAC3B,GAAoB,GAAhB2I,EACF,UAAUtB,aACN,oDACA,qBAEN,GAAIsB,EAAe,GAAiB8B,UAAZ/C,EACtB,UAAUL,aACN,8DACA,qBAINuB,EAAyB5I,GAOzB,IAAMuH,EAAQoB,EAAe,EAAI,EAAIjB,EAGrC9H,KAAKmC,YAAcuF,EAAetH,EAASuH,GAQ3C,IAAMzF,EAAe2F,EAAiBzH,EACAA,EAAQkH,SAASnF,aAE7B,OAAtB/B,EAAQ8I,WAAuC,OAAjBhH,IAC/B9B,EAAQ8I,UACJhH,EAAgByF,EAAQvH,EAAQkE,UAAUyE,cAOtB,SAAvB3I,EAAQ4K,aAAgD,OAAtB5K,EAAQ8I,YAC5C9I,EAAQwJ,SAAW,KACnBxJ,EAAQ4K,YAAc,KACtB5K,EAAQgH,aAAaJ,QAAQhH,OAMJ,QAAvBI,EAAQ4K,aAA+C,OAAtB5K,EAAQ8I,YAC3C9I,EAAQ4K,YAAc,KACtB5K,EAAQgH,aAAaJ,QAAQhH,OAM/BoJ,EAAoBhJ,GAAS,GAAM,QApEjCA,EAAQkE,UAAUsH,YAuEtBd,KAAA,WACE,IAAM1K,EAAU6K,EAAgB5K,IAAIL,MAC/BI,EAAQkH,SAKbiD,EAAanK,GAA0B,GAJrCA,EAAQkE,UAAUwG,UAOtBxC,MAAA,WACE,IAAMlI,EAAU6K,EAAgB5K,IAAIL,MACpC,GAAKI,EAAQkH,UASb,GAAsB,UAAlBtH,KAAKqI,UAAT,CAQA,IAAIsC,EAAW,KAaT5B,EAAe3I,EAAQkE,UAAUyE,aACjCjB,EAAWF,EAAUxH,GAE3B,GAAsC,OAAlCA,EAAQkE,UAAUnC,YACpB,GAAI4G,GAAgB,EAClB4B,EAAW,UACUE,UAAZ/C,EAGT,YADA1H,EAAQkE,UAAUgE,QAGlBqC,EAAW7C,EAOE,OAAb6C,IACFvK,EAAQ8I,UAAYyB,GAQK,QAAvBvK,EAAQ4K,YACV5K,EAAQ4K,YAAc,KAEtB5K,EAAQgH,aAAe,KAKpBhH,EAAQgH,cACXD,EAAmB/G,GACrBA,EAAQ4K,YAAa,cAlEnB5K,EAAQkE,UAAUgE,WAqEtBuD,QAAA,WACE,IAAMzL,EAAU6K,EAAgB5K,IAAIL,MAC9B+I,EAAeF,EAAsBzI,GACrCuJ,EACFvJ,EAAQwK,yBACJ,KAAO/C,EAAiBzH,EAASJ,KAAKmC,aACxC2J,EAA0CjB,UAAtBjD,EAAUxH,GAK9B2L,EACc,GAAhBhD,IACAA,EAAgB,GAAKY,EAAsB,IAAOmC,GACtD,IAAK1L,EAAQkH,WAAayE,EAIxB,OAHIA,IACF3L,EAAQ0I,qBAAuBD,EAAsBzI,SACvDA,EAAQkE,UAAUuH,UAIpB,GAA8B,YAA1BzL,EAAQkH,SAAStB,MACnB,UAAUyB,aACN,sDACA,qBAGNzH,KAAKgM,oBAAoBjD,GACzBwB,EAAanK,GAA0B,MAGzC4L,mBAAA,SAAmBC,GACjB,IAAM7L,EAAU6K,EAAgB5K,IAAIL,MAEpC,GADAI,EAAQ0I,oBAAsBmD,EACzB7L,EAAQkH,UAkBb,IAAIlH,EAAQgH,cAA8C,WAA9BhH,EAAQgH,aAAaT,MAGjD,OAV0B3G,KAAKqI,WAa7B,IAAK,OACL,IAAK,SACHW,EAAyB5I,GACzB,MAkBF,IAAK,WACH,IAAM8B,EAAe2F,EAAiBzH,EACAA,EAAQkH,SAASnF,aACjDoH,EAA4C,OAAjBrH,GAC5BA,EAAe9B,EAAQ8I,WAAa9I,EAAQkE,UAAUyE,aACrD,KAEJ3I,EAAQ8I,UADE,GAAR+C,EACkB/J,EAGA,MAAhBA,GAAoD,MAA5BqH,GACnBrH,EAAeqH,GAA4B0C,EAAO,KAE7DjD,EAAyB5I,GACzBgJ,EAAoBhJ,GAAS,GAAO,GACpCyJ,EAAgBzJ,GAChB,MAKF,QACEmK,EAAanK,GAAS,SAlExBA,EAAQkE,UAAU0H,mBAAmBC,MAsEzCC,QAAA,WACEjB,EAAgB5K,IAAIL,MAAMsE,UAAU4H,aAOtCf,OAAA,WACE,IAAM/K,EAAU6K,EAAgB5K,IAAIL,MAC/BI,EAAQkH,UAmBS,QAAlBtH,KAAKqI,YA9iCb,SAA2BjI,GAKpBA,EAAQ4K,cAKb5K,EAAQ4K,YAAc,KAGtBhC,EAAyB5I,GAIzBA,EAAQgH,aAAaH,OAAOO,KAI5BL,EAAmB/G,GACnBA,EAAQgH,aAAaJ,QAAQ5G,EAAQgI,QAyhCjC+D,CAAkB/L,GACdA,EAAQ+H,iBACyB,WAAjC/H,EAAQ+H,gBAAgBxB,OAC1BvG,EAAQ+H,gBAAgBlB,OAAOO,KAEjCpH,EAAQ+H,gBAAkB,IAAIzB,EAC9BtG,EAAQkE,UAAU6G,UAKpB/K,EAAQ8I,UAAY,KACpB9I,EAAQwJ,SAAW,KAGnBxF,EAAgBhE,EAAQkH,SAAUlH,EAAQkE,YAlCxClE,EAAQkE,UAAU6G,YAmFtBlG,iBAAA,SAAiB5D,EAAM+K,EAAU1H,GAC/BuG,EAAgB5K,IAAIL,MAAMsE,UAAUW,iBAAiB5D,EAAM+K,EACN1H,MAGvDK,oBAAA,SAAoB1D,EAAM+K,EAAU1H,GAClCuG,EAAgB5K,IAAIL,MAAMsE,UAAUS,oBAAoB1D,EAAM+K,EACN1H,MAG1DkE,cAAA,SAAcyD,GACZpB,EAAgB5K,IAAIL,MAAMsE,UAAUsE,cAAcyD,2BA3vBpD,WACE,IAAMjM,EAAU6K,EAAgB5K,IAAIL,MACpC,OAAKI,EAAQkH,UAKRlH,EAAQ4J,SACX5J,EAAQ4J,OAnMd,SAA2B5J,GACzB,IAAM4J,EAAS5J,EAAQkE,UAAU0F,OAC3BsC,EAAqBtC,EAAOuC,aAmB5BC,EAA2B,CAC/BC,MAAO,SAASC,GAEd1C,EAAOC,YAEP,IAAMF,EAAS2C,EAAOD,MAAMzC,GAE5B,GAAI5J,EAAQkH,SAAU,CAEpByC,EAAO4C,UAAYjF,EAAetH,EAAS2J,EAAO4C,WAClD5C,EAAO6C,QAAUlF,EAAetH,EAAS2J,EAAO6C,SAChD7C,EAAO8C,eACHnF,EAAetH,EAAS2J,EAAO8C,gBACnC,IAAMlF,EAAQC,EAAUxH,GAGxB2J,EAAOjC,SAAWH,EACd1G,IAAIwE,QAAQ,KAHWsE,EAAOO,YAC7B3C,EAAQoC,EAAOK,MAAQL,EAAOM,UAAYN,EAAOO,WAAa,GAExB3C,GACvC1G,IAAIwE,QAAQ,GAGhB,IAAMO,EAAQ5F,EAAQkH,SAAStB,MACzB8G,EAAO/C,EAAO+C,KAER,UAAT9G,GAA6B,aAAR8G,GAA+B,QAARA,IAC7C/C,EAAO9D,SAAW,MAEP,SAATD,GAA4B,YAAR8G,GAA8B,QAARA,IAC5C/C,EAAO9D,SAAW,WAIiBrB,IAAjCxE,EAAQkH,SAASnF,cACnB4H,EAAO4C,UAAY,MAGvB,OAAO5C,IAKLgD,EAAmB,CACvBN,MAAO,SAASC,EAAQM,GAItB,GAAI5M,EAAQuL,gBACV,OAAOvL,EAAQuL,gBAEjBvL,EAAQuL,gBAAkBe,EAAOD,MAAMzC,GACvC,IAAID,EAASrB,OAAOuE,OAAO,GAAI7M,EAAQuL,iBAqBvC,OAhBwB,OAApB5B,EAAOjC,UAAyC,SAApBiC,EAAOjC,UACjC1H,EAAQkH,WAIVyC,EAAOK,MAAQ,EACfL,EAAOM,SAAW,EAElBN,EAAOjC,SACHiC,EAAOO,YAFKP,EAAOO,WAlBE,IAkBkC,GAEnBP,EAAOO,WAAa,EAG5DgC,EAAmBG,MAAMzC,EAAQ,CAACD,KAGtC3J,EAAQ8J,iBAAmBH,EACpB3J,EAAQuL,kBAGbuB,EAAsB,CAC1BT,MAAO,SAASC,EAAQM,EAASG,GAE/B,GAAI/M,EAAQkH,SAAU,CACpB,IAAM5C,EAAUyI,EAAc,GAE9B,GAAiBtC,WADAnG,EAAQoD,SAEvB,MAAM5E,UACF,sEAIN,GAAmB2H,WADAnG,EAAQ4F,WAEzB,MAAMpH,UACJ,wEAMF9C,EAAQuL,iBACVe,EAAOD,MAAMzC,EAAQ,CAAC5J,EAAQuL,kBAEhCe,EAAOD,MAAMzC,EAAQmD,GAErB/M,EAAQuL,gBAAkB,OAQ9B,OALAvD,MAAQ,IAAIgF,MAAMpD,EArHF,CACd3J,IAAK,SAASzB,EAAKyO,GACjB,IAAM7N,EAASZ,EAAIyO,GACnB,MAAsB,mBAAX7N,EACFA,EAAOuL,KAAKf,GACdxK,GAGTO,IAAK,SAASnB,EAAKyO,EAAM7M,GAEvB,OADA5B,EAAIyO,GAAQ7M,QA6GhB4H,MAAMkF,kBAAoB,IAAIF,MAAMpD,EAAOsD,kBACPd,GACpCpE,MAAM6B,UAAY,IAAImD,MAAMpD,EAAOC,UAAW8C,GAC9C3E,MAAMmE,aAAe,IAAIa,MAAMpD,EAAOuC,aAAcW,GAC7C9E,MAmEcmF,CAAkBnN,IAE9BA,EAAQ4J,QAPN5J,EAAQkE,UAAU0F,YAS7B,SAAWwD,GACTvC,EAAgB5K,IAAIL,MAAMsE,UAAU0F,OAASwD,EAE7CpN,QAAQ4J,OAAS,2BAGnB,WACE,IAAM5J,EAAU6K,EAAgB5K,IAAIL,MAGpC,OAAOI,EAAQkH,UAAYlH,EAAQkE,UAAUgD,cAE/C,SAAamG,GAMX,IAAMC,EAAc1N,KAAKsH,SACzB,GAAIoG,GAAeD,EAAnB,CAIA,IAAME,EAAoB3N,KAAKqI,UAGzBsB,EAAsB3J,KAAKmC,YAE3B/B,EAAU6K,EAAgB5K,IAAIL,MAC9B4N,EAAMhG,EAAUxH,GAChB6F,EACF2H,EAAM,EAAI/F,EAAiBzH,EAASuJ,GAAuBiE,EAAM,EAI/DC,EAAsBH,aAAuBjJ,EAI7CqJ,EAAoBL,aAAuBhJ,EAQjDrE,EAAQwK,0BAA2B,EAInC,IAAMpB,EAAUxJ,KAAKwJ,QAUrB,GARIqE,GACFzJ,EAAgBhE,EAAQkH,SAAUlH,EAAQkE,WAOxCwJ,EAAkB,CAEpB1N,EAAQkH,SAAWmG,EAGnBzE,EAAyB5I,GAIzB,IAAMuK,EACFvK,EAAQkE,UAAUyE,cAAgB,EAAI,EAAInB,EAAUxH,GAGxD,OAAQuN,GAKN,IAAK,UACL,IAAK,WACHvN,EAAQ8I,UAAYyB,EAGpBnG,EAAapE,EAAQkH,SAAUlH,EAAQkE,UAC1BlC,EAAc2I,KAAK/K,OAChC,MAOF,IAAK,SACHI,EAAQwK,0BAA2B,EACnCxK,EAAQ8I,UAAY,KACpB9I,EAAQwJ,SACJ/B,EAAiBzH,EAASa,IAAIwE,QAAQ,IAAMQ,IAChD,MAGF,QACE7F,EAAQwJ,SAAW,KACnBxJ,EAAQ8I,UAAY,KAiCxB,OA1BIM,IACGpJ,EAAQgH,cACqB,YAA9BhH,EAAQgH,aAAaT,OACvBQ,EAAmB/G,GAGnBA,EAAQ4K,YADe,UAArB2C,EACoB,QAEA,QAWA,OAAtBvN,EAAQ8I,YACV9I,EAAQwJ,SAAW,WAKrBR,EAAoBhJ,GAAS,GAAO,GAKtC,GAAIA,EAAQkE,UAAUgD,UAAYmG,EAuBhC,MAAMvK,UAAU,yBAA2BuK,GAf3C,GALArJ,EAAgBhE,EAAQkH,SAAUlH,EAAQkE,WAC1ClE,EAAQkH,SAAW,KAIfuG,EAIF,OAH4B,OAAxBlE,IACFvJ,EAAQkE,UAAUnC,YAAc8D,EAAW2B,EAAUxH,IAE/CuN,GACN,IAAK,SACHvN,EAAQkE,UAAUgE,QAClB,MAEF,IAAK,UACL,IAAK,WACHlI,EAAQkE,UAAUwG,gCAQ5B,WACE,IAAM1K,EAAU6K,EAAgB5K,IAAIL,MACpC,OAAII,EAAQkH,SACHI,EAAetH,EAASA,EAAQ8I,WAElC9I,EAAQkE,UAAU4E,eAE3B,SAAc1I,GAEZ,IAAMJ,EAAU6K,EAAgB5K,IAAIL,MAEpC,GADAQ,EAAQqH,EAAiBzH,EAASI,GAC7BJ,EAAQkH,SAAb,CAcoB,MALCO,EAAiBzH,EACAA,EAAQkH,SAASnF,cAIN,MAArB/B,EAAQ8I,YAClC9I,EAAQwJ,SAAW,KAGnBC,EAAgBzJ,IAMlB,IAAMuJ,EAAsB9B,EAAiBzH,EAASJ,KAAKmC,aAG3D6G,EAAyB5I,GAGzBA,EAAQ8I,UAAY1I,EAGpBJ,EAAQwK,0BAA2B,EAcjCxK,EAAQwJ,SADgB,OAAtBxJ,EAAQ8I,WAAwD,GAAlC9I,EAAQkE,UAAUyE,aAC/B,KAEAY,EAKjBvJ,EAAQ4K,cACV5K,EAAQ4K,YAAc,KACtB5K,EAAQgH,aAAaJ,QAAQhH,OAMhCoJ,EAAoBhJ,GAAS,GAAM,GAGlCyJ,EAAgBzJ,QAhEdA,EAAQkE,UAAU4E,UAAY1I,2BAmElC,WACE,IAAMJ,EAAU6K,EAAgB5K,IAAIL,MACpC,OAAKI,EAAQkH,SAIJI,EAAetH,EADA,MAApBA,EAAQwJ,SACqBxJ,EAAQwJ,SAEVX,EAAqB7I,IAL3CA,EAAQkE,UAAUnC,iBAO7B,SAAgB3B,GACd,IAAMJ,EAAU6K,EAAgB5K,IAAIL,MAEpC,GADAQ,EAAQqH,EAAiBzH,EAASI,GAC7BJ,EAAQkH,UAAqB,MAAT9G,EAAzB,CAQA,IAAMuN,EAAgB3N,EAAQkH,SAAStB,MAGd,OAArB5F,EAAQwJ,UAA2C,OAAtBxJ,EAAQ8I,WACpB,YAAjB6E,GAAiE,GAAlC3N,EAAQkE,UAAUyE,aAEnD3I,EAAQwJ,SAAWpJ,EAEnBJ,EAAQ8I,UAAYC,EAAmB/I,EAASI,GAElDJ,EAAQwK,0BAA2B,EAId,YAAjBmD,IACF3N,EAAQ8I,UAAY,MAGtB9I,EAAQuJ,oBAAsB,KAGH,SAAvBvJ,EAAQ4K,cACV5K,EAAQwJ,SAAWpJ,EACnBwI,EAAyB5I,GACzBA,EAAQ8I,UAAY,KACpB9I,EAAQ4K,YAAc,KACtB5K,EAAQgH,aAAaJ,QAAQhH,OAI/BoJ,EAAoBhJ,GAAS,GAAM,QArCjCA,EAAQkE,UAAUnC,YAAc3B,4BAwCpC,WACE,OAAOyK,EAAgB5K,IAAIL,MAAMsE,UAAUyE,kBAE7C,SAAiBvI,GACf,IAAMJ,EAAU6K,EAAgB5K,IAAIL,MAEpC,GAAKI,EAAQkH,SAAb,CAMAlH,EAAQ0I,oBAAsB,KAI9B,IAAMa,EAAsB3J,KAAKmC,YAGjC/B,EAAQkE,UAAUyE,aAAevI,EAIN,OAAxBmJ,IACD3J,KAAKmC,YAAcwH,QAjBnBvJ,EAAQkE,UAAUyE,aAAevI,yBAoBrC,WACE,IAAMJ,EAAU6K,EAAgB5K,IAAIL,MACpC,IAAKI,EAAQkH,SACX,OAAOlH,EAAQkE,UAAU+D,UAE3B,IAAMlG,EAAc0F,EAAiBzH,EAASJ,KAAKmC,aAQnD,GAAoB,OAAhBA,GAA8C,OAAtB/B,EAAQ8I,WACT,MAAvB9I,EAAQ4K,YACV,MAAO,OAOT,GAA2B,SAAvB5K,EAAQ4K,aACe,OAAtB5K,EAAQ8I,WAA6C,QAAvB9I,EAAQ4K,YACzC,MAAO,SAQT,GAAmB,MAAf7I,EAAqB,CACvB,GAAI/B,EAAQkE,UAAUyE,aAAe,GACjC5G,GAAeyF,EAAUxH,GAC3B,MAAO,WACT,GAAIA,EAAQkE,UAAUyE,aAAe,GAAK5G,GAAe,EACvD,MAAO,WAIX,MAAO,oCAET,WAEE,OAAO8I,EAAgB5K,IAAIL,MAAMsE,UAAUkF,6BAG7C,WACE,IAAMpJ,EAAU6K,EAAgB5K,IAAIL,MACpC,OAAII,EAAQkH,WACDlH,EAAQgH,cACoB,WAA9BhH,EAAQgH,aAAaT,MAGvBvG,EAAQkE,UAAUkF,wBA4Q3B,WACE,OAAOyB,EAAgB5K,IAAIL,MAAMsE,UAAU0J,yBA2C7C,WACE,OAAO/C,EAAgB5K,IAAIL,MAAMsE,UAAU2J,cAE7C,SAAazN,GACXyK,EAAgB5K,IAAIL,MAAMsE,UAAU2J,SAAWzN,wBAEjD,WACE,OAAOyK,EAAgB5K,IAAIL,MAAMsE,UAAU4J,cAE7C,SAAa1N,GACXyK,EAAgB5K,IAAIL,MAAMsE,UAAU4J,SAAW1N,wBAEjD,WACE,OAAOyK,EAAgB5K,IAAIL,MAAMsE,UAAU6J,cAE7C,SAAa3N,GACXyK,EAAgB5K,IAAIL,MAAMsE,UAAU6J,SAAW3N,wBAGjD,WACE,IAAMJ,EAAU6K,EAAgB5K,IAAIL,MACpC,OAAKI,EAAQkH,UAGRlH,EAAQ+H,kBACX/H,EAAQ+H,gBAAkB,IAAIzB,GAEzBtG,EAAQ+H,gBAAgBrB,SALrB1G,EAAQkE,UAAU8J,4BAQ9B,WACE,IAAMhO,EAAU6K,EAAgB5K,IAAIL,MACpC,OAAKI,EAAQkH,UAGRlH,EAAQgH,eACXhH,EAAQgH,aAAe,IAAIV,EAC3BtG,EAAQgH,aAAaJ,QAAQhH,OAExBI,EAAQgH,aAAaN,SANnB1G,EAAQkE,UAAU+J,eC59C3BC,EAAsB,IAAIlP,QASxBmP,EAAa,CAEjB,CAAC,CANS,EACE,EACC,EACF,IAKX,CACE,CATQ,EAEG,GAQX,CATU,EAED,IAUX,CAAC,CAbS,GAaF,CAZI,EAED,GAUY,CAXV,IAab,CAAC,CAfS,GAeF,CAdI,GAcK,CAbJ,GAac,CAZhB,KAePC,aACJ,WAAYhO,GACV8N,EAAoBvO,IAAIC,KAAM,CAC5B0M,OAAQ,KACR+B,KAAM,QACNC,UAAW,EACXC,WAAY,CACV,CAAC,EAAG,MACJ,CAAC,EAAG,MACJ,CAAC,EAAG,MACJ,CAAC,EAAG,SAGR3O,KAAK0M,OAASlM,EAAMkM,OACpB1M,KAAKyO,KAAOjO,EAAMiO,MAAQ,QAC1BzO,KAAK0O,UAAYlO,EAAMkO,WAAa,EACpC1O,KAAK2O,WAAanO,EAAMmO,YAAc,kBACtC3O,KAAK4O,MAAQpO,EAAMoO,QAAS,gCAW9B,WACE,OAAON,EAAoBjO,IAAIL,MAAM0M,YATvC,SAAW5H,GACT,KAAMA,aAAmBuB,SAEvB,MADAiI,EAAoBjO,IAAIL,MAAM0M,OAAS,KACjCtL,MAAM,2CAEdkN,EAAoBjO,IAAIL,MAAM0M,OAAS5H,oBAYzC,WACE,OAAOwJ,EAAoBjO,IAAIL,MAAMyO,UANvC,SAASjO,IACiC,GAApC,CAAC,QAAS,OAAO0E,QAAQ1E,KAC7B8N,EAAoBjO,IAAIL,MAAMyO,KAAOjO,0BAoBvC,WACE,OAAO8N,EAAoBjO,IAAIL,MAAM0O,eAdvC,SAAclO,GACZ,IAAIkO,EAAYG,WAAWrO,GAE3B,GAAIkO,GAAaA,EACf,MAAMxL,UAAU,sBAIlB,GAAIwL,EAAY,GAAKA,EAAY,EAC/B,MAAMxL,UAAU,yCAClBoL,EAAoBjO,IAAIL,MAAM0O,UAAYA,0BA4B5C,WAEE,OAAOJ,EAAoBjO,IAAIL,MAC5B2O,WAAWG,IAAI,SAACC,GACf,OAAOA,EAAOzO,KAAK,MAEpBA,KAAK,UA3BV,SAAeE,GACb,IAAIwO,EAAUxO,EAAMyO,MAAM,MAC1B,GAAID,EAAQtP,OAAS,GAAKsP,EAAQtP,OAAS,EACzC,MAAMwD,UACJ,6DAGJ,IADA,IAAIgM,EAAgB,CAAC,GAAI,GAAI,GAAI,IACxBzP,EAAI,EAAGA,EAAIuP,EAAQtP,OAAQD,IAAK,CACvC,IAAI0P,EAAcxQ,EAAYqQ,EAAQvP,IAAI,GAC1C,IAAK0P,EAAa,MAAMjM,UAAU,kCAElC,IADA,IAAIkM,EAAYb,EAAWS,EAAQtP,OAAS,GAAGD,GACtC4P,EAAI,EAAGA,EAAID,EAAU1P,OAAQ2P,IACpCH,EAAcE,EAAUC,IAAM,CAC5BR,WAAWM,EAAY3O,OACvB2O,EAAY1O,MAIlB6N,EAAoBjO,IAAIL,MAAM2O,WAAaO,qBAY7C,SAAU1O,GAGR8N,EAAoBjO,IAAIL,MAAM4O,QAAUpO,WCxG5C,GH8DEkB,EAA+BwC,KAAK,CAClCmB,eE6CwB7E,GAC1B,GAAIA,EAAMkM,OAAQ,WAAW8B,EAAwBhO,IF7CnD8E,kBEuD4B1D,EAAcU,EAAagB,EAAQgM,GAE9C,SAAfhN,EAAwBA,EAAc,WAClB,UAAfA,IAAyBA,EAAc,cAgBhD,IAfA,IAXqB5C,EAWjB6P,EACF3N,GAAgBC,SAASC,iBACrB,CACE0N,KAAM,EACNC,MAAO7N,EAAagC,YACpB8L,IAAK,EACLC,OAAQ/N,EAAa8B,aACrBkM,MAAOhO,EAAagC,YACpBiM,OAAQjO,EAAa8B,cAEvB9B,EAAakO,wBAGfZ,EAAgBZ,EAAoBjO,IAAIiD,GAAQqL,WAChDoB,EAAkB,GACbtQ,EAAI,EAAGA,EAAI,EAAGA,IACrBsQ,EAAgB7L,KA1BD,YADIxE,EA6BfwP,EAAczP,IA5BT,GAAyBC,EAAO,IA6BrCD,EAAI,GAAK,EAAI8P,EAAiBM,OAASN,EAAiBK,OA7BG,IAG1DlQ,EAAO,IA8Bd,IAAIsQ,EACIT,EAAiBC,KAAOO,EArJrB,GAoJPC,EAIAT,EAAiBE,MACjBF,EAAiBC,KACjBO,EA1JO,GA2JPA,EA7JQ,GAsJRC,EAQGT,EAAiBG,IAAMK,EA/JpB,GAuJNC,EAWAT,EAAiBI,OACjBJ,EAAiBG,IACjBK,EApKM,GAqKNA,EAnKS,GAsKTE,EAAU3B,EAAoBjO,IAAIiD,GAAQsL,MAC1ClC,EAASpJ,EAAOoJ,OAAOoD,wBACvBpB,EAAYpL,EAAOoL,UAIvB,GAFmB,SAAfpL,EAAOmL,OAAiBC,EAAY,EAAIA,GAEzB,YAAfpM,EAA2B,CAC7B,IAAI4N,EACFxD,EAAOgD,IACPhD,EAAOmD,OAASnB,EAChBsB,EACApO,EAAae,UACf,OAAIsN,EACiB,OAAf3M,EAAOmL,KAAsB7L,KAAKuH,IAAI,EAAG+F,EAAQF,GAC9CpN,KAAKuN,IAAID,EAAOtO,EAAa6B,aAAeuM,GAEhC,OAAf1M,EAAOmL,KAAsByB,EAAQF,EAClCE,EAIT,IAAIA,EACFxD,EAAO8C,KACP9C,EAAOkD,MAAQlB,EACfsB,EACApO,EAAakB,WACf,OAAImN,EACiB,OAAf3M,EAAOmL,KAAsB7L,KAAKuH,IAAI,EAAG+F,EAAQF,GAC9CpN,KAAKuN,IAAID,EAAOtO,EAAa+B,YAAcqM,GAE/B,OAAf1M,EAAOmL,KAAsByB,EAAQF,EAClCE,MCjMVhP,QAAQC,eAAeH,OAAQ,iBAAkB,CAAER,MAAOiE,IAE3D,MAAMrD,MACJ,uFAIJ,IAAKF,QAAQC,eAAekF,QAAQC,UAAW,UAAW,CAAE9F,eFs+CpC4P,EAAW1L,GACjC,IAAM4C,EAAW5C,EAAQ4C,SAErBA,aAAoB7C,UACfC,EAAQ4C,SAEjB,IAAMhD,EAAY8B,EAAqBqG,MAAMzM,KAAM,CAACoQ,EAAW1L,IACzD2L,EAAiB,IAAI7E,EAAelH,EAAWgD,GAOrD,OALIA,aAAoB7C,IACtBH,EAAUgE,QACV+H,EAAevF,QAGVuF,KEn/CP,MAAMjP,MACJ,6FAGJ,IAAKF,QAAQC,eAAeH,OAAQ,YAAa,CAACR,MAAOgL,IACvD,MAAMpK,MAAM"}
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Resolve scroll offsets per\n * https://drafts.csswg.org/scroll-animations-1/#effective-scroll-offsets-algorithm\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @param scrollOffsets {Array}\n * @param fns {Array}\n * @returns {Array}\n */\nexport function resolveScrollOffsets(\n  scrollSource,\n  orientation,\n  scrollOffsets,\n  fns\n) {\n  // 1. Let effective scroll offsets be an empty list of effective scroll\n  // offsets.\n  let effectiveScrollOffsets = [];\n  // 2. Let first offset be true.\n  let firstOffset = true;\n\n  // 3. If scrollOffsets is empty\n  if(scrollOffsets.length == 0) {\n    // 3.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 3.2 Set first offset to false.\n    firstOffset = false;\n    // 3.3 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(100, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n  }\n  // 4. If scrollOffsets has exactly one element\n  else if(scrollOffsets.length == 1) {\n    // 4.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 4.2 Set first offset to false.\n    firstOffset = false;\n  }\n  // 5. For each scroll offset in the list of scrollOffsets, perform the\n  // following steps:\n  for (let i = 0; i < scrollOffsets.length; i++) {\n    // 5.1 Let effective offset be the result of applying the procedure\n    // to resolve a scroll timeline offset for scroll offset with the is\n    // first flag set to first offset.\n    let effectiveOffset = calculateScrollOffset(\n      firstOffset ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'),\n      scrollSource,\n      orientation,\n      scrollOffsets[i],\n      fns[i]);\n    //  5.2 If effective offset is null, the effective scroll offsets is empty and abort the remaining steps.\n    if(effectiveOffset === null)\n      return [];\n    // 5.3 Add effective offset into effective scroll offsets.\n    effectiveScrollOffsets.push(effectiveOffset);\n    // 5.4 Set first offset to false.\n    firstOffset = false;\n  }\n  // 6. Return effective scroll offsets.\n  return effectiveScrollOffsets;\n}\n\n/**\n * Compute scroll timeline progress per\n * https://drafts.csswg.org/scroll-animations-1/#progress-calculation-algorithm\n * @param offset {number}\n * @param scrollOffsets {Array}\n * @returns {number}\n */\nexport function ComputeProgress(\n  offset,\n  scrollOffsets\n) {\n  // 1. Let scroll offsets be the result of applying the procedure to resolve\n  // scroll timeline offsets for scrollOffsets.\n  // 2. Let offset index correspond to the position of the last offset in\n  // scroll offsets whose value is less than or equal to offset and the value\n  // at the following position greater than offset.\n  let offsetIndex;\n  for (offsetIndex = scrollOffsets.length - 2;\n       offsetIndex >= 0 && \n         !(scrollOffsets[offsetIndex] <= offset && offset < scrollOffsets[offsetIndex + 1]);\n       offsetIndex--) {\n  }\n  // 3. Let start offset be the offset value at position offset index in\n  // scroll offsets.\n  let startOffset = scrollOffsets[offsetIndex];\n  // 4. Let end offset be the value of next offset in scroll offsets after\n  // start offset.\n  let endOffset = scrollOffsets[offsetIndex + 1];\n  // 5. Let size be the number of offsets in scroll offsets.\n  let size = scrollOffsets.length;\n  // 6. Let offset weight be the result of evaluating 1 / (size - 1).\n  let offsetWeight = 1 / (size - 1);\n  // 7. Let interval progress be the result of evaluating\n  // (offset - start offset) / (end offset - start offset).\n  let intervalProgress =  (offset - startOffset) / (endOffset - startOffset);\n  // 8. Return the result of evaluating\n  // (offset index + interval progress) × offset weight.\n  return (offsetIndex + intervalProgress) * offsetWeight;\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n    updateInternal(this);\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n\n    //   if source's effective scroll range is null\n    if (effectiveScrollOffsets.length == 0)\n      return \"inactive\";\n\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    let progress = ComputeProgress(\n      currentScrollOffset,\n      effectiveScrollOffsets\n    );\n    return progress * timeRange;\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","MathOperation","operator","opt_name","opt_delimiter","set","this","name","delimiter","toString","details","get","join","cssOMTypes","value","unit","toLowerCase","displayUnit","CSSKeywordValue","arguments","CSSMathProduct","CSSMathNegate","window","CSS","Reflect","defineProperty","Error","type","forEach","installCSSOM","AUTO","scrollTimelineOptions","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolveScrollOffsets","scrollOffsets","fns","effectiveScrollOffsets","firstOffset","push","effectiveOffset","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","input","parse","evaluate","parsed","data","range","Number","isFinite","scrollerStyle","display","overflow","maxOffset","startOffset","endOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","offsetIndex","ComputeProgress","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","parseFloat","map","margin","margins","split","parsedMargins","parsedValue","positions","j","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> 3ca3860 (Add polyfill for CSSOM.)
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","calculateScrollOffset","autoValue","orientation","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","set","this","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","getComputedStyle","display","overflow","startOffset","endOffset","maxOffset","currentScrollOffset","scrollTop","scrollLeft","phase","Math","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","details","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> 047bdea (Rebuild)
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","calculateScrollOffset","autoValue","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","set","this","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","display","overflow","startOffset","endOffset","maxOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","details","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> d16508c (Update build files)
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  if (!window.CSSUnitValue) {\n    class CSSUnitValue {\n      constructor(value, unit) {\n        this.value_ = value;\n        this.unit_ = unit;\n      }\n\n      get value() {\n        return this.value_;\n      }\n\n      get unit() {\n        return this.unit_;\n      }\n\n      displayUnit() {\n        switch(this.unit_) {\n          case 'percent':\n            return '%';\n          case 'number':\n            return '';\n          default:\n            return this.unit_.toLowerCase();\n        }\n      }\n\n      toString() {\n        return `${this.value}${this.displayUnit()}`;\n      }\n    }\n    window.CSSUnitValue = CSSUnitValue;\n  }\n\n  if (!window.CSSKeywordValue) {\n    class CSSKeywordValue {\n      constructor(value) {\n        this.value_ = value;\n      }\n\n      get value() {\n        return this.value_;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    }\n    window.CSSKeywordValue = CSSKeywordValue;\n  }\n\n  if (!window.CSSNumericArray) {\n    class CSSNumericArray {\n      constructor() {\n        this.values = arguments.map(v => new CSSUnitValue(v, 'number'));\n      }\n      toArray() {\n        return this.values.map(v => v.value);\n      }\n    }\n    window.CSSNumericArray = CSSNumericArray;\n  }\n\n  if (!window.CSSMathSum) {\n    class CSSMathSum {\n      constructor() {\n        this.values = new CSSNumericArray(arguments);\n      }\n\n      toString() {\n        return this.values.toArray().join(' + ');\n      }\n    }\n    window.CSSMathSum = CSSMathSum;\n  }\n\n  if (!window.CSSMathMax) {\n    class CSSMathMax {\n      constructor() {\n        this.values = new CSSNumericArray(arguments);\n      }\n\n      toString() {\n        return 'max(' + this.values.toArray().join(', ') + ')';\n      }\n    }\n    window.CSSMathMax = CSSMathMax;\n  }\n\n  if (!window.CSSMathMin) {\n    class CSSMathMin {\n      constructor() {\n        this.values = new CSSNumericArray(arguments);\n      }\n\n      toString() {\n        return 'min(' + this.values.toArray().join(', ') + ')';\n      }\n    }\n    window.CSSMathMin = CSSMathMin;\n  }\n\n  if (!window.CSS)\n    window.CSS = {};\n\n  [\n    'number',\n    'percent',\n    // Length units\n    'em',\n    'ex',\n    'px',\n    'cm',\n    'mm',\n    'in',\n    'pt',\n    'pc',  // Picas\n    'Q',  // Quarter millimeter\n    'vw',\n    'vh',\n    'vmin',\n    'vmax',\n    'rems',\n    \"ch\",\n    // Angle units\n    'deg',\n    'rad',\n    'grad',\n    'turn',\n    // Time units\n    'ms',\n    's',\n    'Hz',\n    'kHz',\n    // Resolution\n    'dppx',\n    'dpi',\n    'dpcm',\n    // Other units\n    \"fr\"\n  ].forEach((name) => {\n    if (!CSS[name]) {\n      CSS[name] = (value) => {\n        return new CSSUnitValue(value, name);\n      }\n    }\n  });\n\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","window","value","unit","this","value_","unit_","displayUnit","toLowerCase","toString","CSSKeywordValue","CSSNumericArray","values","arguments","map","v","toArray","join","CSSMathMax","CSSMathMin","CSS","forEach","name","AUTO","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","set","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","display","overflow","startOffset","endOffset","maxOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","details","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margin","margins","split","parsedMargins","parsedValue","positions","j","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> c4ecd0b (Add polyfill for CSSOM.)
<<<<<<< HEAD
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  if (!window.CSSUnitValue) {\n    function displayUnit(unit) {\n      switch(unit) {\n        case 'percent':\n          return '%';\n        case 'number':\n          return '';\n        default:\n          return unit.toLowerCase();\n      }\n    }\n    class ProxyCSSUnitValue {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    }\n    window.CSSUnitValue = ProxyCSSUnitValue;\n  }\n\n  if (!window.CSSKeywordValue) {\n    class ProxyCSSKeywordValue {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    }\n    window.CSSKeywordValue = ProxyCSSKeywordValue;\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class ProxyMathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  if (!window.CSSMathSum) {\n    class ProxyCSSMathSum extends ProxyMathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    }\n    window.CSSMathSum = ProxyCSSMathSum;\n  }\n\n  if (!window.CSSMathProduct) {\n    class ProxyCSSMathProduct extends ProxyMathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    }\n    window.CSSMathProduct = ProxyCSSMathProduct;\n  }\n\n  if (!window.CSSMathNegate) {\n    class ProxyCSSMathNegate extends ProxyMathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    }\n    window.CSSMathNegate = ProxyCSSMathNegate;\n  }\n\n  if (!window.CSSMathInvert) {\n    class ProxyCSSMathNegate extends ProxyMathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    }\n    window.CSSMathNegate = ProxyCSSMathNegate;\n  }\n\n  if (!window.CSSMathMax) {\n    class ProxyCSSMathMax extends ProxyMathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    }\n    window.CSSMathMax = ProxyCSSMathMax;\n  }\n\n  if (!window.CSSMathMin) {\n    class ProxyCSSMathMin extends ProxyMathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n    window.CSSMathMin = ProxyCSSMathMin;\n  }\n\n  if (!window.CSS)\n    window.CSS = {};\n\n  [\n    'number',\n    'percent',\n    // Length units\n    'em',\n    'ex',\n    'px',\n    'cm',\n    'mm',\n    'in',\n    'pt',\n    'pc',  // Picas\n    'Q',  // Quarter millimeter\n    'vw',\n    'vh',\n    'vmin',\n    'vmax',\n    'rems',\n    \"ch\",\n    // Angle units\n    'deg',\n    'rad',\n    'grad',\n    'turn',\n    // Time units\n    'ms',\n    's',\n    'Hz',\n    'kHz',\n    // Resolution\n    'dppx',\n    'dpi',\n    'dpcm',\n    // Other units\n    \"fr\"\n  ].forEach((name) => {\n    if (!CSS[name]) {\n      CSS[name] = (value) => {\n        return new CSSUnitValue(value, name);\n      }\n    }\n  });\n\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","window","value","unit","set","this","toString","details","get","toLowerCase","displayUnit","CSSKeywordValue","ProxyMathOperation","operator","opt_name","opt_delimiter","name","delimiter","join","arguments","CSSMathProduct","CSSMathNegate","CSSMathInvert","CSSMathMax","CSSMathMin","CSS","forEach","installCSSOM","AUTO","scrollTimelineOptions","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","display","overflow","startOffset","endOffset","maxOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","map","margin","margins","split","parsedMargins","parsedValue","positions","j","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> fea05b5 (Add missing features)
=======
=======
>>>>>>> e7d4bb4 (Update build files)
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Resolve scroll offsets per\n * https://drafts.csswg.org/scroll-animations-1/#effective-scroll-offsets-algorithm\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @param scrollOffsets {Array}\n * @param fns {Array}\n * @returns {Array}\n */\nexport function resolveScrollOffsets(\n  scrollSource,\n  orientation,\n  scrollOffsets,\n  fns\n) {\n  // 1. Let effective scroll offsets be an empty list of effective scroll\n  // offsets.\n  let effectiveScrollOffsets = [];\n  // 2. Let first offset be true.\n  let firstOffset = true;\n\n  // 3. If scrollOffsets is empty\n  if(scrollOffsets.length == 0) {\n    // 3.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 3.2 Set first offset to false.\n    firstOffset = false;\n    // 3.3 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(100, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n  }\n  // 4. If scrollOffsets has exactly one element\n  else if(scrollOffsets.length == 1) {\n    // 4.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 4.2 Set first offset to false.\n    firstOffset = false;\n  }\n  // 5. For each scroll offset in the list of scrollOffsets, perform the\n  // following steps:\n  for (let i = 0; i < scrollOffsets.length; i++) {\n    // 5.1 Let effective offset be the result of applying the procedure\n    // to resolve a scroll timeline offset for scroll offset with the is\n    // first flag set to first offset.\n    let effectiveOffset = calculateScrollOffset(\n      firstOffset ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'),\n      scrollSource,\n      orientation,\n      scrollOffsets[i],\n      fns[i]);\n    //  5.2 If effective offset is null, the effective scroll offsets is empty and abort the remaining steps.\n    if(effectiveOffset === null)\n      return [];\n    // 5.3 Add effective offset into effective scroll offsets.\n    effectiveScrollOffsets.push(effectiveOffset);\n    // 5.4 Set first offset to false.\n    firstOffset = false;\n  }\n  // 6. Return effective scroll offsets.\n  return effectiveScrollOffsets;\n}\n\n/**\n * Compute scroll timeline progress per\n * https://drafts.csswg.org/scroll-animations-1/#progress-calculation-algorithm\n * @param offset {number}\n * @param scrollOffsets {Array}\n * @returns {number}\n */\nexport function ComputeProgress(\n  offset,\n  scrollOffsets\n) {\n  // 1. Let scroll offsets be the result of applying the procedure to resolve\n  // scroll timeline offsets for scrollOffsets.\n  // 2. Let offset index correspond to the position of the last offset in\n  // scroll offsets whose value is less than or equal to offset and the value\n  // at the following position greater than offset.\n  let offsetIndex;\n  for (offsetIndex = scrollOffsets.length - 2;\n       offsetIndex >= 0 && \n         !(scrollOffsets[offsetIndex] <= offset && offset < scrollOffsets[offsetIndex + 1]);\n       offsetIndex--) {\n  }\n  // 3. Let start offset be the offset value at position offset index in\n  // scroll offsets.\n  let startOffset = scrollOffsets[offsetIndex];\n  // 4. Let end offset be the value of next offset in scroll offsets after\n  // start offset.\n  let endOffset = scrollOffsets[offsetIndex + 1];\n  // 5. Let size be the number of offsets in scroll offsets.\n  let size = scrollOffsets.length;\n  // 6. Let offset weight be the result of evaluating 1 / (size - 1).\n  let offsetWeight = 1 / (size - 1);\n  // 7. Let interval progress be the result of evaluating\n  // (offset - start offset) / (end offset - start offset).\n  let intervalProgress =  (offset - startOffset) / (endOffset - startOffset);\n  // 8. Return the result of evaluating\n  // (offset index + interval progress) × offset weight.\n  return (offsetIndex + intervalProgress) * offsetWeight;\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n    updateInternal(this);\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n\n    //   if source's effective scroll range is null\n    if (effectiveScrollOffsets.length == 0)\n      return \"inactive\";\n\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    let progress = ComputeProgress(\n      currentScrollOffset,\n      effectiveScrollOffsets\n    );\n    return progress * timeRange;\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","MathOperation","operator","opt_name","opt_delimiter","set","this","name","delimiter","toString","details","get","join","cssOMTypes","value","unit","toLowerCase","displayUnit","CSSKeywordValue","arguments","CSSMathProduct","CSSMathNegate","window","CSS","Reflect","defineProperty","Error","type","forEach","installCSSOM","AUTO","scrollTimelineOptions","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolveScrollOffsets","scrollOffsets","fns","effectiveScrollOffsets","firstOffset","push","effectiveOffset","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","input","parse","evaluate","parsed","data","range","Number","isFinite","scrollerStyle","display","overflow","maxOffset","startOffset","endOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","offsetIndex","ComputeProgress","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","parseFloat","map","margin","margins","split","parsedMargins","parsedValue","positions","j","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","keyframes","apply","proxyAnimation"],"mappings":"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"}
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","calculateScrollOffset","autoValue","orientation","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","set","this","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","getComputedStyle","display","overflow","startOffset","endOffset","maxOffset","currentScrollOffset","scrollTop","scrollLeft","phase","Math","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","details","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> 047bdea (Rebuild)
<<<<<<< HEAD
>>>>>>> 916650c (Rebuild)
=======
=======
{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","calculateScrollOffset","autoValue","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","set","this","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","display","overflow","startOffset","endOffset","maxOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","details","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}
>>>>>>> d16508c (Update build files)
>>>>>>> e7d4bb4 (Update build files)
=======
>>>>>>> 3ca3860 (Add polyfill for CSSOM.)
