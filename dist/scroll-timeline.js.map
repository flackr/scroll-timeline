{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tick(timelineTime);\n\n    // const animation = animations[i];\n    // // The web-animations spec says to throw a TypeError if you try to seek to\n    // // an unresolved time value from a resolved time value, so to polyfill the\n    // // expected behavior we cancel the underlying animation.\n    // if (timelineCurrentTime == null) {\n    //   if (animation.playState === \"paused\") animation.cancel();\n    // } else if (animation.playState == 'running') {\n    //   animation.currentTime =\n    //       (timelineCurrentTime - animation.startTime) * animation.playbackRate;\n    // }\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange, calculateTargetEffectEnd(animations[i]));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let index = animations.indexOf(animation);\n  if (index === -1) return;\n  animations.splice(index, 1);\n}\n\nfunction find(scrollTimeline, animation) {\n  const animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let index = animations.indexOf(animation);\n  return (index === -1) ? null : animations[index];\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function addAnimation(scrollTimeline, animation, options) {\n  if (!find(scrollTimeline, animation)) {\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    animations.push(animation);\n  }\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n    //   if source's layout box is not a scroll container\"\n    if (scrollerStyle.overflow == \"visible\" || scrollerStyle.overflow == \"clip\")\n      return \"inactive\";\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\n/**\n * Decides whether to use native Element.prototype.animate function in regular fashion or pass it to our polyfill\n *  so its current time is driven by scroll event\n * @param keyframes {Object} array of keyframe objects\n * @param options {Object} WAAPI options object\n * @returns {Function}\n */\n\nfunction createReadyPromise(details) {\n  let sequence = ++details.sequence;\n  let promise = details.readyPromise = new Promise((resolve, reject) => {\n    // TODO: We should actually not apply the animation until this is\n    // resolved.\n    requestAnimationFrame(() => {\n      // If this promise was replaced, this animation was aborted.\n      if (details.readyPromise == promise)\n        details.readyPromise = null;\n      if (details.aborted.has(sequence)) {\n        details.aborted.delete(sequence);\n        // Reject with a non-visible AbortError.\n        reject(new DOMException(\"Animation aborted\", \"AbortError\"));\n      } else {\n        // Apply pending playbackRate\n        if (typeof details.pendingPlaybackRate == 'number') {\n          const previousCurrentTime = details.animation.currentTime;\n          details.animation.playbackRate = details.pendingPlaybackRate;\n          const timelineTime = details.timeline.currentTime;\n          details.startTime = details.pendingPlaybackRate ?\n              timelineTime - previousCurrentTime / details.pendingPlaybackRate :\n              previousCurrentTime;\n          details.pendingPlaybackRate = null;\n        }\n        switch(details.playState) {\n          case 'paused':\n            details.startTime = null;\n            break;\n\n          case 'running':\n          case 'finished':\n            details.holdTime = null;\n        }\n        resolve();\n      }\n    });\n  });\n}\n\nfunction getAnimationProperty(details, name) {\n  if (details.timeline && (name in details))\n    return details[name];\n  else\n    return details.animation[name];\n}\n\nfunction setAnimationProperty(details, name, value) {\n  if (details.timeline && (name in details))\n    details[name] = value;\n  else\n    details.animation[name] = value;\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction updateFinishedState(details) {\n  if (!details.timeline)\n    return;\n\n  const isFinished = () => {\n    if (details.playState == 'paused')\n      return false;\n\n    const playbackRate = effectivePlaybackRate(details);\n    const currentTime = details.animation.currentTime;\n    if (playbackRate < 0 && currentTime <= 0)\n      return true;\n    if (playbackRate > 0 &&\n        currentTime >= details.animation.effect.getTiming().duration)\n      return true;\n\n    return false;\n  };\n\n  if (isFinished()) {\n    if (details.playState != 'finished') {\n      details.playState = 'finished';\n      // TODO: Ensure that finished promise and events fire.\n      // Possibly best to call finish after rAF though that would force a snap\n      // to the boundary, which is not quite correct.\n    }\n  } else if (details.playState == 'finished') {\n    details.playState = 'running';\n  }\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\n// Hack for testing / debugging\nwindow.proxyAnimations = proxyAnimations;\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      sequence: 0, /* Used to track ready promises. */\n      aborted: new Set(), /* Aborted sequences. */\n    });\n  }\n\n  // -----------------------------------------\n  // Helper method\n  // -----------------------------------------\n\n  tick(timelineTime) {\n    if (timelineTime != null && this.playState == 'running') {\n      proxyAnimations.get(this).animation.currentTime =\n          (timelineTime - this.startTime) * this.playbackRate;\n      updateFinishedState(proxyAnimations.get(this));\n    }\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return getAnimationProperty(proxyAnimations.get(this), 'effect');\n  }\n  set effect(newEffect) {\n    setAnimationProperty(proxyAnimations.get(this), 'effect', newEffect);\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    const details = proxyAnimations.get(this);\n\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n    const previousCurrentTime = this.currentTime;\n    const previousPlayState = this.playState;\n    const playbackRate = effectivePlaybackRate(details);\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    details.resetCurrentTimeOnResume = false;\n    if (toScrollTimeline) {\n      // Cannot assume that the underlying native implementation supports\n      // mutable timelines. Thus, we leave its timeline untouched, and simply\n      // ensure that it is in the paused state.\n      details.timeline = newTimeline;\n      applyPendingPlaybackRate(details);\n      details.animation.pause();\n      switch(previousPlayState) {\n        case 'idle':\n          details.playState = 'idle';\n          details.holdTime = null;\n          details.startTime = null;\n          break;\n\n        case 'paused':\n          details.playState = 'paused';\n          details.resetCurrentTimeOnResume = true;\n          details.animation.currentTime = previousCurrentTime;\n          break;\n\n        case 'running':\n        case 'finished':\n          details.playState = 'running';\n          details.startTime =\n              playbackRate < 0 ? details.animation.effect.getTiming().duration\n                               : 0;\n          details.holdTime = null;\n          break;\n      }\n      addAnimation(details.timeline, this);\n      if (pending)\n        createReadyPromise(details);\n    } else {\n      // TODO: polyfill mutable timeline support. Cannot assume the native\n      // animation supports mutable timelines. Could keep a list of detached\n      // timelines and pump updates to current time via rAF.\n      details.animation.timeline = newTimeline;\n      if (fromScrollTimeline) {\n        // TODO: sync pending status & play state (ready promise).\n        details.timeline = null;\n        details.animation.currentTime = previousCurrentTime;\n      }\n    }\n  }\n\n  get startTime() {\n    return getAnimationProperty(proxyAnimations.get(this), 'startTime');\n  }\n  set startTime(value) {\n    const previousCurrentTime = this.currentTime;\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    details.resetCurrentTimeOnResume = false;\n    applyPendingPlaybackRate(details);\n    details.readyPromise = null;\n    if (typeof value == 'number') {\n      details.holdTime = null;\n      details.startTime = value;\n      details.playState = 'running';\n      const timelineTime = details.timeline.currentTime;\n      details.animation.currentTime =\n          (timelineTime - details.startTime) * this.playbackRate;\n      updateFinishedState(details);\n    } else {\n      details.holdTime = previousCurrentTime;\n      details.startTime = null;\n      details.playState =\n          (typeof previousCurrentTime == 'number') ? 'paused' : 'idle';\n    }\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      if (!details.playState || details.playState == 'idle')\n        return null;\n      if (details.playState == 'running' &&\n          details.timeline.phase == 'inactive')\n        return null;\n    }\n    return getAnimationProperty(details, 'currentTime');\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    setAnimationProperty(details, 'currentTime', value);\n    details.resetCurrentTimeOnResume = false;\n    if (details.timeline) {\n       // Update the start or the hold time of the proxy animation depending\n       // on the play sate.\n       const timelineTime = details.timeline.currentTime;\n       const playbackRate = this.playbackRate;\n       switch(details.playState) {\n        case 'running':\n        case 'finished':\n          // TODO: handle value == null or playbackRate == 0.\n          details.startTime = timelineTime - value / playbackRate;\n          details.holdTime = null;\n          break;\n\n        default:\n           details.playState = value ? 'paused' : 'idle';\n           details.holdTime = value;\n           details.startTime = null;\n           break;\n       }\n       updateFinishedState(details);\n    }\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n    details.animation.playbackRate = value;\n    if (details.timeline) {\n      details.pendingPlaybackRate = null;\n      updateFinishedState(details);\n    }\n  }\n\n  get playState() {\n    return getAnimationProperty(proxyAnimations.get(this), 'playState');\n  }\n\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return !!details.readyPromise;\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    details.animation.finish();\n    if (details.timeline) {\n      const previousCurrentTime = details.animation.currentTime;\n      details.playState = \"finished\";\n      removeAnimation(details.timeline, details.animation);\n      // Force reevaluation of the surrogate's start time.\n      this.currentTime = previousCurrentTime;\n      if (this.pending && !hasActiveTimeline(details)) {\n        // A pending promise is not resolved while the timeline is inactive.\n        details.holdTime = previousCurrentTime;\n        details.startTime = null;\n      } else {\n        details.readyPromise = null;\n      }\n    }\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    // TODO: Still some work to be done even if the animation is already\n    // playing.\n    if (details.playState == 'running')\n      return;\n\n    const previousCurrentTime = this.currentTime;\n    details.playState = \"running\";\n    if ((previousCurrentTime == null) || details.resetCurrentTimeOnResume) {\n      this.startTime =\n          effectivePlaybackRate(details) < 0 ?\n              details.animation.effect.getTiming().duration : 0;\n      details.resetCurrentTimeOnResume = false;\n    } else {\n      // Force recalculation of the start time.\n      this.currentTime = previousCurrentTime;\n    }\n\n    addAnimation(details.timeline, this);\n    if (!details.readyPromise)\n      createReadyPromise(details);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    if (details.playState == \"paused\")\n      return;\n\n    const previousCurrentTime = details.animation.currentTime;\n    if (!previousCurrentTime) {\n      details.startTime =\n          effectivePlaybackRate(details) < 0 ?\n              details.animation.effect.getTiming().duration : 0;\n    } else {\n       details.holdTime = previousCurrentTime;\n    }\n    details.playState = \"paused\";\n    removeAnimation(details.timeline, details.animation);\n    if (!details.readyPromise)\n      createReadyPromise(details);\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.reverse();\n      return;\n    }\n\n    this.updatePlaybackRate(-effectivePlaybackRate(details));\n    this.play();\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    const previousCurrentTime = this.currentTime;\n\n    // We do not update the playback rate of the underlaying animation since\n    // timing of when the playback rate takes effect depends on the play state.\n    switch(details.playState) {\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      case 'finished':\n      case 'running':\n        // pending playback rate is applied when the pending ready promise is\n        // resolved.\n        createReadyPromise(details);\n        updateFinishedState(details);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    details.animation.cancel();\n    if (details.timeline) {\n      details.startTime = null;\n      details.holdTime = null;\n      details.playState = 'idle';\n      removeAnimation(details.timeline, details.animation);\n      if (details.readyPromise) {\n        details.aborted.add(proxy.sequence);\n        details.readyPromise = null;\n      }\n    }\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    proxyAnimations.get(this).animation.finished;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      if (details.readyPromise)\n        return details.readyPromise;\n\n      // TODO: If not waiting on a pending task, we still need to return a ready\n      // promise; however, the promise can be immediately resolved. Cannot use\n      // the underlying animation as it is intentionally locked in a\n      // pause-pending state.\n    }\n\n    return details.animation.ready;\n  }\n\n};\n\nexport function animate(keyframes, options) {\n  let timeline = options.timeline;\n  if (!timeline || !(timeline instanceof ScrollTimeline)) {\n    let animation = nativeElementAnimate.apply(this, [keyframes, options]);\n    // Even through this animation runs as a native animation, we still wrap\n    // it in a proxy animation to allow changing of the animation's timeline.\n    let proxyAnimation = new ProxyAnimation(animation, timeline);\n    return proxyAnimation;\n  }\n  delete options.timeline;\n  let animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  animation.pause();\n  let proxyAnimation = new ProxyAnimation(animation, timeline);\n  proxyAnimation.play();\n  return proxyAnimation;\n};\n\n\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tick","calculateScrollOffset","autoValue","orientation","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","removeAnimation","scrollTimeline","animation","index","indexOf","splice","addAnimation","options","find","push","ScrollTimeline","set","this","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","getComputedStyle","display","overflow","startOffset","endOffset","maxOffset","currentScrollOffset","scrollTop","scrollLeft","phase","Math","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","createReadyPromise","details","sequence","promise","readyPromise","Promise","resolve","reject","requestAnimationFrame","aborted","has","DOMException","pendingPlaybackRate","previousCurrentTime","playbackRate","startTime","timeline","playState","holdTime","getAnimationProperty","name","setAnimationProperty","effectivePlaybackRate","applyPendingPlaybackRate","updateFinishedState","getTiming","duration","isFinished","proxyAnimations","ProxyAnimation","animationTimeline","isScrollAnimation","resetCurrentTimeOnResume","Set","finish","pending","hasActiveTimeline","play","pause","reverse","updatePlaybackRate","rate","persist","cancel","add","proxy","newEffect","newTimeline","oldTimeline","fromScrollTimeline","toScrollTimeline","previousPlayState","id","onfinish","oncancel","onremove","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}