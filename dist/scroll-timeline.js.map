{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/scroll-timeline-css-parser.js","../src/scroll-timeline-css.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%|vw|vh|vmin|vmax)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(source) {\n  if (source === document.scrollingElement) return document;\n  return source;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(source, orientation) {\n  const style = getComputedStyle(source);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = source.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(source.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and source geometry\n * @param source {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(source, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.source).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return source.scrollHeight - source.clientHeight;\n  else if (orientation === \"horizontal\")\n    return source.scrollWidth - source.clientWidth;\n}\n\n/**\n * Calculates the maximum pixel value to use\n * @param cssValue {CSSUnitValue}\n * @param source {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nfunction calculateMaxValue(cssValue, source, orientation) {\n  if (cssValue instanceof CSSUnitValue) {\n    switch (cssValue.unit) {\n      case 'vw':\n        return Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);\n      case 'vh':\n        return Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);\n      case 'vmin':\n        return Math.min(\n          Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),\n          Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0),\n        );\n      case 'vmax':\n        return Math.max(\n          Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),\n          Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0),\n        );\n      default:\n        // NOOP\n    }\n  }\n\n  return orientation === \"vertical\"\n    ? source.scrollHeight - source.clientHeight\n    : source.scrollWidth - source.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (['percent', 'vmin', 'vmax', 'vw', 'vh'].includes(cssValue.unit))\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  source,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      source,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  const maxValue = calculateMaxValue(offset, source, orientation);\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Resolve scroll offsets per\n * https://drafts.csswg.org/scroll-animations-1/#effective-scroll-offsets-algorithm\n * @param source {DOMElement}\n * @param orientation {String}\n * @param scrollOffsets {Array}\n * @param fns {Array}\n * @returns {Array}\n */\nexport function resolveScrollOffsets(\n  source,\n  orientation,\n  scrollOffsets,\n  fns\n) {\n  // 1. Let effective scroll offsets be an empty list of effective scroll\n  // offsets.\n  let effectiveScrollOffsets = [];\n  // 2. Let first offset be true.\n  let firstOffset = true;\n\n  // 3. If scrollOffsets is empty\n  if(scrollOffsets.length == 0) {\n    // 3.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        source,\n        orientation,\n        AUTO\n    ));\n    // 3.2 Set first offset to false.\n    firstOffset = false;\n    // 3.3 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(100, 'percent'),\n        source,\n        orientation,\n        AUTO\n    ));\n  }\n  // 4. If scrollOffsets has exactly one element\n  else if(scrollOffsets.length == 1) {\n    // 4.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        source,\n        orientation,\n        AUTO\n    ));\n    // 4.2 Set first offset to false.\n    firstOffset = false;\n  }\n  // 5. For each scroll offset in the list of scrollOffsets, perform the\n  // following steps:\n  for (let i = 0; i < scrollOffsets.length; i++) {\n    // 5.1 Let effective offset be the result of applying the procedure\n    // to resolve a scroll timeline offset for scroll offset with the is\n    // first flag set to first offset.\n    let effectiveOffset = calculateScrollOffset(\n      firstOffset ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'),\n      source,\n      orientation,\n      scrollOffsets[i],\n      fns[i]);\n    //  5.2 If effective offset is null, the effective scroll offsets is empty and abort the remaining steps.\n    if(effectiveOffset === null)\n      return [];\n    // 5.3 Add effective offset into effective scroll offsets.\n    effectiveScrollOffsets.push(effectiveOffset);\n    // 5.4 Set first offset to false.\n    firstOffset = false;\n  }\n  // 6. Return effective scroll offsets.\n  return effectiveScrollOffsets;\n}\n\n/**\n * Compute scroll timeline progress per\n * https://drafts.csswg.org/scroll-animations-1/#progress-calculation-algorithm\n * @param offset {number}\n * @param scrollOffsets {Array}\n * @returns {number}\n */\nexport function ComputeProgress(\n  offset,\n  scrollOffsets\n) {\n  // 1. Let scroll offsets be the result of applying the procedure to resolve\n  // scroll timeline offsets for scrollOffsets.\n  // 2. Let offset index correspond to the position of the last offset in\n  // scroll offsets whose value is less than or equal to offset and the value\n  // at the following position greater than offset.\n  let offsetIndex;\n  for (offsetIndex = scrollOffsets.length - 2;\n       offsetIndex >= 0 && \n         !(scrollOffsets[offsetIndex] <= offset && offset < scrollOffsets[offsetIndex + 1]);\n       offsetIndex--) {\n  }\n  // 3. Let start offset be the offset value at position offset index in\n  // scroll offsets.\n  let startOffset = scrollOffsets[offsetIndex];\n  // 4. Let end offset be the value of next offset in scroll offsets after\n  // start offset.\n  let endOffset = scrollOffsets[offsetIndex + 1];\n  // 5. Let size be the number of offsets in scroll offsets.\n  let size = scrollOffsets.length;\n  // 6. Let offset weight be the result of evaluating 1 / (size - 1).\n  let offsetWeight = 1 / (size - 1);\n  // 7. Let interval progress be the result of evaluating\n  // (offset - start offset) / (end offset - start offset).\n  let intervalProgress =  (offset - startOffset) / (endOffset - startOffset);\n  // 8. Return the result of evaluating\n  // (offset index + interval progress) × offset weight.\n  return (offsetIndex + intervalProgress) * offsetWeight;\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      source: null,\n      orientation: \"block\",\n      scrollOffsets: [],\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.source =\n      options && options.source !== undefined ? options.source : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n  }\n\n  set source(element) {\n    if (this.source)\n      scrollEventSource(this.source).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).source = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get source() {\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n    updateInternal(this);\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  get duration() {\n    return CSS.percent(100);\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.source) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.source);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.source != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.source,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n\n    //   if source's effective scroll range is null\n    if (effectiveScrollOffsets.length == 0)\n      return \"inactive\";\n\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.source,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.source, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.source) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.source,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.source, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return CSS.percent(0);\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return CSS.percent(100);\n\n    // Step 5\n    let progress = ComputeProgress(\n      currentScrollOffset,\n      effectiveScrollOffsets\n    );\n    return CSS.percent(100 * progress);\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\n// Converts a time from its internal representation to a percent. For a\n// monotonic timeline, time is reported as a double with implicit units of\n// milliseconds. For progress-based animations, times are reported as\n// percentages.\nfunction toCssNumberish(details, value) {\n  if (value === null)\n    return value;\n\n  if (typeof value !== 'number') {\n      throw new DOMException(\n          `Unexpected value: ${value}.  Cannot convert to CssNumberish`,\n          \"InvalidStateError\");\n  }\n\n  const limit = effectEnd(details);\n  const percent = limit ? 100 * value / limit : 0;\n  return CSS.percent(percent);\n}\n\n// Covnerts a time to its internal representation. Progress-based animations\n// use times expressed as percentages. Each progress-based animation is backed\n// by a native animation with a document timeline in the polyfill. Thus, we\n// need to convert the timing from percent to milliseconds with implicit units.\nfunction fromCssNumberish(details, value) {\n  if (!details.timeline) {\n    // Document timeline\n    if (value == null || typeof value === 'number')\n      return value;\n\n    const convertedTime = value.to('ms');\n    if (convertTime)\n      return convertedTime.value;\n\n    throw new DOMException(\n        \"CSSNumericValue must be either a number or a time value for \" +\n        \"time based animations.\",\n        \"InvalidStateError\");\n  } else {\n    // Scroll timeline.\n    if (value === null)\n      return value;\n\n    if (value.unit === 'percent') {\n      const duration = effectEnd(details);\n      return value.value * duration / 100;\n    }\n\n    throw new DOMException(\n        \"CSSNumericValue must be a percentage for progress based animations.\",\n        \"NotSupportedError\");\n  }\n}\n\nfunction normalizedTiming(details) {\n  // Used normalized timing in the case of a progress-based animation or\n  // specified timing with a document timeline.  The normalizedTiming property\n  // is initialized and cached when fetching the timing information.\n  const timing = details.proxy.effect.getTiming();\n  return details.normalizedTiming || timing;\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = fromCssNumberish(details, details.timeline.currentTime);\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n\n  details.animation.pause();\n\n  // Event times are speced as doubles in web-animations-1.\n  // Cannot dispatch a proxy to an event since the proxy is not a fully\n  // transparent replacement. As a workaround, use a custom event and inject\n  // the necessary getters.\n  const finishedEvent =\n    new CustomEvent('finish',\n                    { detail: {\n                      currentTime: details.proxy.currentTime,\n                      timelineTime: details.proxy.timeline.currentTime\n                    }});\n  Object.defineProperty(finishedEvent, 'currentTime', {\n    get: function() { return this.detail.currentTime; }\n  });\n  Object.defineProperty(finishedEvent, 'timelineTime', {\n    get: function() { return this.detail.timelineTime; }\n  });\n\n  requestAnimationFrame(() => {\n    queueMicrotask(() => {\n      details.animation.dispatchEvent(finishedEvent);\n    });\n  });\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  let unconstrainedCurrentTime =\n      didSeek ? fromCssNumberish(details, details.proxy.currentTime)\n              : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = fromCssNumberish(details,\n                                                 details.proxy.currentTime);\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = normalizedTiming(details);\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n\n  return Math.max(0, totalDuration);\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n    details.animation.currentTime =\n        (timelineTime - details.startTime) *\n            details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = fromCssNumberish(details,\n                                             details.proxy.currentTime);\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    details.animation.currentTime =\n        (timelineTimeMs - fromCssNumberish(details, this.startTime)) *\n            this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\nfunction createProxyEffect(details) {\n  const effect = details.animation.effect;\n  const nativeUpdateTiming = effect.updateTiming;\n\n  // Generic pass-through handler for any method or attribute that is not\n  // explicitly overridden.\n  const handler = {\n    get: function(obj, prop) {\n      const result = obj[prop];\n      if (typeof result === 'function')\n        return result.bind(effect);\n      return result;\n    },\n\n    set: function(obj, prop, value) {\n      obj[prop] = value;\n      return true;\n    }\n  };\n  // Override getComputedTiming to convert to percentages when using a\n  // progress-based timeline.\n  const getComputedTimingHandler = {\n    apply: function(target) {\n      // Ensure that the native animation is using normalized values.\n      effect.getTiming();\n\n      const timing = target.apply(effect);\n\n      if (details.timeline) {\n        const preConvertLocalTime = timing.localTime;\n        timing.localTime = toCssNumberish(details, timing.localTime);\n        timing.endTime = toCssNumberish(details, timing.endTime);\n        timing.activeDuration =\n            toCssNumberish(details, timing.activeDuration);\n        const limit = effectEnd(details);\n        const iteration_duration = timing.iterations ?\n            (limit - timing.delay - timing.endDelay) / timing.iterations : 0;\n        timing.duration = limit ?\n            CSS.percent(100 * iteration_duration / limit) :\n            CSS.percent(0);\n\n        // Correct for timeline phase.\n        const phase = details.timeline.phase;\n        const fill = timing.fill;\n\n        if(phase == 'before' && fill != 'backwards' && fill != 'both') {\n          timing.progress = null;\n        }\n        if (phase == 'after' && fill != 'forwards' && fill != 'both') {\n          timing.progress = null;\n        }\n\n        // Correct for inactive timeline.\n        if (details.timeline.currentTime === undefined) {\n          timing.localTime = null;\n        }\n      }\n      return timing;\n    }\n  };\n  // Override getTiming to normalize the timing. EffectEnd for the animation\n  // align with the timeline duration.\n  const getTimingHandler = {\n    apply: function(target, thisArg) {\n      // Arbitrary conversion of 100% to ms.\n      const INTERNAL_DURATION_MS = 100000;\n\n      if (details.specifiedTiming)\n        return details.specifiedTiming;\n\n      details.specifiedTiming = target.apply(effect);\n      let timing = Object.assign({}, details.specifiedTiming);\n\n      let totalDuration;\n\n      // Duration 'auto' case.\n      if (timing.duration === null || timing.duration === 'auto') {\n        if (details.timeline) {\n          // TODO: start and end delay are specced as doubles and currently\n          // ignored for a progress based animation. Support delay and endDelay\n          // once CSSNumberish.\n          timing.delay = 0;\n          timing.endDelay = 0;\n          totalDuration = timing.iterations ? INTERNAL_DURATION_MS : 0;\n          timing.duration =\n              timing.iterations ? totalDuration / timing.iterations : 0;\n          // Set the timing on the native animation to the normalized values\n          // while preserving the specified timing.\n          nativeUpdateTiming.apply(effect, [timing]);\n        }\n      }\n      details.normalizedTiming = timing;\n      return details.specifiedTiming;\n    }\n  };\n  const updateTimingHandler = {\n    apply: function(target, thisArg, argumentsList) {\n      // Additional validation that is specific to scroll timelines.\n      if (details.timeline) {\n        const options = argumentsList[0];\n        const duration = options.duration;\n        if (duration === Infinity) {\n          throw TypeError(\n              \"Effect duration cannot be Infinity when used with Scroll \" +\n              \"Timelines\");\n        }\n        const iterations = options.iterations;\n        if (iterations === Infinity) {\n          throw TypeError(\n            \"Effect iterations cannot be Infinity when used with Scroll \" +\n            \"Timelines\");\n        }\n      }\n\n      // Apply updates on top of the original specified timing.\n      if (details.specifiedTiming) {\n        target.apply(effect, [details.specifiedTiming]);\n      }\n      target.apply(effect, argumentsList);\n      // Force renormalization.\n      details.specifiedTiming = null;\n    }\n  };\n  const proxy = new Proxy(effect, handler);\n  proxy.getComputedTiming = new Proxy(effect.getComputedTiming,\n                                      getComputedTimingHandler);\n  proxy.getTiming = new Proxy(effect.getTiming, getTimingHandler);\n  proxy.updateTiming = new Proxy(effect.updateTiming, updateTimingHandler);\n  return proxy;\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position. These values are represented as floating point\n      // numbers in milliseconds.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      // Record the specified timing since it may be different than the timing\n      // actually used for the animation. When fetching the timing, this value\n      // will be returned, however, the native animation will use normalized\n      // values.\n      specifiedTiming: null,\n      // The normalized timing has the corrected timing with the intrinsic\n      // iteration duration resolved.\n      normalizedTiming: null,\n      // Effect proxy that performs the necessary time conversions when using a\n      // progress-based timelines.\n      effect: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.effect;\n\n    // Proxy the effect to support timing conversions for progress based\n    // animations.\n    if (!details.effect)\n      details.effect = createProxyEffect(details);\n\n    return details.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n    // Reset proxy to force re-initialization the next time it is accessed.\n    details.effect = null;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    const details = proxyAnimations.get(this);\n    const end = effectEnd(details);\n    const progress =\n        end > 0 ? fromCssNumberish(details, previousCurrentTime) / end : 0;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime =\n              fromCssNumberish(details, CSS.percent(100 * progress));\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = progress * effectEnd(details);\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return toCssNumberish(details, details.startTime);\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return toCssNumberish(details, details.holdTime);\n\n    return toCssNumberish(details, calculateCurrentTime(details));\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = fromCssNumberish(details, this.currentTime);\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = toCssNumberish(details, limit);\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ?\n            null : fromCssNumberish(details, this.currentTime);\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = fromCssNumberish(details,\n                                              details.timeline.currentTime);\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(source, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    source == document.scrollingElement\n      ? {\n          left: 0,\n          right: source.clientWidth,\n          top: 0,\n          bottom: source.clientHeight,\n          width: source.clientWidth,\n          height: source.clientHeight,\n        }\n      : source.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      source.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, source.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      source.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, source.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","const VALID_SCROLL_OFFSET_SUFFIXES = [\n  // Relative lengths.\n  'em',\n  'ex',\n  'ch',\n  'rem',\n  'vw',\n  'vh',\n  'vmin',\n  'vmax',\n  // Absolute lengths.\n  'cm',\n  'mm',\n  'q',\n  'in',\n  'pc',\n  'pt',\n  'px',\n  // Percentage.\n  '%',\n];\n\n// This is also used in scroll-timeline-css.js\nexport const RegexMatcher = {\n  IDENTIFIER: /[\\w\\\\\\@_-]+/g,\n  WHITE_SPACE: /\\s*/g,\n  NUMBER: /^[0-9]+/,\n  TIME: /^[0-9]+(s|ms)/,\n  ANIMATION_TIMELINE: /animation-timeline\\s*:([^;}]+)/,\n  ANIMATION_NAME: /animation-name\\s*:([^;}]+)/,\n  ANIMATION: /animation\\s*:([^;}]+)/,\n  OFFSET_WITH_SUFFIX: new RegExp('(^[0-9]+)(' + VALID_SCROLL_OFFSET_SUFFIXES.join('|') + ')'),\n  ELEMENT_OFFSET: /selector\\(#([^)]+)\\)[ ]{0,1}(start|end)*[ ]{0,1}([0-9]+[.]{0,1}[0-9]*)*/,\n  SOURCE_ELEMENT: /selector\\(#([^)]+)\\)/,\n};\n\n// Used for ANIMATION_TIMELINE, ANIMATION_NAME and ANIMATION regex\nconst VALUES_CAPTURE_INDEX = 1;\n\nconst WHOLE_MATCH_INDEX = 0;\n\nconst ANIMATION_KEYWORDS = [\n  'normal', 'reverse', 'alternate', 'alternate-reverse',\n  'none', 'forwards', 'backwards', 'both',\n  'running', 'paused',\n  'ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out'\n];\n\n// 1 - Extracts @scroll-timeline and saves it in scrollTimelineOptions.\n// 2 - If we find any animation-timeline in any of the CSS Rules, \n// we will save objects in a list named cssRulesWithTimelineName\nexport class StyleParser {\n  constructor() {\n    this.cssRulesWithTimelineName = [];\n    this.scrollTimelineOptions = new Map(); // save options by name\n    this.keyframeNames = new Set();\n  }\n\n  // Inspired by\n  // https://drafts.csswg.org/css-syntax/#parser-diagrams\n  // https://github.com/GoogleChromeLabs/container-query-polyfill/blob/main/src/engine.ts\n  // This function is called twice, in the first pass we are interested in saving\n  // @scroll-timeline and @keyframe names, in the second pass\n  // we will parse other rules\n  transpileStyleSheet(sheetSrc, firstPass, srcUrl) {\n    // AdhocParser\n    const p = {\n      sheetSrc: sheetSrc,\n      index: 0,\n      name: srcUrl,\n    };\n\n    while (p.index < p.sheetSrc.length) {\n      this.eatWhitespace(p);\n      if (p.index >= p.sheetSrc.length) break;\n      if (this.lookAhead(\"/*\", p)) {\n        while (this.lookAhead(\"/*\", p)) {\n          this.eatComment(p);\n          this.eatWhitespace(p);\n        }\n        continue;\n      }\n\n      if (this.lookAhead(\"@scroll-timeline\", p)) {\n        const { scrollTimeline, startIndex, endIndex } = this.parseScrollTimeline(p);\n        if (firstPass) this.scrollTimelineOptions.set(scrollTimeline.name, scrollTimeline);\n      } else {\n        const rule = this.parseQualifiedRule(p);\n        if (!rule) continue;\n        if (firstPass) {\n          this.extractAndSaveKeyframeName(rule.selector);\n        } else {\n          this.handleScrollTimelineProps(rule, p);\n        }\n      }\n    }\n\n    // If this sheet has no srcURL (like from a <style> tag), we are done.\n    // TODO: Otherwise, we have to find `url()` functions and resolve\n    // relative and path-absolute URLs to absolute URLs.\n    return p.sheetSrc;\n  }\n\n  getScrollTimelineName(animationName, target) {\n    // Rules are pushed to cssRulesWithTimelineName list in the same order as they appear in style sheet.\n    // We are traversing backwards to take the last sample of a rule in a style sheet.\n    // TODO: Rule specificity should be taken into account, i.e. don't just take the last\n    // rule that matches, instead take the one with the most specifity among those that match\n    for (let i = this.cssRulesWithTimelineName.length - 1; i >= 0; i--) {\n      const current = this.cssRulesWithTimelineName[i];\n      if (target.matches(current.selector)) {\n        if (!current['animation-name'] || current['animation-name'] == animationName) {\n          return current['animation-timeline'];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  parseScrollTimeline(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"@scroll-timeline\");\n    this.eatWhitespace(p);\n    let name = this.parseIdentifier(p);\n    this.eatWhitespace(p);\n    this.assertString(p, \"{\"); // eats {\n    this.eatWhitespace(p);\n\n    let scrollTimeline = {\n      name: name,\n      source: \"auto\",\n      orientation: undefined,\n      'scroll-offsets': undefined\n    };\n\n    while (this.peek(p) !== \"}\") {\n      const property = this.parseIdentifier(p);\n      this.eatWhitespace(p);\n      this.assertString(p, \":\");\n      this.eatWhitespace(p);\n      scrollTimeline[property] = this.removeEnclosingDoubleQuotes(this.eatUntil(\";\", p));\n      this.assertString(p, \";\");\n      this.eatWhitespace(p);\n    }\n\n    this.assertString(p, \"}\");\n    const endIndex = p.index;\n    this.eatWhitespace(p);\n    return {\n      scrollTimeline,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  handleScrollTimelineProps(rule, p) {\n    // The animation-timeline property may not be used in keyframes\n    if (rule.selector.includes(\"@keyframes\")) {\n      return;\n    }\n\n    // TODO is it enough to check with \"includes()\"\n    const hasAnimationName = rule.block.contents.includes(\"animation-name:\");\n    const hasAnimationTimeline = rule.block.contents.includes(\"animation-timeline:\");\n    const hasAnimation = rule.block.contents.includes(\"animation:\");\n\n    let timelineNames = [];\n    let animationNames = [];\n\n    if (hasAnimationTimeline) {\n      timelineNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_TIMELINE);\n    }\n\n    if (hasAnimationName) {\n      animationNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_NAME);\n    }\n\n    if (hasAnimationTimeline && hasAnimationName) {\n      this.saveRelationInList(rule, timelineNames, animationNames);\n      return;\n    }\n\n    if (hasAnimation) {\n      this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION)\n        .forEach(shorthand => {\n          const animationName = this.extractAnimationName(shorthand);\n          const timelineName = this.extractTimelineName(shorthand);\n          if (animationName) animationNames.push(animationName);\n          if (timelineName) {\n            timelineNames.push(timelineName);\n            // Remove timeline name from animation shorthand\n            // so the native implementation works with the rest of the properties\n            // Retain length of original name though, to play nice with multiple\n            // animations that might have been applied\n            rule.block.contents = rule.block.contents.replace(\n              timelineName,\n              \" \".repeat(timelineName.length)\n            );\n            this.replacePart(\n              rule.block.startIndex,\n              rule.block.endIndex,\n              rule.block.contents,\n              p\n            );\n          }\n        });\n    }\n\n    this.saveRelationInList(rule, timelineNames, animationNames);\n  }\n\n  saveRelationInList(rule, timelineNames, animationNames) {\n    if (animationNames.length == 0) {\n      for (let i = 0; i < timelineNames.length; i++) {\n        this.cssRulesWithTimelineName.push({\n          selector: rule.selector,\n          'animation-name': undefined,\n          'animation-timeline': timelineNames[i]\n        });\n      }\n    } else {\n      for (let i = 0; i < Math.max(timelineNames.length, animationNames.length); i++) {\n        this.cssRulesWithTimelineName.push({\n          selector: rule.selector,\n          'animation-name': animationNames[i % animationNames.length],\n          'animation-timeline': timelineNames[i % timelineNames.length]\n        });\n      }\n    }\n\n  }\n\n  extractAnimationName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.keyframeNames);\n  }\n\n  extractTimelineName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.scrollTimelineOptions);\n  }\n\n  findMatchingEntryInContainer(shorthand, container) {\n    const matches = shorthand.split(\" \").filter(part => container.has(part))\n    return matches ? matches[0] : null;\n  }\n\n\n  parseIdentifier(p) {\n    RegexMatcher.IDENTIFIER.lastIndex = p.index;\n    const match = RegexMatcher.IDENTIFIER.exec(p.sheetSrc);\n    if (!match) {\n      throw this.parseError(p, \"Expected an identifier\");\n    }\n    p.index += match[WHOLE_MATCH_INDEX].length;\n    return match[WHOLE_MATCH_INDEX];\n  }\n\n  /**\n   * @param {String} selector contains everything upto '{', eg: \"@keyframes expand\"\n   */\n  extractAndSaveKeyframeName(selector) {\n    if (selector.startsWith(\"@keyframes\")) {\n      selector.split(\" \").forEach((item, index) => {\n        if (index > 0) {\n          this.keyframeNames.add(item);\n        }\n      })\n    }\n  }\n\n  parseQualifiedRule(p) {\n    const startIndex = p.index;\n    const selector = this.parseSelector(p).trim();\n    if (!selector) return;\n    const block = this.eatBlock(p);\n    const endIndex = p.index;\n    return {\n      selector,\n      block,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  removeEnclosingDoubleQuotes(s) {\n    let startIndex = s[0] == '\"' ? 1 : 0;\n    let endIndex = s[s.length - 1] == '\"' ? s.length - 1 : s.length;\n    return s.substring(startIndex, endIndex);\n  }\n\n  assertString(p, s) {\n    if (p.sheetSrc.substr(p.index, s.length) != s) {\n      throw this.parseError(p, `Did not find expected sequence ${s}`);\n    }\n    p.index += s.length;\n  }\n\n  replacePart(start, end, replacement, p) {\n    p.sheetSrc = p.sheetSrc.slice(0, start) + replacement + p.sheetSrc.slice(end);\n    // If we are pointing past the end of the affected section, we need to\n    // recalculate the string pointer. Pointing to something inside the section\n    // that’s being replaced is undefined behavior. Sue me.\n    if (p.index >= end) {\n      const delta = p.index - end;\n      p.index = start + replacement.length + delta;\n    }\n  }\n\n  eatComment(p) {\n    this.assertString(p, \"/*\");\n    this.eatUntil(\"*/\", p);\n    this.assertString(p, \"*/\");\n  }\n\n  eatBlock(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"{\");\n    let level = 1;\n    while (level != 0) {\n      if (p.sheetSrc[p.index] === \"{\") {\n        level++;\n      } else if (p.sheetSrc[p.index] === \"}\") {\n        level--;\n      }\n      this.advance(p);\n    }\n    const endIndex = p.index;\n    const contents = p.sheetSrc.slice(startIndex, endIndex);\n\n    return { startIndex, endIndex, contents };\n  }\n\n  advance(p) {\n    p.index++;\n    if (p.index > p.sheetSrc.length) {\n      throw this.parseError(p, \"Advanced beyond the end\");\n    }\n  }\n\n  eatUntil(s, p) {\n    const startIndex = p.index;\n    while (!this.lookAhead(s, p)) {\n      this.advance(p);\n    }\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  parseSelector(p) {\n    let startIndex = p.index;\n    this.eatUntil(\"{\", p);\n    if (startIndex === p.index) {\n      throw Error(\"Empty selector\");\n    }\n\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  eatWhitespace(p) {\n    // Start matching at the current position in the sheet src\n    RegexMatcher.WHITE_SPACE.lastIndex = p.index;\n    const match = RegexMatcher.WHITE_SPACE.exec(p.sheetSrc);\n    if (match) {\n      p.index += match[WHOLE_MATCH_INDEX].length;\n    }\n  }\n\n  lookAhead(s, p) {\n    return p.sheetSrc.substr(p.index, s.length) == s;\n  }\n\n  peek(p) {\n    return p.sheetSrc[p.index];\n  }\n\n  extractMatches(contents, matcher) {\n    return matcher.exec(contents)[VALUES_CAPTURE_INDEX].trim().split(\",\").map(item => item.trim());\n  }\n}\n\nfunction isTime(s) {\n  return RegexMatcher.TIME.exec(s);\n}\n\nfunction isNumber(s) {\n  return RegexMatcher.NUMBER.exec(s);\n}\n\nexport function removeKeywordsFromAnimationShorthand(anim) {\n  return anim.split(' ').filter(\n    (item, index, array) => index == array.length - 1 || !ANIMATION_KEYWORDS.includes(item))\n    .filter(item => !isTime(item) && !isNumber(item));\n}\n","import { StyleParser, RegexMatcher } from \"./scroll-timeline-css-parser\";\nimport { ProxyAnimation } from \"./proxy-animation\"\n\nconst parser = new StyleParser();\n\nfunction initMutationObserver() {\n  const sheetObserver = new MutationObserver((entries) => {\n    for (const entry of entries) {\n      for (const addedNode of entry.addedNodes) {\n        if (addedNode instanceof HTMLStyleElement) {\n          handleStyleTag(addedNode);\n        }\n        if (addedNode instanceof HTMLLinkElement) {\n          handleLinkedStylesheet(addedNode);\n        }\n      }\n    }\n\n    // TODO: Proxy element.style similar to how we proxy element.animate.\n    // We accomplish this by swapping out Element.prototype.style.\n  });\n\n  sheetObserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n  });\n\n  /**\n   * @param {HtmlStyleElement} el style tag to be parsed\n   */\n  function handleStyleTag(el) {\n    // Don’t touch empty style tags.\n    if (el.innerHTML.trim().length === 0) {\n      return;\n    }\n    // TODO: Do with one pass for better performance\n    let newSrc = parser.transpileStyleSheet(el.innerHTML, true);\n    newSrc = parser.transpileStyleSheet(newSrc, false);\n    el.innerHTML = newSrc;\n  }\n\n  function handleLinkedStylesheet(el) {\n    // TODO\n  }\n\n  document.querySelectorAll(\"style\").forEach((tag) => handleStyleTag(tag));\n  document\n    .querySelectorAll(\"link\")\n    .forEach((tag) => handleLinkedStylesheet(tag));\n}\n\n// This implementation is based on https://drafts.csswg.org/scroll-animations-1/\n// TODO: Should update accordingly when new spec lands.\nfunction getSourceElement(source) {\n  const matches = RegexMatcher.SOURCE_ELEMENT.exec(source);\n  const SOURCE_CAPTURE_INDEX = 1;\n  if (matches) {\n    return document.getElementById(matches[SOURCE_CAPTURE_INDEX]);\n  } else if (source === \"auto\") {\n    return document.scrollingElement;\n  } else {\n    return null;\n  }\n}\n\n// This implementation is based on https://drafts.csswg.org/scroll-animations-1/\n// 'scroll-offsets' are likely to be deprecated,\n// TODO: Should update accordingly when new spec lands.\nfunction convertOneScrollOffset(part) {\n  if (part == 'auto') return new CSSKeywordValue('auto');\n\n  const matchesOffsetWithSuffix = RegexMatcher.OFFSET_WITH_SUFFIX.exec(part);\n  const VALUE_CAPTURE_INDEX = 1;\n  const UNIT_CAPTURE_INDEX = 2;\n  if (matchesOffsetWithSuffix) {\n    return new CSSUnitValue(parseInt(matchesOffsetWithSuffix[VALUE_CAPTURE_INDEX]), matchesOffsetWithSuffix[UNIT_CAPTURE_INDEX]);\n  }\n\n  const matchesElementOffset = RegexMatcher.ELEMENT_OFFSET.exec(part);\n  const SOURCE_CAPTURE_INDEX = 1;\n  const EDGE_CAPTURE_INDEX = 2;\n  const THRESHOLD_CAPTURE_INDEX = 3;\n  if (matchesElementOffset) {\n    if (document.getElementById(matchesElementOffset[SOURCE_CAPTURE_INDEX])) {\n      return {\n        target: document.getElementById(matchesElementOffset[SOURCE_CAPTURE_INDEX]),\n        ...(matchesElementOffset.length >= 3 ? { edge: matchesElementOffset[EDGE_CAPTURE_INDEX] } : {}),\n        ...(matchesElementOffset.length >= 4 ? { threshold: parseFloat(matchesElementOffset[THRESHOLD_CAPTURE_INDEX]) } : {})\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction isDescendant(child, parent) {\n  while (child) {\n    if (child == parent) return true;\n    child = child.parentNode;\n  }\n  return false;\n}\n\n// This implementation is based on https://drafts.csswg.org/scroll-animations-1/\n// 'scroll-offsets' are likely to be deprecated,\n// TODO: Should update accordingly when new spec lands.\nfunction getScrollOffsets(source, offsets) {\n  let scrollOffsets = undefined;\n\n  if (offsets) {\n    if (offsets == \"none\") {\n      // do nothing\n    } else {\n      scrollOffsets = offsets.split(\",\")\n        .map(part => part.trim())\n        .filter(part => part != '')\n        .map(part => convertOneScrollOffset(part))\n        .filter(offset => offset);\n\n      // If the available scroll-offsets are not valid,\n      // so we won't create the scrollTimeline,\n      for (let off of scrollOffsets) {\n        if (off.target && off.target instanceof Element &&\n          (window.getComputedStyle(off.target, null).display == \"none\" || !isDescendant(off.target, source))) {\n          return null;\n        }\n      }\n      if (scrollOffsets.length == 0) {\n        return null;\n      }\n    }\n  }\n\n  return scrollOffsets;\n}\n\nfunction createScrollTimeline(name) {\n  const options = parser.scrollTimelineOptions.get(name);\n  if (!options) return null;\n\n  const sourceElement = getSourceElement(options.source);\n  const scrollOffsets = getScrollOffsets(sourceElement, options['scroll-offsets']);\n\n  // TODO: Handle invalid scrollOffsets differently, don't return null for scrollTimeline, should check native implementation\n  if (scrollOffsets !== null) {\n    const scrollTimeline = new ScrollTimeline({\n      ...(sourceElement ? { source: getSourceElement(options.source) } : {}),\n      ...(scrollOffsets ? { scrollOffsets: scrollOffsets } : {}),\n      ...(options.orientation != \"auto\" ? { orientation: options.orientation } : {}),\n    });\n    return scrollTimeline;\n  } else {\n    return null;\n  }\n}\n\nexport function initCSSPolyfill() {\n  // Don't load if browser claims support\n  if (CSS.supports(\"animation-timeline: works\")) {\n    return;\n  }\n\n  initMutationObserver();\n\n  // We are not wrapping capturing 'animationstart' by a 'load' event,\n  // because we may lose some of the 'animationstart' events by the time 'load' is completed.\n  window.addEventListener('animationstart', (evt) => {\n    evt.target.getAnimations().filter(anim => anim.animationName === evt.animationName).forEach(anim => {\n      const timelineName = parser.getScrollTimelineName(anim.animationName, evt.target);\n      if (timelineName) {\n        const scrollTimeline = createScrollTimeline(timelineName);\n        if (anim.timeline != scrollTimeline) {\n          const proxyAnimation = new ProxyAnimation(anim, scrollTimeline);\n          anim.pause();\n          proxyAnimation.play();\n        }\n      }\n    });\n  });\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\n\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\nimport { initCSSPolyfill } from \"./scroll-timeline-css\"\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\ninitCSSPolyfill();\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","MathOperation","operator","opt_name","opt_delimiter","set","this","name","delimiter","toString","details","get","join","cssOMTypes","value","unit","toLowerCase","displayUnit","CSSKeywordValue","arguments","CSSMathProduct","CSSMathNegate","window","CSS","Reflect","defineProperty","Error","type","forEach","installCSSOM","AUTO","scrollTimelineOptions","extensionScrollOffsetFunctions","scrollEventSource","source","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","includes","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","max","documentElement","clientWidth","innerWidth","clientHeight","innerHeight","min","scrollHeight","scrollWidth","calculateMaxValue","resolveScrollOffsets","scrollOffsets","fns","effectiveScrollOffsets","firstOffset","push","effectiveOffset","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","input","parse","evaluate","parsed","data","percent","scrollerStyle","display","overflow","maxOffset","startOffset","endOffset","phase","progress","offsetIndex","ComputeProgress","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","toCssNumberish","limit","effectEnd","fromCssNumberish","duration","convertedTime","to","convertTime","commitFinishedNotification","finishedPromise","proxy","playState","pause","finishedEvent","CustomEvent","detail","Object","queueMicrotask","dispatchEvent","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","effect","getTiming","normalizedTiming","delay","endDelay","iterations","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","Infinity","play","bind","pendingTask","proxyAnimations","timelineTimeMs","cancel","readyTime","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","specifiedTiming","finish","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","event","nativeUpdateTiming","updateTiming","getComputedTimingHandler","apply","target","localTime","endTime","activeDuration","fill","getTimingHandler","thisArg","assign","updateTimingHandler","argumentsList","Proxy","prop","getComputedTiming","createProxyEffect","newEffect","newTimeline","oldTimeline","previousPlayState","end","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","edge","threshold","rootMargin","clamp","parseFloat","map","margin","margins","split","parsedMargins","parsedValue","positions","j","RegexMatcher","IDENTIFIER","WHITE_SPACE","NUMBER","TIME","ANIMATION_TIMELINE","ANIMATION_NAME","ANIMATION","OFFSET_WITH_SUFFIX","RegExp","ELEMENT_OFFSET","SOURCE_ELEMENT","parser","cssRulesWithTimelineName","Map","keyframeNames","Set","transpileStyleSheet","sheetSrc","firstPass","srcUrl","p","index","eatWhitespace","lookAhead","eatComment","parseScrollTimeline","rule","parseQualifiedRule","extractAndSaveKeyframeName","selector","handleScrollTimelineProps","getScrollTimelineName","animationName","current","startIndex","assertString","parseIdentifier","scroll-offsets","peek","property","removeEnclosingDoubleQuotes","eatUntil","endIndex","hasAnimationName","block","contents","hasAnimationTimeline","hasAnimation","timelineNames","animationNames","extractMatches","shorthand","extractAnimationName","timelineName","extractTimelineName","replace","repeat","replacePart","saveRelationInList","animation-name","animation-timeline","findMatchingEntryInContainer","container","filter","part","has","lastIndex","exec","parseError","startsWith","item","_this2","add","parseSelector","eatBlock","s","substring","substr","start","replacement","slice","level","advance","matcher","getSourceElement","getElementById","isDescendant","child","parent","parentNode","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","supports","handleStyleTag","el","innerHTML","newSrc","MutationObserver","entries","addedNodes","addedNode","HTMLStyleElement","observe","childList","subtree","querySelectorAll","tag","initMutationObserver","evt","getAnimations","anim","sourceElement","matchesOffsetWithSuffix","parseInt","matchesElementOffset","convertOneScrollOffset","off","getScrollOffsets","createScrollTimeline","proxyAnimation","keyframes"],"mappings":"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"}