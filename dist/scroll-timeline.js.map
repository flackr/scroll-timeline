{"version":3,"file":"scroll-timeline.js","sources":["../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/scroll-timeline-css-parser.js","../src/scroll-timeline-css.js","../src/index.js"],"sourcesContent":["// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(source) {\n  if (source === document.scrollingElement) return document;\n  return source;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  validateSource(scrollTimelineInstance);\n  const details = scrollTimelineOptions.get(scrollTimelineInstance);\n  let animations = details.animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(source, orientation) {\n  if (!source)\n    return null;\n\n  const style = getComputedStyle(source);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = source.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(source.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Calculates scroll offset based on orientation and source geometry\n * @param source {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(source, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(source).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return source.scrollHeight - source.clientHeight;\n  else if (orientation === \"horizontal\")\n    return source.scrollWidth - source.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\n// Detects if the cached source is obsolete, and updates if required\n// to ensure the new source has a scroll listener.\nfunction validateSource(timeline) {\n  if (!(timeline instanceof ViewTimeline))\n    return;\n\n  const node = timeline.subject;\n  if (!node) {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const display  = getComputedStyle(node).display;\n  if (display == 'none') {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const source = getScrollParent(node);\n  updateSource(timeline, source);\n}\n\nfunction updateSource(timeline, source) {\n  const details = scrollTimelineOptions.get(timeline);\n  const oldSource = details.source;\n  const oldScrollListener = details.scrollListener;\n  if (oldSource == source)\n    return;\n\n  if (oldSource && oldScrollListener) {\n    scrollEventSource(oldSource).removeEventListener(\"scroll\",\n                                                     oldScrollListener);\n  }\n  scrollTimelineOptions.get(timeline).source = source;\n  if (source) {\n    const listener = () => {\n      updateInternal(timeline);\n    };\n    scrollEventSource(source).addEventListener(\"scroll\", listener);\n    details.scrollListener = listener;\n  }\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      source: null,\n      orientation: \"block\",\n\n      // View timeline\n      subject: null,\n      inset: options.inset,\n\n      // Internal members\n      animations: [],\n      scrollListener: null\n    });\n    const source =\n      options && options.source !== undefined ? options.source\n                                              : document.scrollingElement;\n    updateSource(this, source);\n    this.orientation = (options && options.orientation) || \"block\";\n    updateInternal(this);\n  }\n\n  set source(element) {\n    updateSource(this, element);\n    updateInternal(this);\n  }\n\n  get source() {\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  get duration() {\n    return CSS.percent(100);\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    const unresolved = null;\n    //   if source is null\n    const container = this.source;\n    if (!container) return \"inactive\";\n    let scrollerStyle = getComputedStyle(container);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (container != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    return \"active\"\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const container = this.source;\n    if (!container) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    const orientation = this.orientation;\n    const scrollPos = directionAwareScrollOffset(container, orientation);\n    const maxScrollPos = calculateMaxScrollOffset(container, orientation);\n\n    return maxScrollPos > 0 ? CSS.percent(100 * scrollPos / maxScrollPos)\n                            : CSS.percent(100);\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n\n// Methods for calculation of the containing block.\n// See https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block.\n\nfunction findClosestAncestor(element, matcher) {\n  let candidate = element.parentElement;\n  while(candidate != null) {\n    if (matcher(candidate))\n      return candidate;\n    candidate = candidate.parentElement;\n  }\n}\n\nfunction isBlockContainer(element) {\n  const style = getComputedStyle(element);\n  switch (style.display) {\n    case 'block':\n    case 'inline-block':\n    case 'list-item':\n    case 'table':\n    case 'table-caption':\n    case 'flow-root':\n    case 'flex':\n    case 'grid':\n      return true;\n  }\n\n  return false;\n}\n\nfunction isFixedElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.transform != 'none' || style.perspective != 'none')\n    return true;\n\n  if (style.willChange == 'transform' || style.willChange == 'perspective')\n    return true;\n\n  if (style.filter != 'none' || style.willChange == 'filter')\n    return true;\n\n  if (style.backdropFilter != 'none')\n    return true;\n\n  return false;\n}\n\nfunction isAbsoluteElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.position != 'static')\n    return true;\n\n  return isFixedElementContainer(element);\n}\n\nfunction getContainingBlock(element) {\n  switch (getComputedStyle(element).position) {\n    case 'static':\n    case 'relative':\n    case 'sticky':\n      return findClosestAncestor(element, isBlockContainer);\n\n    case 'absolute':\n      return findClosestAncestor(element, isAbsoluteElementContainer);\n\n    case 'fixed':\n      return findClosestAncestor(element, isFixedElementContainer);\n  }\n}\n\nfunction getScrollParent(node) {\n  if (!node)\n    return undefined;\n\n  while (node = getContainingBlock(node)) {\n    const style = getComputedStyle(node);\n    switch(style['overflow-x']) {\n      case 'auto':\n      case 'scroll':\n      case 'hidden':\n        // https://drafts.csswg.org/css-overflow-3/#overflow-propagation\n        // The UA must apply the overflow from the root element to the viewport;\n        // however, if the overflow is visible in both axis, then the overflow\n        // of the first visible child body is applied instead.\n        if (node == document.body &&\n            getComputedStyle(document.scrollingElement).overflow == \"visible\")\n          return  document.scrollingElement;\n\n        return node;\n    }\n  }\n  return document.scrollingElement;\n}\n\n// ---- View timelines -----\n\n// Computes the scroll offsets corresponding to the [0, 100]% range for a\n// specific phase on a view timeline.\n// TODO: Track changes to determine when associated animations require their\n// timing to be renormalized.\nfunction range(timeline, phase) {\n  const details = scrollTimelineOptions.get(timeline);\n\n  const unresolved = null;\n  if (timeline.phase === 'inactive')\n    return unresolved;\n\n  if (!(timeline instanceof ViewTimeline))\n    return unresolved;\n\n  // Compute the offset of the top-left corner of subject relative to\n  // top-left corner of the container.\n  const container = timeline.source;\n  const target = timeline.subject;\n\n  let top = 0;\n  let left = 0;\n  let node = target;\n  const ancestor = container.offsetParent;\n  while (node && node != ancestor) {\n    left += node.offsetLeft;\n    top += node.offsetTop;\n    node = node.offsetParent;\n  }\n  left -= container.offsetLeft + container.clientLeft;\n  top -= container.offsetTop + container.clientTop;\n\n  // Determine the view and container size based on the scroll direction.\n  // The view position is the scroll position of the logical starting edge\n  // of the view.\n  const style = getComputedStyle(container);\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  const rtl = style.direction == 'rtl' || style.writingMode == 'vertical-rl';\n  let viewSize = undefined;\n  let viewPos = undefined;\n  let containerSize = undefined;\n  const orientation = details.orientation;\n  if (orientation == 'horizontal' ||\n      (orientation == 'inline' && horizontalWritingMode) ||\n      (orientation == 'block' && !horizontalWritingMode)) {\n    viewSize = target.clientWidth;\n    viewPos = left;\n    if (rtl)\n      viewPos += container.scrollWidth - container.clientWidth;\n    containerSize = container.clientWidth;\n  } else {\n    // TODO: support sideways-lr\n    viewSize = target.clientHeight;\n    viewPos = top;\n    containerSize = container.clientHeight;\n  }\n\n  const inset = parseInset(details.inset, containerSize);\n\n\n  // Cover:\n  // 0% progress represents the position at which the start border edge of the\n  // element’s principal box coincides with the end edge of its view progress\n  // visibility range.\n  // 100% progress represents the position at which the end border edge of the\n  // element’s principal box coincides with the start edge of its view progress\n  // visibility range.\n  const coverStartOffset = viewPos - containerSize + inset.end;\n  const coverEndOffset = viewPos + viewSize - inset.start;\n\n  // Contain:\n  // The 0% progress represents the earlier of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //    the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  // The 100% progress represents the greater of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //  the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  const alignStartOffset = coverStartOffset + viewSize;\n  const alignEndOffset = coverEndOffset - viewSize;\n  const containStartOffset = Math.min(alignStartOffset, alignEndOffset);\n  const containEndOffset = Math.max(alignStartOffset, alignEndOffset);\n\n  // Enter and Exit bounds align with cover and contains bounds.\n\n  let startOffset = undefined;\n  let endOffset = undefined;\n\n  switch(phase) {\n    case 'cover':\n      startOffset = coverStartOffset;\n      endOffset = coverEndOffset;\n      break;\n\n    case 'contain':\n      startOffset = containStartOffset;\n      endOffset = containEndOffset;\n      break;\n\n    case 'enter':\n      startOffset = coverStartOffset;\n      endOffset = containStartOffset;\n      break;\n\n    case 'exit':\n      startOffset = containEndOffset;\n      endOffset = coverEndOffset;\n      break;\n  }\n\n  return { start: startOffset, end: endOffset };\n}\n\nfunction parseInset(value, containerSize) {\n  const inset = { start: 0, end: 0 };\n\n  if(!value)\n    return inset;\n\n  const parts = value.split(' ');\n  const insetParts = [];\n  parts.forEach(part => {\n    // TODO: Add support for relative lengths (e.g. em)\n    if(part.endsWith(\"%\"))\n      insetParts.push(containerSize / 100 * parseFloat(part));\n    else if(part.endsWith(\"px\"))\n      insetParts.push(parseFloat(part));\n    else if(part === \"auto\")\n      insetParts.push(0);\n  });\n\n  if (insetParts.length > 2) {\n    throw TypeError(\"Invalid inset\");\n  }\n\n  if(insetParts.length == 1) {\n    inset.start = insetParts[0];\n    inset.end = insetParts[0];\n  } else if(insetParts.length == 2) {\n    inset.start = insetParts[0];\n    inset.end = insetParts[1];\n  }\n\n  return inset;\n}\n\n// Calculate the fractional offset of a (phase, percent) pair relative to the\n// full cover range.\nexport function relativePosition(timeline, phase, percent) {\n  const phaseRange = range(timeline, phase);\n  const coverRange = range(timeline, 'cover');\n  if (!phaseRange || !coverRange)\n    return 0;\n\n  const fraction = percent.value / 100;\n  const offset =\n      (phaseRange.end - phaseRange.start) * fraction + phaseRange.start;\n  return (offset - coverRange.start) / (coverRange.end - coverRange.start);\n}\n\n// https://drafts.csswg.org/scroll-animations-1/rewrite#view-progress-timelines\nexport class ViewTimeline extends ScrollTimeline {\n  // As specced, ViewTimeline has a subject and a source, but\n  // ViewTimelineOptions only has source. Furthermore, there is a strict\n  // relationship between subject and source (source is nearest scrollable\n  // ancestor of subject).\n\n  // Proceeding under the assumption that subject will be added to\n  // ViewTimelineOptions. Inferring the source from the subject if not\n  // explicitly set.\n  constructor(options) {\n    if (options.axis) {\n      // Orientation called axis for a view timeline. Internally we can still\n      // call this orientation, since the internal naming is not exposed.\n      options.orientation = options.axis;\n    }\n    super(options);\n    const details = scrollTimelineOptions.get(this);\n    details.subject = options && options.subject ? options.subject : undefined;\n    // TODO: Handle insets.\n\n    validateSource(this);\n    updateInternal(this);\n  }\n\n  get source() {\n    validateSource(this);\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set source(source) {\n    throw new Error(\"Cannot set the source of a view timeline\");\n  }\n\n  get subject() {\n    return scrollTimelineOptions.get(this).subject;\n  }\n\n  // The orientation is called \"axis\" for a view timeline.\n  // Internally we still call it orientation.\n  get axis() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const scrollPos = directionAwareScrollOffset(this.source, this.orientation);\n    if (scrollPos == unresolved)\n      return unresolved;\n\n    const offsets = range(this, 'cover');\n    if (!offsets)\n      return unresolved;\n    const progress =\n        (scrollPos - offsets.start) / (offsets.end - offsets.start);\n\n    return CSS.percent(100 * progress);\n  }\n\n}\n","import {\n  ScrollTimeline,\n  addAnimation,\n  removeAnimation,\n  relativePosition\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nconst ANIMATION_DELAY_NAMES = ['enter', 'exit', 'cover', 'contain'];\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\n// Converts a time from its internal representation to a percent. For a\n// monotonic timeline, time is reported as a double with implicit units of\n// milliseconds. For progress-based animations, times are reported as\n// percentages.\nfunction toCssNumberish(details, value) {\n  if (value === null)\n    return value;\n\n  if (typeof value !== 'number') {\n      throw new DOMException(\n          `Unexpected value: ${value}.  Cannot convert to CssNumberish`,\n          \"InvalidStateError\");\n  }\n\n  const limit = effectEnd(details);\n  const percent = limit ? 100 * value / limit : 0;\n  return CSS.percent(percent);\n}\n\n// Covnerts a time to its internal representation. Progress-based animations\n// use times expressed as percentages. Each progress-based animation is backed\n// by a native animation with a document timeline in the polyfill. Thus, we\n// need to convert the timing from percent to milliseconds with implicit units.\nfunction fromCssNumberish(details, value) {\n  if (!details.timeline) {\n    // Document timeline\n    if (value == null || typeof value === 'number')\n      return value;\n\n    const convertedTime = value.to('ms');\n    if (convertTime)\n      return convertedTime.value;\n\n    throw new DOMException(\n        \"CSSNumericValue must be either a number or a time value for \" +\n        \"time based animations.\",\n        \"InvalidStateError\");\n  } else {\n    // Scroll timeline.\n    if (value === null)\n      return value;\n\n    if (value.unit === 'percent') {\n      const duration = effectEnd(details);\n      return value.value * duration / 100;\n    }\n\n    throw new DOMException(\n        \"CSSNumericValue must be a percentage for progress based animations.\",\n        \"NotSupportedError\");\n  }\n}\n\nfunction normalizedTiming(details) {\n  // Used normalized timing in the case of a progress-based animation or\n  // specified timing with a document timeline.  The normalizedTiming property\n  // is initialized and cached when fetching the timing information.\n  const timing = details.proxy.effect.getTiming();\n  return details.normalizedTiming || timing;\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = fromCssNumberish(details, details.timeline.currentTime);\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n\n  details.animation.pause();\n\n  // Event times are speced as doubles in web-animations-1.\n  // Cannot dispatch a proxy to an event since the proxy is not a fully\n  // transparent replacement. As a workaround, use a custom event and inject\n  // the necessary getters.\n  const finishedEvent =\n    new CustomEvent('finish',\n                    { detail: {\n                      currentTime: details.proxy.currentTime,\n                      timelineTime: details.proxy.timeline.currentTime\n                    }});\n  Object.defineProperty(finishedEvent, 'currentTime', {\n    get: function() { return this.detail.currentTime; }\n  });\n  Object.defineProperty(finishedEvent, 'timelineTime', {\n    get: function() { return this.detail.timelineTime; }\n  });\n\n  requestAnimationFrame(() => {\n    queueMicrotask(() => {\n      details.animation.dispatchEvent(finishedEvent);\n    });\n  });\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  let unconstrainedCurrentTime =\n      didSeek ? fromCssNumberish(details, details.proxy.currentTime)\n              : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = fromCssNumberish(details,\n                                                 details.proxy.currentTime);\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = normalizedTiming(details);\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n\n  return Math.max(0, totalDuration);\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime == null)\n      return;\n\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(details,\n                         (timelineTimeMs - details.startTime) *\n                             details.animation.playbackRate);\n  } else if (details.holdTime !== null) {\n    setNativeCurrentTime(details, details.holdTime);\n  }\n}\n\n// Sets the time of the underlying animation, nudging the time slightly if at\n// a scroll-timeline boundary to remain in the active phase.\nfunction setNativeCurrentTime(details, time) {\n  const timeline = details.timeline;\n  const playbackRate = details.animation.playbackRate;\n  const atScrollTimelineBoundary =\n      timeline.currentTime &&\n      timeline.currentTime.value == (playbackRate < 0 ? 0 : 100);\n  const delta =\n      atScrollTimelineBoundary ? (playbackRate < 0 ? 0.001 : -0.001) : 0;\n\n  details.animation.currentTime = time + delta;\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = fromCssNumberish(details,\n                                             details.proxy.currentTime);\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(\n        details,\n        (timelineTimeMs - fromCssNumberish(details, this.startTime)) *\n            this.playbackRate);\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\nfunction createProxyEffect(details) {\n  const effect = details.animation.effect;\n  const nativeUpdateTiming = effect.updateTiming;\n\n  // Generic pass-through handler for any method or attribute that is not\n  // explicitly overridden.\n  const handler = {\n    get: function(obj, prop) {\n      const result = obj[prop];\n      if (typeof result === 'function')\n        return result.bind(effect);\n      return result;\n    },\n\n    set: function(obj, prop, value) {\n      obj[prop] = value;\n      return true;\n    }\n  };\n  // Override getComputedTiming to convert to percentages when using a\n  // progress-based timeline.\n  const getComputedTimingHandler = {\n    apply: function(target) {\n      // Ensure that the native animation is using normalized values.\n      effect.getTiming();\n\n      const timing = target.apply(effect);\n\n      if (details.timeline) {\n        const preConvertLocalTime = timing.localTime;\n        timing.localTime = toCssNumberish(details, timing.localTime);\n        timing.endTime = toCssNumberish(details, timing.endTime);\n        timing.activeDuration =\n            toCssNumberish(details, timing.activeDuration);\n        const limit = effectEnd(details);\n        const iteration_duration = timing.iterations ?\n            (limit - timing.delay - timing.endDelay) / timing.iterations : 0;\n        timing.duration = limit ?\n            CSS.percent(100 * iteration_duration / limit) :\n            CSS.percent(0);\n\n        // Correct for inactive timeline.\n        if (details.timeline.currentTime === undefined) {\n          timing.localTime = null;\n        }\n      }\n      return timing;\n    }\n  };\n  // Override getTiming to normalize the timing. EffectEnd for the animation\n  // align with the timeline duration.\n  const getTimingHandler = {\n    apply: function(target, thisArg) {\n      // Arbitrary conversion of 100% to ms.\n      const INTERNAL_DURATION_MS = 100000;\n\n      if (details.specifiedTiming)\n        return details.specifiedTiming;\n\n      details.specifiedTiming = target.apply(effect);\n      let timing = Object.assign({}, details.specifiedTiming);\n\n      const timeline = details.timeline;\n      let computedDelays = false;\n      let startDelay;\n      let endDelay;\n      if (timeline instanceof ViewTimeline) {\n        // Compute start and end delay to align with start and end times.\n        // If times not specified use cover 0% to cover 100%.\n        startDelay = fractionalStartDelay(details);\n        endDelay = fractionalEndDelay(details);\n        computedDelays = true;\n      }\n\n      let totalDuration;\n\n      // Duration 'auto' case.\n      if (timing.duration === null || timing.duration === 'auto' ||\n          computedDelays) {\n        if (details.timeline) {\n          if (computedDelays) {\n            timing.delay = startDelay * INTERNAL_DURATION_MS;\n            timing.endDelay = endDelay * INTERNAL_DURATION_MS;\n          } else {\n            // TODO: start and end delay are specced as doubles and currently\n            // ignored for a progress based animation. Support delay and endDelay\n            // once CSSNumberish.\n            timing.delay = 0;\n            timing.endDelay = 0;\n          }\n          totalDuration = timing.iterations ? INTERNAL_DURATION_MS : 0;\n          timing.duration = timing.iterations\n             ? (totalDuration - timing.delay - timing.endDelay) /\n                 timing.iterations\n             : 0;\n          // Set the timing on the native animation to the normalized values\n          // while preserving the specified timing.\n          nativeUpdateTiming.apply(effect, [timing]);\n        }\n      }\n      details.normalizedTiming = timing;\n      return details.specifiedTiming;\n    }\n  };\n  const updateTimingHandler = {\n    apply: function(target, thisArg, argumentsList) {\n      // Additional validation that is specific to scroll timelines.\n      if (details.timeline) {\n        const options = argumentsList[0];\n        const duration = options.duration;\n        if (duration === Infinity) {\n          throw TypeError(\n              \"Effect duration cannot be Infinity when used with Scroll \" +\n              \"Timelines\");\n        }\n        const iterations = options.iterations;\n        if (iterations === Infinity) {\n          throw TypeError(\n            \"Effect iterations cannot be Infinity when used with Scroll \" +\n            \"Timelines\");\n        }\n      }\n\n      // Apply updates on top of the original specified timing.\n      if (details.specifiedTiming) {\n        target.apply(effect, [details.specifiedTiming]);\n      }\n      target.apply(effect, argumentsList);\n      // Force renormalization.\n      details.specifiedTiming = null;\n    }\n  };\n  const proxy = new Proxy(effect, handler);\n  proxy.getComputedTiming = new Proxy(effect.getComputedTiming,\n                                      getComputedTimingHandler);\n  proxy.getTiming = new Proxy(effect.getTiming, getTimingHandler);\n  proxy.updateTiming = new Proxy(effect.updateTiming, updateTimingHandler);\n  return proxy;\n}\n\n// Computes the start delay as a fraction of the active cover range.\nfunction fractionalStartDelay(details) {\n  if (!(details.timeline instanceof ViewTimeline))\n    return 0;\n\n  const startTime = details.timeRange.start;\n  return relativePosition(details.timeline, startTime.name, startTime.offset);\n}\n\n// Computes the ends delay as a fraction of the active cover range.\nfunction fractionalEndDelay(details) {\n  if (!(details.timeline instanceof ViewTimeline))\n    return 0;\n\n  const endTime = details.timeRange.end;\n  return 1 - relativePosition(details.timeline, endTime.name, endTime.offset);\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline, animOptions={}) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position. These values are represented as floating point\n      // numbers in milliseconds.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      // Record the specified timing since it may be different than the timing\n      // actually used for the animation. When fetching the timing, this value\n      // will be returned, however, the native animation will use normalized\n      // values.\n      specifiedTiming: null,\n      // The normalized timing has the corrected timing with the intrinsic\n      // iteration duration resolved.\n      normalizedTiming: null,\n      // Effect proxy that performs the necessary time conversions when using a\n      // progress-based timelines.\n      effect: null,\n      // Range when using a view-timeline. The default range is cover 0% to\n      // 100%.\n      timeRange: timeline instanceof ViewTimeline ? parseAnimationDelays(animOptions) : null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.effect;\n\n    // Proxy the effect to support timing conversions for progress based\n    // animations.\n    if (!details.effect)\n      details.effect = createProxyEffect(details);\n\n    return details.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n    // Reset proxy to force re-initialization the next time it is accessed.\n    details.effect = null;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    const details = proxyAnimations.get(this);\n    const end = effectEnd(details);\n    const progress =\n        end > 0 ? fromCssNumberish(details, previousCurrentTime) / end : 0;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime =\n              fromCssNumberish(details, CSS.percent(100 * progress));\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = progress * effectEnd(details);\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return toCssNumberish(details, details.startTime);\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return toCssNumberish(details, details.holdTime);\n\n    return toCssNumberish(details, calculateCurrentTime(details));\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = fromCssNumberish(details, this.currentTime);\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = toCssNumberish(details, limit);\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ?\n            null : fromCssNumberish(details, this.currentTime);\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = fromCssNumberish(details,\n                                              details.timeline.currentTime);\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\n// animation-delay or animation-end-delay should be in the form of a name and an optional percentage\nfunction parseOneAnimationDelay(delay, defaultOffset) {\n  if(!delay) return null;\n\n  const parts = delay.split(' ');\n\n  if(!ANIMATION_DELAY_NAMES.includes(parts[0]) ||\n    (parts.length == 2 && !parts[1].endsWith('%')))\n    throw TypeError(\"Invalid animation delay\");\n\n  let offset = defaultOffset;\n  if(parts.length == 2) {\n    const percentage = parseFloat(parts[1]);\n    if(Number.isNaN(percentage))\n      throw TypeError(`\\\"${parts[1]}\\\" is not a valid percentage for animation delay`);\n\n    offset = CSS.percent(percentage);\n  }\n\n  return { name: parts[0], offset: offset };\n}\n\nfunction defaultAnimationDelay() { return { name: 'cover', offset: CSS.percent(0) }; }\n\nfunction defaultAnimationEndDelay() { return { name: 'cover', offset: CSS.percent(100) }; }\n\nfunction parseAnimationDelays(animOptions) {\n  const timeRange = parseTimeRange(animOptions['animation-time-range']);\n\n  if(animOptions['animation-delay'])\n    timeRange.start = parseOneAnimationDelay(animOptions['animation-delay'], defaultAnimationDelay().offset);\n\n  if(animOptions['animation-end-delay'])\n    timeRange.end = parseOneAnimationDelay(animOptions['animation-end-delay'], defaultAnimationEndDelay().offset);\n\n  return timeRange;\n}\n\nfunction parseTimeRange(value) {\n  const timeRange = {\n    start: defaultAnimationDelay(),\n    end: defaultAnimationEndDelay()\n  };\n\n  if (!value)\n    return timeRange;\n\n  // Format:\n  // <start-name> <start-offset> <end-name> <end-offset>\n  // <name> --> <name> 0% <name> 100%\n  // <name> <start-offset> <end-offset> --> <name> <start-offset>\n  //                                        <name> <end-offset>\n  // <start-offset> <end-offset> --> cover <start-offset> cover <end-offset>\n  // TODO: Support all formatting options once ratified in the spec.\n  const parts = value.split(' ');\n  const names = [];\n  const offsets = [];\n\n  parts.forEach(part => {\n    if (part.endsWith('%'))\n      offsets.push(parseFloat(part));\n    else\n      names.push(part);\n  });\n\n  if (names.length > 2 || offsets.length > 2 || offsets.length == 1) {\n    throw TypeError(\"Invalid time range\");\n  }\n\n  if (names.length) {\n    timeRange.start.name = names[0];\n    timeRange.end.name = names.length > 1 ? names[1] : names[0];\n  }\n\n  if (offsets.length > 1) {\n    timeRange.start.offset = CSS.percent(offsets[0]);\n    timeRange.end.offset = CSS.percent(offsets[1]);\n  }\n\n  return timeRange;\n}\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const timelineOffset = (options, property) => {\n     if (property in options) {\n        const value = options[property];\n        if (typeof value != 'number') {\n          delete options[property];\n          return value;\n        }\n        return null;\n     }\n  };\n\n  const updateDelay = (timelineOffset, value) => {\n    if (!value)\n      return;\n\n    // TODO(kevers): Update property names once ratified.\n    // https://github.com/w3c/csswg-drafts/issues/7589\n    if (value.phase)\n      timelineOffset.name = value.phase;\n\n    if (value.percent)\n      timelineOffset.offset = value.percent;\n  };\n\n  const delayTimelineOffset = timelineOffset(options, 'delay');\n  const endDelayTimelineOffset = timelineOffset(options, 'endDelay');\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    if (timeline instanceof ViewTimeline) {\n      const details = proxyAnimations.get(proxyAnimation);\n      details.timeRange = parseTimeRange(options.timeRange);\n      updateDelay(details.timeRange.start, delayTimelineOffset);\n      updateDelay(details.timeRange.end, endDelayTimelineOffset);\n    }\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// This is also used in scroll-timeline-css.js\nexport const RegexMatcher = {\n  IDENTIFIER: /[\\w\\\\\\@_-]+/g,\n  WHITE_SPACE: /\\s*/g,\n  NUMBER: /^[0-9]+/,\n  TIME: /^[0-9]+(s|ms)/,\n  VIEW_TIMELINE: /view-timeline\\s*:([^;}]+)/,\n  VIEW_TIMELINE_NAME: /view-timeline-name\\s*:([^;}]+)/,\n  VIEW_TIMELINE_AXIS: /view-timeline-axis\\s*:([^;}]+)/,\n  ANIMATION_TIMELINE: /animation-timeline\\s*:([^;}]+)/,\n  ANIMATION_DELAY: /animation-delay\\s*:([^;}]+)/,\n  ANIMATION_END_DELAY: /animation-end-delay\\s*:([^;}]+)/,\n  ANIMATION_TIME_RANGE: /animation-time-range\\s*:([^;}]+)/,\n  ANIMATION_NAME: /animation-name\\s*:([^;}]+)/,\n  ANIMATION: /animation\\s*:([^;}]+)/,\n  SOURCE_ELEMENT: /selector\\(#([^)]+)\\)/,\n};\n\n// Used for ANIMATION_TIMELINE, ANIMATION_NAME and ANIMATION regex\nconst VALUES_CAPTURE_INDEX = 1;\n\nconst WHOLE_MATCH_INDEX = 0;\n\nconst ANIMATION_KEYWORDS = [\n  'normal', 'reverse', 'alternate', 'alternate-reverse',\n  'none', 'forwards', 'backwards', 'both',\n  'running', 'paused',\n  'ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out'\n];\n\nconst VIEW_TIMELINE_AXIS_TYPES = ['block', 'inline',  'vertical', 'horizontal'];\n\n// 1 - Extracts @scroll-timeline and saves it in scrollTimelineOptions.\n// 2 - If we find any animation-timeline in any of the CSS Rules, \n// we will save objects in a list named cssRulesWithTimelineName\nexport class StyleParser {\n  constructor() {\n    this.cssRulesWithTimelineName = [];\n    this.scrollTimelineOptions = new Map(); // save options by name\n    this.subjectSelectorToViewTimeline = [];\n    this.keyframeNames = new Set();\n  }\n\n  // Inspired by\n  // https://drafts.csswg.org/css-syntax/#parser-diagrams\n  // https://github.com/GoogleChromeLabs/container-query-polyfill/blob/main/src/engine.ts\n  // This function is called twice, in the first pass we are interested in saving\n  // @scroll-timeline and @keyframe names, in the second pass\n  // we will parse other rules\n  transpileStyleSheet(sheetSrc, firstPass, srcUrl) {\n    // AdhocParser\n    const p = {\n      sheetSrc: sheetSrc,\n      index: 0,\n      name: srcUrl,\n    };\n\n    while (p.index < p.sheetSrc.length) {\n      this.eatWhitespace(p);\n      if (p.index >= p.sheetSrc.length) break;\n      if (this.lookAhead(\"/*\", p)) {\n        while (this.lookAhead(\"/*\", p)) {\n          this.eatComment(p);\n          this.eatWhitespace(p);\n        }\n        continue;\n      }\n\n      if (this.lookAhead(\"@scroll-timeline\", p)) {\n        const { scrollTimeline, startIndex, endIndex } = this.parseScrollTimeline(p);\n        if (firstPass) this.scrollTimelineOptions.set(scrollTimeline.name, scrollTimeline);\n      } else {\n        const rule = this.parseQualifiedRule(p);\n        if (!rule) continue;\n        if (firstPass) {\n          this.extractAndSaveKeyframeName(rule.selector);\n        } else {\n          this.handleScrollTimelineProps(rule, p);\n        }\n      }\n    }\n\n    // If this sheet has no srcURL (like from a <style> tag), we are done.\n    // TODO: Otherwise, we have to find `url()` functions and resolve\n    // relative and path-absolute URLs to absolute URLs.\n    return p.sheetSrc;\n  }\n\n  getAnimationTimelineOptions(animationName, target) {\n    // Rules are pushed to cssRulesWithTimelineName list in the same order as they appear in style sheet.\n    // We are traversing backwards to take the last sample of a rule in a style sheet.\n    // TODO: Rule specificity should be taken into account, i.e. don't just take the last\n    // rule that matches, instead take the one with the most specifity among those that match\n    for (let i = this.cssRulesWithTimelineName.length - 1; i >= 0; i--) {\n      const current = this.cssRulesWithTimelineName[i];\n      if (target.matches(current.selector)) {\n        if (!current['animation-name'] || current['animation-name'] == animationName) {\n          return {\n            'animation-timeline': current['animation-timeline'],\n            'animation-delay': current['animation-delay'],\n            'animation-end-delay': current['animation-end-delay'],\n            'animation-time-range': current['animation-time-range']\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  // This implementation is based on https://drafts.csswg.org/scroll-animations-1/\n  // TODO: Should update accordingly when new spec lands.\n  getSourceElement(source) {\n    const matches = RegexMatcher.SOURCE_ELEMENT.exec(source);\n    const SOURCE_CAPTURE_INDEX = 1;\n    if (matches)\n      return document.getElementById(matches[SOURCE_CAPTURE_INDEX]);\n    else if (source === \"auto\")\n      return document.scrollingElement;\n    else\n      return null;\n  }\n\n  getScrollTimelineOptions(timelineName) {\n    const options = this.scrollTimelineOptions.get(timelineName);\n\n    if(options?.source) {\n      const sourceElement = this.getSourceElement(options.source);\n      return {\n        ...(sourceElement ? { source: sourceElement } : {}),\n        ...(options.orientation != \"auto\" ? { orientation: options.orientation } : {}),\n      };\n    }\n\n    return null;\n  }\n\n  findPreviousSiblingOrAncestorMatchingSelector(target, selector) {\n    // Target self\n    let candidate = target;\n    \n    // Walk the DOM tree: preceding siblings and ancestors\n    while (candidate) {\n      if (candidate.matches(selector)) \n        return candidate;\n      candidate = candidate.previousElementSibling || candidate.parentElement;\n    }\n\n    // No match\n    return null;\n  }\n\n  getViewTimelineOptions(timelineName, target) {\n    for (let i = this.subjectSelectorToViewTimeline.length - 1; i >= 0; i--) {\n      const options = this.subjectSelectorToViewTimeline[i];\n      if(options.name == timelineName) {\n        const subject = this.findPreviousSiblingOrAncestorMatchingSelector(target, options.selector);\n        if(subject) {\n          return {\n            subject,\n            axis: options.axis,\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  parseScrollTimeline(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"@scroll-timeline\");\n    this.eatWhitespace(p);\n    let name = this.parseIdentifier(p);\n    this.eatWhitespace(p);\n    this.assertString(p, \"{\"); // eats {\n    this.eatWhitespace(p);\n\n    let scrollTimeline = {\n      name: name,\n      source: \"auto\",\n      orientation: undefined,\n    };\n\n    while (this.peek(p) !== \"}\") {\n      const property = this.parseIdentifier(p);\n      this.eatWhitespace(p);\n      this.assertString(p, \":\");\n      this.eatWhitespace(p);\n      scrollTimeline[property] = this.removeEnclosingDoubleQuotes(this.eatUntil(\";\", p));\n      this.assertString(p, \";\");\n      this.eatWhitespace(p);\n    }\n\n    this.assertString(p, \"}\");\n    const endIndex = p.index;\n    this.eatWhitespace(p);\n    return {\n      scrollTimeline,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  handleScrollTimelineProps(rule, p) {\n    // The animation-timeline property may not be used in keyframes\n    if (rule.selector.includes(\"@keyframes\")) {\n      return;\n    }\n\n    // TODO is it enough to check with \"includes()\"\n    const hasAnimationName = rule.block.contents.includes(\"animation-name:\");\n    const hasAnimationTimeline = rule.block.contents.includes(\"animation-timeline:\");\n    const hasAnimation = rule.block.contents.includes(\"animation:\");\n\n    this.saveSubjectSelectorToViewTimeline(rule);\n\n    let timelineNames = [];\n    let animationNames = [];\n\n    if (hasAnimationTimeline)\n      timelineNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_TIMELINE);\n\n    if (hasAnimationName)\n      animationNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_NAME);\n\n    if (hasAnimationTimeline && hasAnimationName) {\n      this.saveRelationInList(rule, timelineNames, animationNames);\n      return;\n    }\n\n    if (hasAnimation) {\n      this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION)\n        .forEach(shorthand => {\n          const animationName = this.extractAnimationName(shorthand);\n          const timelineName = this.extractTimelineName(shorthand);\n          if (animationName) animationNames.push(animationName);\n          if (timelineName) {\n            timelineNames.push(timelineName);\n            // Remove timeline name from animation shorthand\n            // so the native implementation works with the rest of the properties\n            // Retain length of original name though, to play nice with multiple\n            // animations that might have been applied\n            rule.block.contents = rule.block.contents.replace(\n              timelineName,\n              \" \".repeat(timelineName.length)\n            );\n            this.replacePart(\n              rule.block.startIndex,\n              rule.block.endIndex,\n              rule.block.contents,\n              p\n            );\n          }\n\n          // If there is no duration, animationstart will not happen,\n          // and polyfill will not work which is based on animationstart.\n          // Add 1s as duration to fix this.\n          if(timelineName || hasAnimationTimeline) {\n            if(!this.hasDuration(shorthand)) {\n              // TODO: Should keep track of whether duration is artificial or not,\n              // so that we can later track that we need to update timing to\n              // properly see duration as 'auto' for the polyfill.\n              rule.block.contents = rule.block.contents.replace(\n                \"animation:\",\n                \"animation: 1s \"\n              );\n              this.replacePart(\n                rule.block.startIndex,\n                rule.block.endIndex,\n                rule.block.contents,\n                p\n              );\n            }\n          }\n        });\n    }\n\n    this.saveRelationInList(rule, timelineNames, animationNames);\n  }\n\n  saveSubjectSelectorToViewTimeline(rule) {\n    const hasViewTimeline = rule.block.contents.includes(\"view-timeline:\");\n    const hasViewTimelineName = rule.block.contents.includes(\"view-timeline-name:\");\n    const hasViewTimelineAxis = rule.block.contents.includes(\"view-timeline-axis:\");\n\n    if(!hasViewTimeline && !hasViewTimelineName) return;\n\n    let viewTimeline = {selector: rule.selector, name: '', axis: 'block'};\n\n    if(hasViewTimeline) {\n      const parts = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE, separator=' ');\n      if(parts.length == 1) {\n        viewTimeline.name = parts[0];\n      } else if(parts.length == 2) {\n        if(VIEW_TIMELINE_AXIS_TYPES.includes(parts[0]))\n          viewTimeline.axis = parts[0], viewTimeline.name = parts[1];\n        else\n          viewTimeline.axis = parts[1], viewTimeline.name = parts[0];\n      }\n    }\n\n    if(hasViewTimelineName) {\n      const parts = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_NAME);\n      viewTimeline.name = parts[0];\n    }\n\n    if(hasViewTimelineAxis) {\n      const parts = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_AXIS);\n      if(VIEW_TIMELINE_AXIS_TYPES.includes(parts[0]))\n        viewTimeline.axis = parts[0];\n    }\n\n    this.subjectSelectorToViewTimeline.push(viewTimeline);\n  }\n\n  hasDuration(shorthand) {\n    return shorthand.split(\" \").filter(part => isTime(part)).length >= 1;\n  }\n\n  saveRelationInList(rule, timelineNames, animationNames) {\n    const hasAnimationDelay = rule.block.contents.includes(\"animation-delay:\");\n    const hasAnimationEndDelay = rule.block.contents.includes(\"animation-end-delay:\");\n    const hasAnimationTimeRange = rule.block.contents.includes(\"animation-time-range:\");\n\n    let animationDelays = [];\n    let animationEndDelays = [];\n    let animationTimeRanges = [];\n\n    if (hasAnimationDelay)\n      animationDelays = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_DELAY);\n\n    if (hasAnimationEndDelay)\n      animationEndDelays = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_END_DELAY);\n\n    if (hasAnimationTimeRange)\n      animationTimeRanges = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_TIME_RANGE);\n\n    const maxLength = Math.max(timelineNames.length, animationNames.length,\n      animationDelays.length, animationEndDelays.length, animationTimeRanges.length);\n\n    for (let i = 0; i < maxLength; i++) {\n      this.cssRulesWithTimelineName.push({\n        selector: rule.selector,\n        'animation-timeline': timelineNames[i % timelineNames.length],\n        ...(animationNames.length ? {'animation-name': animationNames[i % animationNames.length]}: {}),\n        ...(animationDelays.length ? {'animation-delay': animationDelays[i % animationDelays.length]}: {}),\n        ...(animationEndDelays.length ? {'animation-end-delay': animationEndDelays[i % animationEndDelays.length]}: {}),\n        ...(animationTimeRanges.length ? {'animation-time-range': animationTimeRanges[i % animationTimeRanges.length]}: {}),\n      });\n    }\n  }\n\n  extractAnimationName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.keyframeNames);\n  }\n\n  extractTimelineName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.scrollTimelineOptions);\n  }\n\n  findMatchingEntryInContainer(shorthand, container) {\n    const matches = shorthand.split(\" \").filter(part => container.has(part))\n    return matches ? matches[0] : null;\n  }\n\n\n  parseIdentifier(p) {\n    RegexMatcher.IDENTIFIER.lastIndex = p.index;\n    const match = RegexMatcher.IDENTIFIER.exec(p.sheetSrc);\n    if (!match) {\n      throw this.parseError(p, \"Expected an identifier\");\n    }\n    p.index += match[WHOLE_MATCH_INDEX].length;\n    return match[WHOLE_MATCH_INDEX];\n  }\n\n  /**\n   * @param {String} selector contains everything upto '{', eg: \"@keyframes expand\"\n   */\n  extractAndSaveKeyframeName(selector) {\n    if (selector.startsWith(\"@keyframes\")) {\n      selector.split(\" \").forEach((item, index) => {\n        if (index > 0) {\n          this.keyframeNames.add(item);\n        }\n      })\n    }\n  }\n\n  parseQualifiedRule(p) {\n    const startIndex = p.index;\n    const selector = this.parseSelector(p).trim();\n    if (!selector) return;\n    const block = this.eatBlock(p);\n    const endIndex = p.index;\n    return {\n      selector,\n      block,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  removeEnclosingDoubleQuotes(s) {\n    let startIndex = s[0] == '\"' ? 1 : 0;\n    let endIndex = s[s.length - 1] == '\"' ? s.length - 1 : s.length;\n    return s.substring(startIndex, endIndex);\n  }\n\n  assertString(p, s) {\n    if (p.sheetSrc.substr(p.index, s.length) != s) {\n      throw this.parseError(p, `Did not find expected sequence ${s}`);\n    }\n    p.index += s.length;\n  }\n\n  replacePart(start, end, replacement, p) {\n    p.sheetSrc = p.sheetSrc.slice(0, start) + replacement + p.sheetSrc.slice(end);\n    // If we are pointing past the end of the affected section, we need to\n    // recalculate the string pointer. Pointing to something inside the section\n    // that’s being replaced is undefined behavior. Sue me.\n    if (p.index >= end) {\n      const delta = p.index - end;\n      p.index = start + replacement.length + delta;\n    }\n  }\n\n  eatComment(p) {\n    this.assertString(p, \"/*\");\n    this.eatUntil(\"*/\", p, true);\n    this.assertString(p, \"*/\");\n  }\n\n  eatBlock(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"{\");\n    let level = 1;\n    while (level != 0) {\n      if(this.lookAhead(\"/*\", p)) {\n        this.eatComment(p);\n        continue;\n      }\n\n      if (p.sheetSrc[p.index] === \"{\") {\n        level++;\n      } else if (p.sheetSrc[p.index] === \"}\") {\n        level--;\n      }\n      this.advance(p);\n    }\n    const endIndex = p.index;\n    const contents = p.sheetSrc.slice(startIndex, endIndex);\n\n    return { startIndex, endIndex, contents };\n  }\n\n  advance(p) {\n    p.index++;\n    if (p.index > p.sheetSrc.length) {\n      throw this.parseError(p, \"Advanced beyond the end\");\n    }\n  }\n\n  eatUntil(s, p, replaceWithSpace=false) {\n    const startIndex = p.index;\n    while (!this.lookAhead(s, p)) {\n      this.advance(p);\n    }\n\n    if(replaceWithSpace) {\n      p.sheetSrc = p.sheetSrc.slice(0, startIndex)\n        + \" \".repeat(p.index - startIndex)\n        + p.sheetSrc.slice(p.index);\n    }\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  parseSelector(p) {\n    let startIndex = p.index;\n    this.eatUntil(\"{\", p);\n    if (startIndex === p.index) {\n      throw Error(\"Empty selector\");\n    }\n\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  eatWhitespace(p) {\n    // Start matching at the current position in the sheet src\n    RegexMatcher.WHITE_SPACE.lastIndex = p.index;\n    const match = RegexMatcher.WHITE_SPACE.exec(p.sheetSrc);\n    if (match) {\n      p.index += match[WHOLE_MATCH_INDEX].length;\n    }\n  }\n\n  lookAhead(s, p) {\n    return p.sheetSrc.substr(p.index, s.length) == s;\n  }\n\n  peek(p) {\n    return p.sheetSrc[p.index];\n  }\n\n  extractMatches(contents, matcher, separator=',') {\n    return matcher.exec(contents)[VALUES_CAPTURE_INDEX].trim().split(separator).map(item => item.trim());\n  }\n}\n\nfunction isTime(s) {\n  return RegexMatcher.TIME.exec(s);\n}\n\nfunction isNumber(s) {\n  return RegexMatcher.NUMBER.exec(s);\n}\n\nexport function removeKeywordsFromAnimationShorthand(anim) {\n  return anim.split(' ').filter(\n    (item, index, array) => index == array.length - 1 || !ANIMATION_KEYWORDS.includes(item))\n    .filter(item => !isTime(item) && !isNumber(item));\n}\n","import { StyleParser, RegexMatcher } from \"./scroll-timeline-css-parser\";\nimport { ProxyAnimation } from \"./proxy-animation\"\nimport { ScrollTimeline, ViewTimeline } from \"./scroll-timeline-base\";\n\nconst parser = new StyleParser();\n\nfunction initMutationObserver() {\n  const sheetObserver = new MutationObserver((entries) => {\n    for (const entry of entries) {\n      for (const addedNode of entry.addedNodes) {\n        if (addedNode instanceof HTMLStyleElement) {\n          handleStyleTag(addedNode);\n        }\n        if (addedNode instanceof HTMLLinkElement) {\n          handleLinkedStylesheet(addedNode);\n        }\n      }\n    }\n\n    // TODO: Proxy element.style similar to how we proxy element.animate.\n    // We accomplish this by swapping out Element.prototype.style.\n  });\n\n  sheetObserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n  });\n\n  /**\n   * @param {HtmlStyleElement} el style tag to be parsed\n   */\n  function handleStyleTag(el) {\n    // Don’t touch empty style tags.\n    if (el.innerHTML.trim().length === 0) {\n      return;\n    }\n    // TODO: Do with one pass for better performance\n    let newSrc = parser.transpileStyleSheet(el.innerHTML, true);\n    newSrc = parser.transpileStyleSheet(newSrc, false);\n    el.innerHTML = newSrc;\n  }\n\n  function handleLinkedStylesheet(el) {\n    // TODO\n  }\n\n  document.querySelectorAll(\"style\").forEach((tag) => handleStyleTag(tag));\n  document\n    .querySelectorAll(\"link\")\n    .forEach((tag) => handleLinkedStylesheet(tag));\n}\n\nfunction isDescendant(child, parent) {\n  while (child) {\n    if (child == parent) return true;\n    child = child.parentNode;\n  }\n  return false;\n}\n\nfunction createScrollTimeline(animationName, target) {\n  const animOptions = parser.getAnimationTimelineOptions(animationName, target);\n  const timelineName = animOptions['animation-timeline'];\n  if(!timelineName) return null;\n\n  let options = parser.getScrollTimelineOptions(timelineName) ||\n    parser.getViewTimelineOptions(timelineName, target);\n  if (!options) return null;\n\n  return {\n    timeline: options.source ? new ScrollTimeline(options) : new ViewTimeline(options),\n    animOptions: animOptions\n  };\n}\n\nexport function initCSSPolyfill() {\n  // Don't load if browser claims support\n  if (CSS.supports(\"animation-timeline: works\")) {\n    return;\n  }\n\n  initMutationObserver();\n\n  // We are not wrapping capturing 'animationstart' by a 'load' event,\n  // because we may lose some of the 'animationstart' events by the time 'load' is completed.\n  window.addEventListener('animationstart', (evt) => {\n    evt.target.getAnimations().filter(anim => anim.animationName === evt.animationName).forEach(anim => {\n      const result = createScrollTimeline(anim.animationName, evt.target);\n      if (result.timeline && anim.timeline != result.timeline) {\n        const proxyAnimation = new ProxyAnimation(anim, result.timeline, result.animOptions);\n        anim.pause();\n        proxyAnimation.play();\n      }\n    });\n  });\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  ViewTimeline,\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\n\nimport { initCSSPolyfill } from \"./scroll-timeline-css\"\n\ninitCSSPolyfill();\n\nif ([...document.styleSheets].filter(s => s.href !== null).length) {\n  console.warn(\"Non-Inline StyleSheets detected: ScrollTimeline polyfill currently only\" +\n    \" supports inline styles within style tags\");\n}\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\nif (\n  !Reflect.defineProperty(window, \"ViewTimeline\", { value: ViewTimeline })\n) {\n  throw Error(\n    \"Error installing ViewTimeline polyfill: could not attach ViewTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["_cssOMTypes","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","CSSUnitValue","MathOperation","operator","opt_name","opt_delimiter","set","this","name","delimiter","toString","details","get","join","_createClass","key","cssOMTypes","value","unit","prototype","toLowerCase","displayUnit","CSSKeywordValue","CSSMathSum","_MathOperation","call","arguments","_inheritsLoose","CSSMathProduct","_MathOperation2","CSSMathNegate","_MathOperation3","_MathOperation4","_MathOperation5","CSSMathMax","_MathOperation6","CSSMathMin","window","CSS","Reflect","defineProperty","Error","type","forEach","installCSSOM","scrollTimelineOptions","scrollEventSource","source","document","scrollingElement","updateInternal","scrollTimelineInstance","validateSource","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","timeline","ViewTimeline","node","subject","display","getContainingBlock","body","overflow","getScrollParent","updateSource","oldSource","oldScrollListener","scrollListener","removeEventListener","listener","addEventListener","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","inset","undefined","element","indexOf","TypeError","percent","container","scrollerStyle","phase","scrollPos","maxScrollPos","calculateMaxScrollOffset","scrollHeight","clientHeight","scrollWidth","clientWidth","findClosestAncestor","matcher","candidate","parentElement","isBlockContainer","isFixedElementContainer","style","transform","perspective","willChange","filter","backdropFilter","isAbsoluteElementContainer","position","range","target","top","left","ancestor","offsetParent","offsetLeft","offsetTop","clientLeft","clientTop","viewSize","viewPos","containerSize","direction","start","end","parts","split","insetParts","part","endsWith","parseFloat","parseInset","coverStartOffset","coverEndOffset","alignStartOffset","alignEndOffset","containStartOffset","min","containEndOffset","max","startOffset","endOffset","relativePosition","phaseRange","coverRange","_this","axis","_assertThisInitialized","unresolved","offsets","nativeElementAnimate","Element","animate","nativeAnimation","Animation","ANIMATION_DELAY_NAMES","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","notifyReady","createAbortError","DOMException","toCssNumberish","limit","effectEnd","fromCssNumberish","duration","convertedTime","to","convertTime","commitFinishedNotification","finishedPromise","proxy","playState","pause","finishedEvent","CustomEvent","detail","Object","queueMicrotask","dispatchEvent","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","effect","getTiming","normalizedTiming","delay","endDelay","iterations","setNativeCurrentTime","time","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","Infinity","play","bind","pendingTask","proxyAnimations","cancel","readyTime","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animOptions","animationTimeline","isScrollAnimation","specifiedTiming","timeRange","parseAnimationDelays","_proto2","finish","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","event","nativeUpdateTiming","updateTiming","getComputedTimingHandler","apply","localTime","endTime","activeDuration","getTimingHandler","thisArg","INTERNAL_DURATION_MS","startDelay","assign","computedDelays","offset","fractionalStartDelay","fractionalEndDelay","updateTimingHandler","argumentsList","Proxy","obj","prop","getComputedTiming","createProxyEffect","newEffect","newTimeline","oldTimeline","previousPlayState","progress","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","parseOneAnimationDelay","defaultOffset","includes","percentage","Number","isNaN","defaultAnimationDelay","defaultAnimationEndDelay","parseTimeRange","names","RegexMatcher","IDENTIFIER","WHITE_SPACE","NUMBER","TIME","VIEW_TIMELINE","VIEW_TIMELINE_NAME","VIEW_TIMELINE_AXIS","ANIMATION_TIMELINE","ANIMATION_DELAY","ANIMATION_END_DELAY","ANIMATION_TIME_RANGE","ANIMATION_NAME","ANIMATION","SOURCE_ELEMENT","VIEW_TIMELINE_AXIS_TYPES","parser","StyleParser","cssRulesWithTimelineName","Map","subjectSelectorToViewTimeline","keyframeNames","Set","transpileStyleSheet","sheetSrc","firstPass","srcUrl","p","index","eatWhitespace","lookAhead","eatComment","parseScrollTimeline","rule","parseQualifiedRule","extractAndSaveKeyframeName","selector","handleScrollTimelineProps","_proto","getAnimationTimelineOptions","animationName","current","matches","getSourceElement","exec","getElementById","getScrollTimelineOptions","timelineName","sourceElement","_extends","findPreviousSiblingOrAncestorMatchingSelector","previousElementSibling","getViewTimelineOptions","startIndex","assertString","parseIdentifier","peek","property","removeEnclosingDoubleQuotes","eatUntil","endIndex","hasAnimationName","block","contents","hasAnimationTimeline","hasAnimation","saveSubjectSelectorToViewTimeline","timelineNames","animationNames","extractMatches","shorthand","extractAnimationName","extractTimelineName","replace","repeat","replacePart","hasDuration","saveRelationInList","hasViewTimeline","hasViewTimelineName","hasViewTimelineAxis","viewTimeline","separator","isTime","hasAnimationDelay","hasAnimationEndDelay","hasAnimationTimeRange","animationDelays","animationEndDelays","animationTimeRanges","maxLength","findMatchingEntryInContainer","has","lastIndex","match","parseError","_this2","startsWith","item","add","parseSelector","trim","eatBlock","s","substring","substr","replacement","slice","level","advance","replaceWithSpace","map","supports","handleStyleTag","el","innerHTML","newSrc","MutationObserver","entries","_step","_iterator","_createForOfIteratorHelperLoose","done","_step2","_iterator2","addedNodes","addedNode","HTMLStyleElement","observe","documentElement","childList","subtree","querySelectorAll","tag","initMutationObserver","evt","getAnimations","anim","createScrollTimeline","proxyAnimation","styleSheets","href","console","warn","keyframes","timelineOffset","updateDelay","delayTimelineOffset","endDelayTimelineOffset"],"mappings":"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"}