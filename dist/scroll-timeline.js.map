{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\r\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\r\n    return obj;\r\n  if (!acceptStr)\r\n    return null;\r\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\r\n  if (matches) {\r\n    let value = matches[1];\r\n    // The unit for % is percent.\r\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\r\n    return new CSSUnitValue(value, unit);\r\n  }\r\n  return null;\r\n}\r\n","// Copyright 2019 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     https://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\nimport { parseLength } from \"./utils\";\r\n\r\nconst AUTO = new CSSKeywordValue(\"auto\");\r\n\r\nlet scrollTimelineOptions = new WeakMap();\r\nlet extensionScrollOffsetFunctions = [];\r\n\r\nfunction scrollEventSource(scrollSource) {\r\n  if (scrollSource === document.scrollingElement) return document;\r\n  return scrollSource;\r\n}\r\n\r\n/**\r\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\r\n * @param scrollTimelineInstance {ScrollTimeline}\r\n */\r\nfunction updateInternal(scrollTimelineInstance) {\r\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\r\n  if (animations.length === 0) return;\r\n  let timelineTime = scrollTimelineInstance.currentTime;\r\n\r\n  for (let i = 0; i < animations.length; i++) {\r\n    animations[i].tickAnimation(timelineTime);\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\r\n *  in case developer provided timeRange, we use that directly.\r\n * @param scrollTimeline {ScrollTimeline}\r\n * @returns {Number}\r\n */\r\nfunction calculateTimeRange(scrollTimeline) {\r\n  let timeRange = scrollTimeline.timeRange;\r\n  if (timeRange == AUTO) {\r\n    timeRange = 0;\r\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\r\n    for (let i = 0; i < animations.length; i++) {\r\n      timeRange = Math.max(timeRange,\r\n                           calculateTargetEffectEnd(animations[i].animation));\r\n    }\r\n    if (timeRange === Infinity) timeRange = 0;\r\n  }\r\n  return timeRange;\r\n}\r\n\r\n/**\r\n * Calculates a scroll offset that corrects for writing modes, text direction\r\n * and a logical orientation.\r\n * @param scrollTimeline {ScrollTimeline}\r\n * @param orientation {String}\r\n * @returns {Number}\r\n */\r\nfunction directionAwareScrollOffset(scrollSource, orientation) {\r\n  const style = getComputedStyle(scrollSource);\r\n  // All writing modes are vertical except for horizontal-tb.\r\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\r\n  // in Chrome.\r\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\r\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\r\n  let currentScrollOffset  = scrollSource.scrollTop;\r\n  if (orientation == 'horizontal' ||\r\n     (orientation == 'inline' && horizontalWritingMode) ||\r\n     (orientation == 'block' && !horizontalWritingMode)) {\r\n    // Negative values are reported for scrollLeft when the inline text\r\n    // direction is right to left or for vertical text with a right to left\r\n    // block flow. This is a consequence of shifting the scroll origin due to\r\n    // changes in the overflow direction.\r\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\r\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\r\n  }\r\n  return currentScrollOffset;\r\n}\r\n\r\n/**\r\n * Determines target effect end based on animation duration, iterations count and start and end delays\r\n *  returned value should always be positive\r\n * @param options {Animation} animation\r\n * @returns {number}\r\n */\r\nexport function calculateTargetEffectEnd(animation) {\r\n  return animation.effect.getComputedTiming().activeDuration;\r\n}\r\n\r\n/**\r\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\r\n * @param parseFunction {Function}\r\n * @param evaluateFunction {Function}\r\n * @returns {Array} all currently installed parsers\r\n */\r\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\r\n  extensionScrollOffsetFunctions.push({\r\n    parse: parseFunction,\r\n    evaluate: evaluateFunction,\r\n  });\r\n  return extensionScrollOffsetFunctions;\r\n}\r\n\r\n/**\r\n * Calculates scroll offset based on orientation and scrollSource geometry\r\n * @param scrollSource {DOMElement}\r\n * @param orientation {String}\r\n * @returns {number}\r\n */\r\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\r\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\r\n  // flow vertically.\r\n  const horizontalWritingMode =\r\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\r\n  if (orientation === \"block\")\r\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\r\n  else if (orientation === \"inline\")\r\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\r\n  if (orientation === \"vertical\")\r\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\r\n  else if (orientation === \"horizontal\")\r\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\r\n}\r\n\r\nfunction resolvePx(cssValue, resolvedLength) {\r\n  if (cssValue instanceof CSSUnitValue) {\r\n    if (cssValue.unit == \"percent\")\r\n      return cssValue.value * resolvedLength / 100;\r\n    else if (cssValue.unit == \"px\")\r\n      return cssValue.value;\r\n    else\r\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\r\n  } else if (cssValue instanceof CSSMathSum) {\r\n    let total = 0;\r\n    for (let value of cssValue.values) {\r\n      total += resolvePx(value, resolvedLength);\r\n    }\r\n    return total;\r\n  }\r\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\r\n}\r\n\r\nexport function calculateScrollOffset(\r\n  autoValue,\r\n  scrollSource,\r\n  orientation,\r\n  offset,\r\n  fn\r\n) {\r\n  if (fn)\r\n    return fn(\r\n      scrollSource,\r\n      orientation,\r\n      offset,\r\n      autoValue.value == 0 ? \"start\" : \"end\"\r\n    );\r\n  // TODO: Support other writing directions.\r\n  if (orientation === \"block\") orientation = \"vertical\";\r\n  else if (orientation === \"inline\") orientation = \"horizontal\";\r\n\r\n  let maxValue =\r\n    orientation === \"vertical\"\r\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\r\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\r\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\r\n  return resolvePx(parsed, maxValue);\r\n}\r\n\r\n/**\r\n * Resolve scroll offsets per\r\n * https://drafts.csswg.org/scroll-animations-1/#effective-scroll-offsets-algorithm\r\n * @param scrollSource {DOMElement}\r\n * @param orientation {String}\r\n * @param scrollOffsets {Array}\r\n * @param fns {Array}\r\n * @returns {Array}\r\n */\r\nexport function resolveScrollOffsets(\r\n  scrollSource,\r\n  orientation,\r\n  scrollOffsets,\r\n  fns\r\n) {\r\n  // 1. Let effective scroll offsets be an empty list of effective scroll\r\n  // offsets.\r\n  let effectiveScrollOffsets = [];\r\n  // 2. Let first offset be true.\r\n  let firstOffset = true;\r\n\r\n  // 3. If scrollOffsets is empty\r\n  if(scrollOffsets.length == 0) {\r\n    // 3.1 Run the procedure to resolve a scroll timeline offset for auto with\r\n    // the is first flag set to first offset and add the resulted value into\r\n    // effective scroll offsets.\r\n    effectiveScrollOffsets.push(\r\n      calculateScrollOffset(\r\n        new CSSUnitValue(0, 'percent'),\r\n        scrollSource,\r\n        orientation,\r\n        AUTO\r\n    ));\r\n    // 3.2 Set first offset to false.\r\n    firstOffset = false;\r\n    // 3.3 Run the procedure to resolve a scroll timeline offset for auto with\r\n    // the is first flag set to first offset and add the resulted value into\r\n    // effective scroll offsets.\r\n    effectiveScrollOffsets.push(\r\n      calculateScrollOffset(\r\n        new CSSUnitValue(100, 'percent'),\r\n        scrollSource,\r\n        orientation,\r\n        AUTO\r\n    ));\r\n  }\r\n  // 4. If scrollOffsets has exactly one element\r\n  else if(scrollOffsets.length == 1) {\r\n    // 4.1 Run the procedure to resolve a scroll timeline offset for auto with\r\n    // the is first flag set to first offset and add the resulted value into\r\n    // effective scroll offsets.\r\n    effectiveScrollOffsets.push(\r\n      calculateScrollOffset(\r\n        new CSSUnitValue(0, 'percent'),\r\n        scrollSource,\r\n        orientation,\r\n        AUTO\r\n    ));\r\n    // 4.2 Set first offset to false.\r\n    firstOffset = false;\r\n  }\r\n  // 5. For each scroll offset in the list of scrollOffsets, perform the\r\n  // following steps:\r\n  for (let i = 0; i < scrollOffsets.length; i++) {\r\n    // 5.1 Let effective offset be the result of applying the procedure\r\n    // to resolve a scroll timeline offset for scroll offset with the is\r\n    // first flag set to first offset.\r\n    let effectiveOffset = calculateScrollOffset(\r\n      firstOffset ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'),\r\n      scrollSource,\r\n      orientation,\r\n      scrollOffsets[i],\r\n      fns[i]);\r\n    //  5.2 If effective offset is null, the effective scroll offsets is empty and abort the remaining steps.\r\n    if(effectiveOffset === null)\r\n      return [];\r\n    // 5.3 Add effective offset into effective scroll offsets.\r\n    effectiveScrollOffsets.push(effectiveOffset);\r\n    // 5.4 Set first offset to false.\r\n    firstOffset = false;\r\n  }\r\n  // 6. Return effective scroll offsets.\r\n  return effectiveScrollOffsets;\r\n}\r\n\r\n/**\r\n * Compute scroll timeline progress per\r\n * https://drafts.csswg.org/scroll-animations-1/#progress-calculation-algorithm\r\n * @param offset {number}\r\n * @param scrollOffsets {Array}\r\n * @returns {number}\r\n */\r\nexport function ComputeProgress(\r\n  offset,\r\n  scrollOffsets\r\n) {\r\n  // 1. Let scroll offsets be the result of applying the procedure to resolve\r\n  // scroll timeline offsets for scrollOffsets.\r\n  // 2. Let offset index correspond to the position of the last offset in\r\n  // scroll offsets whose value is less than or equal to offset and the value\r\n  // at the following position greater than offset.\r\n  let offsetIndex;\r\n  for (offsetIndex = scrollOffsets.length - 2;\r\n       offsetIndex >= 0 && \r\n         !(scrollOffsets[offsetIndex] <= offset && offset < scrollOffsets[offsetIndex + 1]);\r\n       offsetIndex--) {\r\n  }\r\n  // 3. Let start offset be the offset value at position offset index in\r\n  // scroll offsets.\r\n  let startOffset = scrollOffsets[offsetIndex];\r\n  // 4. Let end offset be the value of next offset in scroll offsets after\r\n  // start offset.\r\n  let endOffset = scrollOffsets[offsetIndex + 1];\r\n  // 5. Let size be the number of offsets in scroll offsets.\r\n  let size = scrollOffsets.length;\r\n  // 6. Let offset weight be the result of evaluating 1 / (size - 1).\r\n  let offsetWeight = 1 / (size - 1);\r\n  // 7. Let interval progress be the result of evaluating\r\n  // (offset - start offset) / (end offset - start offset).\r\n  let intervalProgress =  (offset - startOffset) / (endOffset - startOffset);\r\n  // 8. Return the result of evaluating\r\n  // (offset index + interval progress) × offset weight.\r\n  return (offsetIndex + intervalProgress) * offsetWeight;\r\n}\r\n\r\n/**\r\n * Removes a Web Animation instance from ScrollTimeline\r\n * @param scrollTimeline {ScrollTimeline}\r\n * @param animation {Animation}\r\n * @param options {Object}\r\n */\r\nexport function removeAnimation(scrollTimeline, animation) {\r\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\r\n  for (let i = 0; i < animations.length; i++) {\r\n    if (animations[i].animation == animation) {\r\n      animations.splice(i, 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Attaches a Web Animation instance to ScrollTimeline.\r\n * @param scrollTimeline {ScrollTimeline}\r\n * @param animation {Animation}\r\n * @param tickAnimation {function(number)}\r\n */\r\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\r\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\r\n  for (let i = 0; i < animations.length; i++) {\r\n    if (animations[i].animation == animation)\r\n      return;\r\n  }\r\n\r\n  animations.push({\r\n    animation: animation,\r\n    tickAnimation: tickAnimation\r\n  });\r\n  updateInternal(scrollTimeline);\r\n}\r\n\r\n// TODO: this is a private function used for unit testing add function\r\nexport function _getStlOptions(scrollTimeline) {\r\n  return scrollTimelineOptions.get(scrollTimeline);\r\n}\r\n\r\nexport class ScrollTimeline {\r\n  constructor(options) {\r\n    scrollTimelineOptions.set(this, {\r\n      scrollSource: null,\r\n      orientation: \"block\",\r\n      scrollOffsets: [],\r\n      timeRange: AUTO,\r\n\r\n      // Internal members\r\n      animations: [],\r\n      scrollOffsetFns: [],\r\n    });\r\n    this.scrollSource =\r\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\r\n    this.orientation = (options && options.orientation) || \"block\";\r\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\r\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\r\n  }\r\n\r\n  set scrollSource(element) {\r\n    if (this.scrollSource)\r\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\r\n        updateInternal(this)\r\n      );\r\n    scrollTimelineOptions.get(this).scrollSource = element;\r\n    if (element) {\r\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\r\n        updateInternal(this)\r\n      );\r\n    }\r\n    updateInternal(this);\r\n  }\r\n\r\n  get scrollSource() {\r\n    return scrollTimelineOptions.get(this).scrollSource;\r\n  }\r\n\r\n  set orientation(orientation) {\r\n    if (\r\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\r\n    ) {\r\n      throw TypeError(\"Invalid orientation\");\r\n    }\r\n    scrollTimelineOptions.get(this).orientation = orientation;\r\n    updateInternal(this);\r\n  }\r\n\r\n  get orientation() {\r\n    return scrollTimelineOptions.get(this).orientation;\r\n  }\r\n\r\n  set scrollOffsets(value) {\r\n    let offsets = [];\r\n    let fns = [];\r\n    for (let input of value) {\r\n      let fn = null;\r\n      let offset = undefined;\r\n      if (input == \"auto\")\r\n        input = AUTO;\r\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\r\n        let result = extensionScrollOffsetFunctions[i].parse(input);\r\n        if (result !== undefined) {\r\n          offset = result;\r\n          fn = extensionScrollOffsetFunctions[i].evaluate;\r\n          break;\r\n        }\r\n      }\r\n      if (!fn) {\r\n        if (input != AUTO) {\r\n          let parsed = parseLength(input);\r\n          // TODO: This should check CSSMathSum values as well.\r\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\r\n            throw TypeError(\"Invalid scrollOffsets entry.\");\r\n        }\r\n        offset = input;\r\n      }\r\n      offsets.push(offset);\r\n      fns.push(fn);\r\n    }\r\n    if (offsets.length == 1 && offsets[0] == AUTO)\r\n      throw TypeError(\"Invalid scrollOffsets value.\");\r\n    let data = scrollTimelineOptions.get(this);\r\n    data.scrollOffsets = offsets;\r\n    data.scrollOffsetFns = fns;\r\n  }\r\n\r\n  get scrollOffsets() {\r\n    let data = scrollTimelineOptions.get(this);\r\n    return data.scrollOffsets;\r\n  }\r\n\r\n  set timeRange(range) {\r\n    if (range != \"auto\") {\r\n      // Check for a valid number, which if finite and not NaN.\r\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\r\n        throw TypeError(\"Invalid timeRange value\");\r\n    }\r\n    scrollTimelineOptions.get(this).timeRange = range;\r\n    updateInternal(this);\r\n  }\r\n\r\n  get timeRange() {\r\n    return scrollTimelineOptions.get(this).timeRange;\r\n  }\r\n\r\n  get phase() {\r\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\r\n    // Step 1\r\n    let unresolved = null;\r\n    //   if source is null\r\n    if (!this.scrollSource) return \"inactive\";\r\n    let scrollerStyle = getComputedStyle(this.scrollSource);\r\n\r\n    //   if source does not currently have a CSS layout box\r\n    if (scrollerStyle.display == \"none\")\r\n      return \"inactive\";\r\n\r\n    //   if source's layout box is not a scroll container\"\r\n    if (this.scrollSource != document.scrollingElement &&\r\n        (scrollerStyle.overflow == 'visible' ||\r\n         scrollerStyle.overflow == \"clip\")) {\r\n        return \"inactive\";\r\n    }\r\n\r\n    let effectiveScrollOffsets = resolveScrollOffsets(\r\n      this.scrollSource,\r\n      this.orientation,\r\n      this.scrollOffsets,\r\n      scrollTimelineOptions.get(this).scrollOffsetFns\r\n    );\r\n\r\n    //   if source's effective scroll range is null\r\n    if (effectiveScrollOffsets.length == 0)\r\n      return \"inactive\";\r\n\r\n    let maxOffset = calculateScrollOffset(\r\n      new CSSUnitValue(100, 'percent'),\r\n      this.scrollSource,\r\n      this.orientation,\r\n      new CSSUnitValue(100, 'percent'),\r\n      null\r\n    );\r\n    let startOffset = effectiveScrollOffsets[0];\r\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\r\n\r\n    // Step 2\r\n    const currentScrollOffset =\r\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\r\n\r\n    // Step 3\r\n    if (currentScrollOffset < startOffset)\r\n      return \"before\";\r\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\r\n      return \"after\";\r\n    return \"active\"\r\n  }\r\n\r\n  get currentTime() {\r\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\r\n    // Step 1\r\n    let unresolved = null;\r\n    if (!this.scrollSource) return unresolved;\r\n    if (this.phase == 'inactive')\r\n      return unresolved;\r\n\r\n    let effectiveScrollOffsets = resolveScrollOffsets(\r\n      this.scrollSource,\r\n      this.orientation,\r\n      this.scrollOffsets,\r\n      scrollTimelineOptions.get(this).scrollOffsetFns\r\n    );\r\n    let startOffset = effectiveScrollOffsets[0];\r\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\r\n    let timeRange = calculateTimeRange(this);\r\n\r\n    // Step 2\r\n    const currentScrollOffset =\r\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\r\n\r\n    // Step 3\r\n    if (currentScrollOffset < startOffset)\r\n      return 0;\r\n\r\n    // Step 4\r\n    if (currentScrollOffset >= endOffset)\r\n      return timeRange;\r\n\r\n    // Step 5\r\n    let progress = ComputeProgress(\r\n      currentScrollOffset,\r\n      effectiveScrollOffsets\r\n    );\r\n    return progress * timeRange;\r\n  }\r\n\r\n  get __polyfill() {\r\n    return true;\r\n  }\r\n}\r\n","import {\r\n  ScrollTimeline,\r\n  installScrollOffsetExtension,\r\n  addAnimation,\r\n  removeAnimation\r\n} from \"./scroll-timeline-base\";\r\n\r\nconst nativeElementAnimate = window.Element.prototype.animate;\r\nconst nativeAnimation = window.Animation;\r\n\r\nclass PromiseWrapper {\r\n  constructor() {\r\n    this.state = 'pending';\r\n    this.nativeResolve = this.nativeReject = null;\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this.nativeResolve = resolve;\r\n      this.nativeReject = reject;\r\n    });\r\n  }\r\n  resolve(value) {\r\n    this.state = 'resolved';\r\n    this.nativeResolve(value);\r\n  }\r\n  reject(reason) {\r\n    this.state = 'rejected';\r\n    // Do not report unhandled promise rejections.\r\n    this.promise.catch(() => {});\r\n    this.nativeReject(reason);\r\n  }\r\n}\r\n\r\nfunction createReadyPromise(details) {\r\n  details.readyPromise = new PromiseWrapper();\r\n  // Trigger the pending task on the next animation frame.\r\n  requestAnimationFrame(() => {\r\n    const timelineTime = details.timeline.currentTime;\r\n    if (timelineTime !== null)\r\n      notifyReady(details);\r\n  });\r\n}\r\n\r\nfunction createAbortError() {\r\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\r\n}\r\n\r\nfunction commitPendingPlay(details)  {\r\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\r\n  // Refer to steps listed under \"Schedule a task to run ...\"\r\n\r\n  const timelineTime = details.timeline.currentTime;\r\n  if (details.holdTime != null) {\r\n    // A: If animation’s hold time is resolved,\r\n    // A.1. Apply any pending playback rate on animation.\r\n    // A.2. Let new start time be the result of evaluating:\r\n    //        ready time - hold time / playback rate for animation.\r\n    //      If the playback rate is zero, let new start time be simply ready\r\n    //      time.\r\n    // A.3. Set the start time of animation to new start time.\r\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\r\n    //      time unresolved.\r\n    applyPendingPlaybackRate(details);\r\n    if (details.animation.playbackRate == 0) {\r\n      details.startTime = timelineTime;\r\n    } else {\r\n      details.startTime\r\n          = timelineTime -\r\n              details.holdTime / details.animation.playbackRate;\r\n      details.holdTime = null;\r\n    }\r\n  } else if (details.startTime !== null &&\r\n             details.pendingPlaybackRate !== null) {\r\n    // B: If animation’s start time is resolved and animation has a pending\r\n    //    playback rate,\r\n    // B.1. Let current time to match be the result of evaluating:\r\n    //        (ready time - start time) × playback rate for animation.\r\n    // B.2 Apply any pending playback rate on animation.\r\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\r\n    //     be current time to match.\r\n    // B.4 Let new start time be the result of evaluating:\r\n    //       ready time - current time to match / playback rate\r\n    //     for animation.\r\n    //     If the playback rate is zero, let new start time be simply ready\r\n    //     time.\r\n    // B.5 Set the start time of animation to new start time.\r\n    const currentTimeToMatch =\r\n        (timelineTime - details.startTime) * details.animation.playbackRate;\r\n    applyPendingPlaybackRate(details);\r\n    const playbackRate = details.animation.playbackRate;\r\n    if (playbackRate == 0) {\r\n      details.holdTime = null;\r\n      details.startTime = timelineTime;\r\n    } else {\r\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\r\n    }\r\n  }\r\n\r\n  // 8.4 Resolve animation’s current ready promise with animation.\r\n  if (details.readyPromise && details.readyPromise.state == 'pending')\r\n     details.readyPromise.resolve(details.proxy);\r\n\r\n  // 8.5 Run the procedure to update an animation’s finished state for\r\n  //     animation with the did seek flag set to false, and the\r\n  //     synchronously notify flag set to false.\r\n  updateFinishedState(details, false, false);\r\n\r\n  // Additional polyfill step to update the native animation's current time.\r\n  syncCurrentTime(details);\r\n  details.pendingTask = null;\r\n};\r\n\r\nfunction commitPendingPause(details) {\r\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\r\n  // Refer to steps listed under \"Schedule a task to run ...\"\r\n\r\n  // 1. Let ready time be the time value of the timeline associated with\r\n  //    animation at the moment when the user agent completed processing\r\n  //    necessary to suspend playback of animation’s target effect.\r\n  const readyTime = details.timeline.currentTime;\r\n\r\n  // 2. If animation’s start time is resolved and its hold time is not\r\n  //    resolved, let animation’s hold time be the result of evaluating\r\n  //    (ready time - start time) × playback rate.\r\n  if (details.startTime != null && details.holdTime == null) {\r\n    details.holdTime =\r\n        (readyTime - details.startTime) * details.animation.playbackRate;\r\n  }\r\n\r\n  // 3. Apply any pending playback rate on animation.\r\n  applyPendingPlaybackRate(details);\r\n\r\n  // 4. Make animation’s start time unresolved.\r\n  details.startTime = null;\r\n\r\n  // 5. Resolve animation’s current ready promise with animation.\r\n  details.readyPromise.resolve(details.proxy);\r\n\r\n  // 6. Run the procedure to update an animation’s finished state for\r\n  // animation with the did seek flag set to false, and the synchronously\r\n  //  notify flag set to false.\r\n  updateFinishedState(details, false, false);\r\n\r\n  // Additional polyfill step to update the native animation's current time.\r\n  syncCurrentTime(details);\r\n  details.pendingTask = null;\r\n};\r\n\r\nfunction commitFinishedNotification(details) {\r\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\r\n    return;\r\n\r\n  if (details.proxy.playState != 'finished')\r\n    return;\r\n\r\n  details.finishedPromise.resolve(details.proxy);\r\n  // Handle the finished event via the native animation.\r\n  // TODO: consider polyfilling queuing the event.\r\n  details.animation.finish();\r\n  details.animation.pause();\r\n}\r\n\r\nfunction effectivePlaybackRate(details) {\r\n  if (details.pendingPlaybackRate !== null)\r\n    return details.pendingPlaybackRate;\r\n  return details.animation.playbackRate;\r\n}\r\n\r\nfunction applyPendingPlaybackRate(details) {\r\n  if (details.pendingPlaybackRate !== null) {\r\n    details.animation.playbackRate = details.pendingPlaybackRate;\r\n    details.pendingPlaybackRate = null;\r\n  }\r\n}\r\n\r\nfunction calculateCurrentTime(details) {\r\n  if (!details.timeline)\r\n    return null;\r\n\r\n  const timelineTime = details.timeline.currentTime;\r\n  if (timelineTime === null)\r\n    return null;\r\n\r\n  if (details.startTime === null)\r\n    return null;\r\n\r\n  let currentTime =\r\n      (timelineTime - details.startTime) * details.animation.playbackRate;\r\n\r\n  // Handle special case.\r\n  if (currentTime == -0)\r\n    currentTime = 0;\r\n\r\n  return currentTime;\r\n}\r\n\r\nfunction calculateStartTime(details, currentTime) {\r\n  if (!details.timeline)\r\n    return null;\r\n\r\n  const timelineTime = details.timeline.currentTime;\r\n  if (timelineTime == null)\r\n    return null;\r\n\r\n  return timelineTime - currentTime / details.animation.playbackRate;\r\n}\r\n\r\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\r\n  if (!details.timeline)\r\n    return;\r\n\r\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\r\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\r\n  // required to accommodate timelines that may change direction. Without this\r\n  // distinction, a once-finished animation would remain finished even when its\r\n  // timeline progresses in the opposite direction.\r\n  const unconstrainedCurrentTime =\r\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\r\n\r\n  // 2. Conditionally update the hold time.\r\n  if (unconstrainedCurrentTime && details.startTime != null &&\r\n      !details.proxy.pending) {\r\n    // Can seek outside the bounds of the active effect. Set the hold time to\r\n    // the unconstrained value of the current time in the event that this update\r\n    // is the result of explicitly setting the current time and the new time\r\n    // is out of bounds. An update due to a time tick should not snap the hold\r\n    // value back to the boundary if previously set outside the normal effect\r\n    // boundary. The value of previous current time is used to retain this\r\n    // value.\r\n    const playbackRate = effectivePlaybackRate(details);\r\n    const upperBound = effectEnd(details);\r\n    let boundary = details.previousCurrentTime;\r\n    // TODO: Support hold phase.\r\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\r\n      if (boundary === null || boundary < upperBound)\r\n        boundary = upperBound;\r\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\r\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\r\n      if (boundary == null || boundary > 0)\r\n        boundary = 0;\r\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\r\n    } else if (playbackRate != 0) {\r\n      // Update start time and reset hold time.\r\n      if (didSeek && details.holdTime !== null)\r\n        details.startTime = calculateStartTime(details, details.holdTime);\r\n      details.holdTime = null;\r\n    }\r\n  }\r\n\r\n  // Additional step to ensure that the native animation has the same value for\r\n  // current time as the proxy.\r\n  syncCurrentTime(details);\r\n\r\n  // 3. Set the previous current time.\r\n  details.previousCurrentTime = details.proxy.currentTime;\r\n\r\n  // 4. Set the current finished state.\r\n  const playState = details.proxy.playState;\r\n\r\n  if (playState == 'finished') {\r\n    if (!details.finishedPromise)\r\n      details.finishedPromise = new PromiseWrapper();\r\n    if (details.finishedPromise.state == 'pending') {\r\n      // 5. Setup finished notification.\r\n      if (synchronouslyNotify) {\r\n        commitFinishedNotification(details);\r\n      } else {\r\n        Promise.resolve().then(() => {\r\n          commitFinishedNotification(details);\r\n        });\r\n      }\r\n    }\r\n  } else {\r\n    // 6. If not finished but the current finished promise is already resolved,\r\n    //    create a new promise.\r\n    if (details.finishedPromise &&\r\n        details.finishedPromise.state == 'resolved') {\r\n      details.finishedPromise = new PromiseWrapper();\r\n    }\r\n    if (details.animation.playState != 'paused')\r\n      details.animation.pause();\r\n  }\r\n}\r\n\r\nfunction effectEnd(details) {\r\n  // https://www.w3.org/TR/web-animations-1/#end-time\r\n  const timing = details.animation.effect.getTiming();\r\n  const totalDuration =\r\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\r\n  return Math.max(0, totalDuration);\r\n}\r\n\r\n\r\nfunction hasActiveTimeline(details) {\r\n  return !details.timeline || details.timeline.phase != 'inactive';\r\n}\r\n\r\nfunction syncCurrentTime(details) {\r\n  if (!details.timeline)\r\n    return;\r\n\r\n  if (details.startTime !== null) {\r\n    const timelineTime = details.timeline.currentTime;\r\n    details.animation.currentTime =\r\n        (timelineTime - details.startTime) * details.animation.playbackRate;\r\n  } else if (details.holdTime !== null) {\r\n    details.animation.currentTime = details.holdTime;\r\n  }\r\n}\r\n\r\nfunction resetPendingTasks(details) {\r\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\r\n\r\n  // 1. If animation does not have a pending play task or a pending pause task,\r\n  //    abort this procedure.\r\n  if (!details.pendingTask)\r\n    return;\r\n\r\n  // 2. If animation has a pending play task, cancel that task.\r\n  // 3. If animation has a pending pause task, cancel that task.\r\n  details.pendingTask = null;\r\n\r\n  // 4. Apply any pending playback rate on animation.\r\n  applyPendingPlaybackRate(details);\r\n\r\n  // 5. Reject animation’s current ready promise with a DOMException named\r\n  //    \"AbortError\".\r\n  details.readyPromise.reject(createAbortError());\r\n\r\n  // 6. Let animation’s current ready promise be the result of creating a new\r\n  //    resolved Promise object.\r\n  createReadyPromise(details);\r\n  details.readyPromise.resolve(details.proxy);\r\n}\r\n\r\nfunction playInternal(details, autoRewind) {\r\n  if (!details.timeline)\r\n    return;\r\n\r\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\r\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\r\n  //    pending pause task, and false otherwise.\r\n  const abortedPause =\r\n     details.proxy.playState == 'paused' && details.proxy.pending;\r\n\r\n  // 2. Let has pending ready promise be a boolean flag that is initially\r\n  //    false.\r\n  let hasPendingReadyPromise = false;\r\n\r\n  // 3. Let seek time be a time value that is initially unresolved.\r\n  let seekTime = null;\r\n\r\n  // 4. Let has finite timeline be true if animation has an associated\r\n  //    timeline that is not monotonically increasing.\r\n  //    Note: this value will always true at this point in the polyfill.\r\n  //    Following steps are pruned based on the procedure for scroll\r\n  //    timelines.\r\n\r\n  // 5. Perform the steps corresponding to the first matching condition from\r\n  //    the following, if any:\r\n  //\r\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\r\n  //    true and either animation’s:\r\n  //      current time is unresolved, or\r\n  //      current time < zero, or\r\n  //      current time >= target effect end,\r\n  //    5a1. Set seek time to zero.\r\n  //\r\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\r\n  //    true and either animation’s:\r\n  //      current time is unresolved, or\r\n  //      current time ≤ zero, or\r\n  //      current time > target effect end,\r\n  //    5b1. If associated effect end is positive infinity,\r\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\r\n  //    5b2. Otherwise,\r\n  //         5b2a Set seek time to animation's associated effect end.\r\n  //\r\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\r\n  //    is unresolved,\r\n  //    5c1. Set seek time to zero.\r\n  let previousCurrentTime = details.proxy.currentTime;\r\n\r\n  // Resume of a paused animation after a timeline change snaps to the scroll\r\n  // position.\r\n  if (details.resetCurrentTimeOnResume) {\r\n    previousCurrentTime = null;\r\n    details.resetCurrentTimeOnResume = false;\r\n  }\r\n\r\n  const playbackRate = effectivePlaybackRate(details);\r\n  const upperBound = effectEnd(details);\r\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\r\n                                         previousCurrentTime < 0 ||\r\n                                         previousCurrentTime >= upperBound)) {\r\n    seekTime = 0;\r\n  } else if (playbackRate < 0 && autoRewind &&\r\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\r\n             previousCurrentTime > upperBound)) {\r\n    if (upperBound == Infinity) {\r\n      // Defer to native implementation to handle throwing the exception.\r\n      details.animation.play();\r\n      return;\r\n    }\r\n    seekTime = upperBound;\r\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\r\n    seekTime = 0;\r\n  }\r\n\r\n  // 6. If seek time is resolved,\r\n  //        6a1. Set animation's start time to seek time.\r\n  //        6a2. Let animation's hold time be unresolved.\r\n  //        6a3. Apply any pending playback rate on animation.\r\n  if (seekTime != null) {\r\n    details.startTime = seekTime;\r\n    details.holdTime = null;\r\n    applyPendingPlaybackRate(details);\r\n  }\r\n\r\n  // Additional step for the polyfill.\r\n  addAnimation(details.timeline, details.animation,\r\n               tickAnimation.bind(details.proxy));\r\n\r\n  // 7. If animation's hold time is resolved, let its start time be\r\n  //    unresolved.\r\n  if (details.holdTime) {\r\n    details.startTime = null;\r\n  }\r\n\r\n  // 8. If animation has a pending play task or a pending pause task,\r\n  //   8.1 Cancel that task.\r\n  //   8.2 Set has pending ready promise to true.\r\n  if (details.pendingTask) {\r\n    details.pendingTask = null;\r\n    hasPendingReadyPromise = true;\r\n  }\r\n\r\n  // 9. If the following three conditions are all satisfied:\r\n  //      animation’s hold time is unresolved, and\r\n  //      seek time is unresolved, and\r\n  //      aborted pause is false, and\r\n  //      animation does not have a pending playback rate,\r\n  //    abort this procedure.\r\n  if (details.holdTime === null && seekTime === null &&\r\n      !abortedPause && details.pendingPlaybackRate === null)\r\n  return;\r\n\r\n  // 10. If has pending ready promise is false, let animation’s current ready\r\n  //    promise be a new promise in the relevant Realm of animation.\r\n  if (details.readyPromise && !hasPendingReadyPromise)\r\n    details.readyPromise = null;\r\n\r\n  // Additional polyfill step to ensure that the native animation has the\r\n  // correct value for current time.\r\n  syncCurrentTime(details);\r\n\r\n  // 11. Schedule a task to run as soon as animation is ready.\r\n  if (!details.readyPromise)\r\n    createReadyPromise(details);\r\n  details.pendingTask = 'play';\r\n\r\n  // 12. Run the procedure to update an animation’s finished state for animation\r\n  //     with the did seek flag set to false, and the synchronously notify flag\r\n  //     set to false.\r\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\r\n}\r\n\r\nfunction tickAnimation(timelineTime) {\r\n  const details = proxyAnimations.get(this);\r\n  if (timelineTime == null) {\r\n    // While the timeline is inactive, it's effect should not be applied.\r\n    // To polyfill this behavior, we cancel the underlying animation.\r\n    if (details.animation.playState != 'idle')\r\n      details.animation.cancel();\r\n    return;\r\n  }\r\n\r\n  if (details.pendingTask) {\r\n    notifyReady(details);\r\n  }\r\n\r\n  const playState = this.playState;\r\n  if (playState == 'running' || playState == 'finished') {\r\n    details.animation.currentTime =\r\n        (timelineTime - this.startTime) * this.playbackRate;\r\n\r\n    // Conditionally reset the hold time so that the finished state can be\r\n    // properly recomputed.\r\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\r\n      details.holdTime = null;\r\n    updateFinishedState(details, false, false);\r\n  }\r\n}\r\n\r\nfunction notifyReady(details) {\r\n  if (details.pendingTask == 'pause') {\r\n    commitPendingPause(details);\r\n  } else if (details.pendingTask == 'play') {\r\n    commitPendingPlay(details);\r\n  }\r\n}\r\n\r\n// Create an alternate Animation class which proxies API requests.\r\n// TODO: Create a full-fledged proxy so missing methods are automatically\r\n// fetched from Animation.\r\nlet proxyAnimations = new WeakMap();\r\n\r\nexport class ProxyAnimation {\r\n  constructor(effect, timeline) {\r\n    const animation =\r\n        (effect instanceof nativeAnimation) ?\r\n           effect : new nativeAnimation(effect, animationTimeline);\r\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\r\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\r\n    proxyAnimations.set(this, {\r\n      animation: animation,\r\n      timeline: isScrollAnimation ? timeline : undefined,\r\n      playState: isScrollAnimation ? \"idle\" : null,\r\n      readyPromise: null,\r\n      finishedPromise: null,\r\n      // Start and hold times are directly tracked in the proxy despite being\r\n      // accessible via the animation so that direct manipulation of these\r\n      // properties does not affect the play state of the underlying animation.\r\n      // Note that any changes to these values require an update of current\r\n      // time for the underlying animation to ensure that its hold time is set\r\n      // to the correct position.\r\n      startTime: null,\r\n      holdTime: null,\r\n      previousCurrentTime: null,\r\n      // When changing the timeline on a paused animation, we defer updating the\r\n      // start time until the animation resumes playing.\r\n      resetCurrentTimeOnResume: false,\r\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\r\n      // not immediately take effect. The value of this property is\r\n      // inaccessible via the web animations API and therefore explicitly\r\n      // tracked.\r\n      pendingPlaybackRate: null,\r\n      pendingTask: null,\r\n      proxy: this\r\n    });\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Web animation API\r\n  // -----------------------------------------\r\n\r\n  get effect() {\r\n    return proxyAnimations.get(this).animation.effect;\r\n  }\r\n  set effect(newEffect) {\r\n    proxyAnimations.get(this).animation.effect = newEffect;\r\n  }\r\n\r\n  get timeline() {\r\n    const details = proxyAnimations.get(this);\r\n    // If we explicitly set a null timeline we will return the underlying\r\n    // animation's timeline.\r\n    return details.timeline || details.animation.timeline;\r\n  }\r\n  set timeline(newTimeline) {\r\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\r\n\r\n    // 1. Let old timeline be the current timeline of animation, if any.\r\n    // 2. If new timeline is the same object as old timeline, abort this\r\n    //    procedure.\r\n    const oldTimeline = this.timeline;\r\n    if (oldTimeline == newTimeline)\r\n      return;\r\n\r\n    // 3. Let previous play state be animation’s play state.\r\n    const previousPlayState = this.playState;\r\n\r\n    // 4. Let previous current time be the animation’s current time.\r\n    const previousCurrentTime = this.currentTime;\r\n\r\n    // 5. Let from finite timeline be true if old timeline is not null and not\r\n    //    monotonically increasing.\r\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\r\n\r\n    // 6. Let to finite timeline be true if timeline is not null and not\r\n    //    monotonically increasing.\r\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\r\n\r\n    // 7. Let the timeline of animation be new timeline.\r\n    // Cannot assume that the native implementation has mutable timeline\r\n    // support. Deferring this step until we know that we are either\r\n    // polyfilling, supporting natively, or throwing an error.\r\n\r\n    // 8. Set the flag reset current time on resume to false.\r\n    const details = proxyAnimations.get(this);\r\n    details.resetCurrentTimeOnResume = false;\r\n\r\n    // Additional step required to track whether the animation was pending in\r\n    // order to set up a new ready promise if needed.\r\n    const pending = this.pending;\r\n\r\n    if (fromScrollTimeline) {\r\n      removeAnimation(details.timeline, details.animation);\r\n    }\r\n\r\n    // 9. Perform the steps corresponding to the first matching condition from\r\n    //    the following, if any:\r\n\r\n    // If to finite timeline,\r\n    if (toScrollTimeline) {\r\n      // Deferred step 7.\r\n      details.timeline = newTimeline;\r\n\r\n      // 1. Apply any pending playback rate on animation\r\n      applyPendingPlaybackRate(details);\r\n\r\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\r\n      //    associated effect end otherwise.\r\n      const seekTime =\r\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\r\n\r\n      // 3.  Update the animation based on the first matching condition if any:\r\n      switch (previousPlayState) {\r\n        //   If either of the following conditions are true:\r\n        //     * previous play state is running or,\r\n        //     * previous play state is finished\r\n        //   Set animation’s start time to seek time.\r\n        case 'running':\r\n        case 'finished':\r\n          details.startTime = seekTime;\r\n          // Additional polyfill step needed to associate the animation with\r\n          // the scroll timeline.\r\n          addAnimation(details.timeline, details.animation,\r\n                       tickAnimation.bind(this));\r\n          break;\r\n\r\n        //   If previous play state is paused:\r\n        //     If previous current time is resolved:\r\n        //       * Set the flag reset current time on resume to true.\r\n        //       * Set start time to unresolved.\r\n        //       * Set hold time to previous current time.\r\n        case 'paused':\r\n          details.resetCurrentTimeOnResume = true;\r\n          details.startTime = null;\r\n          details.holdTime = previousCurrentTime;\r\n          break;\r\n\r\n        // Oterwise\r\n        default:\r\n          details.holdTime = null;\r\n          details.startTime = null;\r\n      }\r\n\r\n      // Additional steps required if the animation is pending as we need to\r\n      // associate the pending promise with proxy animation.\r\n      // Note: if the native promise already has an associated \"then\", we will\r\n      // lose this association.\r\n      if (pending) {\r\n        if (!details.readyPromise ||\r\n            details.readyPromise.state == 'resolved') {\r\n          createReadyPromise(details);\r\n        }\r\n        if (previousPlayState == 'paused')\r\n          details.pendingTask = 'pause';\r\n        else\r\n          details.pendingTask = 'play';\r\n      }\r\n\r\n      // Note that the following steps should apply when transitioning to\r\n      // a monotonic timeline as well; however, we do not have a direct means\r\n      // of applying the steps to the native animation.\r\n\r\n      // 10. If the start time of animation is resolved, make animation’s hold\r\n      //     time unresolved. This step ensures that the finished play state of\r\n      //     animation is not “sticky” but is re-evaluated based on its updated\r\n      //     current time.\r\n      if (details.startTime !== null)\r\n        details.holdTime = null;\r\n\r\n      // 11. Run the procedure to update an animation’s finished state for\r\n      //     animation with the did seek flag set to false, and the\r\n      //     synchronously  notify flag set to false.\r\n      updateFinishedState(details, false, false);\r\n      return;\r\n    }\r\n\r\n    // To monotonic timeline.\r\n    if (details.animation.timeline == newTimeline) {\r\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\r\n      // re-associate the proxy with the native animation.\r\n      removeAnimation(details.timeline, details.animation);\r\n      details.timeline = null;\r\n\r\n      // If from finite timeline and previous current time is resolved,\r\n      //   Run the procedure to set the current time to previous current time.\r\n      if (fromScrollTimeline) {\r\n        if (previousCurrentTime !== null)\r\n          details.animation.currentTime = previousCurrentTime;\r\n\r\n        switch (previousPlayState) {\r\n          case 'paused':\r\n            details.animation.pause();\r\n            break;\r\n\r\n          case 'running':\r\n          case 'finished':\r\n            details.animation.play();\r\n        }\r\n      }\r\n    } else {\r\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\r\n    }\r\n  }\r\n\r\n  get startTime() {\r\n    const details = proxyAnimations.get(this);\r\n    if (details.timeline)\r\n      return details.startTime;\r\n\r\n    return details.animation.startTime;\r\n  }\r\n  set startTime(value) {\r\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline) {\r\n      details.animation.startTime = value;\r\n      return;\r\n    }\r\n\r\n    // 1. Let timeline time be the current time value of the timeline that\r\n    //    animation is associated with. If there is no timeline associated with\r\n    //    animation or the associated timeline is inactive, let the timeline\r\n    //    time be unresolved.\r\n    const timelineTime = details.timeline.currentTime;\r\n\r\n    // 2. If timeline time is unresolved and new start time is resolved, make\r\n    //    animation’s hold time unresolved.\r\n    if (timelineTime == null && details.startTime != null) {\r\n      details.holdTime = null;\r\n      // Clearing the hold time may have altered the value of current time.\r\n      // Ensure that the underlying animations has the correct value.\r\n      syncCurrentTime(details);\r\n    }\r\n\r\n    // 3. Let previous current time be animation’s current time.\r\n    // Note: This is the current time after applying the changes from the\r\n    // previous step which may cause the current time to become unresolved.\r\n    const previousCurrentTime = this.currentTime;\r\n\r\n    // 4. Apply any pending playback rate on animation.\r\n    applyPendingPlaybackRate(details);\r\n\r\n    // 5. Set animation’s start time to new start time.\r\n    details.startTime = value;\r\n\r\n    // 6. Set the reset current time on resume flag to false.\r\n    details.resetCurrentTimeOnResume = false;\r\n\r\n    // 7. Update animation’s hold time based on the first matching condition\r\n    //    from the following,\r\n\r\n    //    If new start time is resolved,\r\n    //    If animation’s playback rate is not zero,\r\n    //       make animation’s hold time unresolved.\r\n\r\n    //    Otherwise (new start time is unresolved),\r\n    //        Set animation’s hold time to previous current time even if\r\n    //        previous current time is unresolved.\r\n\r\n    if (details.startTime !== null && details.animation.playbackRate != 0)\r\n      details.holdTime = null;\r\n    else\r\n      details.holdTime = previousCurrentTime;\r\n\r\n    // 7. If animation has a pending play task or a pending pause task, cancel\r\n    //    that task and resolve animation’s current ready promise with\r\n    //    animation.\r\n    if (details.pendingTask) {\r\n      details.pendingTask = null;\r\n      details.readyPromise.resolve(this);\r\n    }\r\n\r\n   // 8. Run the procedure to update an animation’s finished state for animation\r\n   //    with the did seek flag set to true, and the synchronously notify flag\r\n   //    set to false.\r\n   updateFinishedState(details, true, false);\r\n\r\n    // Ensure that currentTime is updated for the native animation.\r\n    syncCurrentTime(details);\r\n  }\r\n\r\n  get currentTime() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline)\r\n      return details.animation.currentTime;\r\n\r\n    if (details.holdTime != null)\r\n      return details.holdTime;\r\n\r\n    return calculateCurrentTime(details);\r\n  }\r\n  set currentTime(value) {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline || value == null) {\r\n      details.animation.currentTime = value;\r\n      return;\r\n    }\r\n\r\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\r\n    const previouStartTime = details.startTime;\r\n    const previousHoldTime = details.holdTime;\r\n    const timelinePhase = details.timeline.phase;\r\n\r\n    // Update either the hold time or the start time.\r\n    if (details.holdTime !== null || details.startTime === null ||\r\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\r\n      // TODO: Support hold phase.\r\n      details.holdTime = value;\r\n    } else {\r\n      details.startTime = calculateStartTime(details, value);\r\n    }\r\n    details.resetCurrentTimeOnResume = false;\r\n\r\n    // Preserve invariant that we can only set a start time or a hold time in\r\n    // the absence of an active timeline.\r\n    if (timelinePhase == 'inactive')\r\n      details.startTime = null;\r\n\r\n    // Reset the previous current time.\r\n    details.previousCurrentTime = null;\r\n\r\n    // Synchronously resolve pending pause task.\r\n    if (details.pendingTask == 'pause') {\r\n      details.holdTime = value;\r\n      applyPendingPlaybackRate(details);\r\n      details.startTime = null;\r\n      details.pendingTask = null;\r\n      details.readyPromise.resolve(this);\r\n    }\r\n\r\n    // Update the finished state.\r\n    updateFinishedState(details, true, false);\r\n  }\r\n\r\n  get playbackRate() {\r\n    return proxyAnimations.get(this).animation.playbackRate;\r\n  }\r\n  set playbackRate(value) {\r\n    const details = proxyAnimations.get(this);\r\n\r\n    if (!details.timeline) {\r\n      details.animation.playbackRate = value;\r\n      return;\r\n    }\r\n\r\n    // 1. Clear any pending playback rate on animation.\r\n    details.pendingPlaybackRate = null;\r\n\r\n    // 2. Let previous time be the value of the current time of animation before\r\n    //    changing the playback rate.\r\n    const previousCurrentTime = this.currentTime;\r\n\r\n    // 3. Set the playback rate to new playback rate.\r\n    details.animation.playbackRate = value;\r\n\r\n    // 4. If previous time is resolved, set the current time of animation to\r\n    //    previous time\r\n   if (previousCurrentTime !== null)\r\n      this.currentTime = previousCurrentTime;\r\n  }\r\n\r\n  get playState() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline)\r\n      return details.animation.playState;\r\n\r\n    const currentTime = this.currentTime;\r\n\r\n    // 1. All of the following conditions are true:\r\n    //    * The current time of animation is unresolved, and\r\n    //    * the start time of animation is unresolved, and\r\n    //    * animation does not have either a pending play task or a pending pause\r\n    //      task,\r\n    //    then idle.\r\n    if (currentTime === null && details.startTime === null &&\r\n        details.pendingTask == null)\r\n      return 'idle';\r\n\r\n    // 2. Either of the following conditions are true:\r\n    //    * animation has a pending pause task, or\r\n    //    * both the start time of animation is unresolved and it does not have a\r\n    //      pending play task,\r\n    //    then paused.\r\n    if (details.pendingTask == 'pause' ||\r\n        (details.startTime === null && details.pendingTask != 'play'))\r\n      return 'paused';\r\n\r\n    // 3.  For animation, current time is resolved and either of the following\r\n    //     conditions are true:\r\n    //     * animation’s effective playback rate > 0 and current time >= target\r\n    //       effect end; or\r\n    //     * animation’s effective playback rate < 0 and current time <= 0,\r\n    //    then finished.\r\n    if (currentTime != null) {\r\n      if (details.animation.playbackRate > 0 &&\r\n          currentTime >= effectEnd(details))\r\n        return 'finished';\r\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\r\n        return 'finished';\r\n    }\r\n\r\n    // 4.  Otherwise\r\n    return 'running';\r\n  }\r\n  get replaceState() {\r\n    // TODO: Fix me. Replace state is not a boolean.\r\n    return proxyAnimations.get(this).animation.pending;\r\n  }\r\n\r\n  get pending() {\r\n    const details = proxyAnimations.get(this);\r\n    if (details.timeline) {\r\n      return !!details.readyPromise &&\r\n             details.readyPromise.state == 'pending';\r\n    }\r\n\r\n    return details.animation.pending;\r\n  }\r\n\r\n  finish() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline) {\r\n      details.animation.finish();\r\n      return;\r\n    }\r\n\r\n    // 1. If animation’s effective playback rate is zero, or if animation’s\r\n    //    effective playback rate > 0 and target effect end is infinity, throw\r\n    //    an InvalidStateError and abort these steps.\r\n    const playbackRate = effectivePlaybackRate(details);\r\n    const duration = effectEnd(details);\r\n    if (playbackRate == 0) {\r\n      throw new DOMException(\r\n          \"Cannot finish Animation with a playbackRate of 0.\",\r\n          \"InvalidStateError\");\r\n    }\r\n    if (playbackRate > 0 && duration == Infinity) {\r\n      throw new DOMException(\r\n          \"Cannot finish Animation with an infinite target effect end.\",\r\n          \"InvalidStateError\");\r\n    }\r\n\r\n    // 2. Apply any pending playback rate to animation.\r\n    applyPendingPlaybackRate(details);\r\n\r\n    // 3. Set limit as follows:\r\n    //       If playback rate > 0,\r\n    //          Let limit be target effect end.\r\n    //       Otherwise,\r\n    //          Let limit be zero.\r\n    const limit = playbackRate < 0 ? 0 : duration;\r\n\r\n    // 4. Silently set the current time to limit.\r\n    this.currentTime = limit;\r\n\r\n    // 5. If animation’s start time is unresolved and animation has an\r\n    //    associated active timeline, let the start time be the result of\r\n    //    evaluating\r\n    //        timeline time - (limit / playback rate)\r\n    //    where timeline time is the current time value of the associated\r\n    //    timeline.\r\n    const timelineTime = details.timeline.currentTime;\r\n\r\n    if (details.startTime === null && timelineTime !== null) {\r\n       details.startTime =\r\n           timelineTime - (limit / details.animation.playbackRate);\r\n    }\r\n\r\n    // 6. If there is a pending pause task and start time is resolved,\r\n    //    6.1 Let the hold time be unresolved.\r\n    //    6.2 Cancel the pending pause task.\r\n    //    6.3 Resolve the current ready promise of animation with animation.\r\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\r\n      details.holdTime = null;\r\n      details.pendingTask = null;\r\n      details.readyPromise.resolve(this);\r\n    }\r\n\r\n    // 7. If there is a pending play task and start time is resolved, cancel\r\n    //    that task and resolve the current ready promise of animation with\r\n    //    animation.\r\n    if (details.pendingTask == 'play' && details.startTime !== null) {\r\n      details.pendingTask = null;\r\n      details.readyPromise.resolve(this);\r\n    }\r\n\r\n    // 8. Run the procedure to update an animation’s finished state for\r\n    //    animation with the did seek flag set to true, and the synchronously\r\n    //    notify flag set to true.\r\n    updateFinishedState(details, true, true);\r\n  }\r\n\r\n  play() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline) {\r\n      details.animation.play();\r\n      return;\r\n    }\r\n\r\n    playInternal(details, /* autoRewind */ true);\r\n  }\r\n\r\n  pause() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline) {\r\n      details.animation.pause();\r\n      return;\r\n    }\r\n\r\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\r\n\r\n    // 1. If animation has a pending pause task, abort these steps.\r\n    // 2. If the play state of animation is paused, abort these steps.\r\n    if (this.playState == \"paused\")\r\n      return;\r\n\r\n    // 3. Let seek time be a time value that is initially unresolved.\r\n    // 4. Let has finite timeline be true if animation has an associated\r\n    //    timeline that is not monotonically increasing.\r\n    //    Note: always true if we have reached this point in the polyfill.\r\n    //    Pruning following steps to be specific to scroll timelines.\r\n    let seekTime = null;\r\n\r\n    // 5.  If the animation’s current time is unresolved, perform the steps\r\n    //     according to the first matching condition from below:\r\n    // 5a. If animation’s playback rate is ≥ 0,\r\n    //       Set seek time to zero.\r\n    // 5b. Otherwise,\r\n    //         If associated effect end for animation is positive infinity,\r\n    //             throw an \"InvalidStateError\" DOMException and abort these\r\n    //             steps.\r\n    //         Otherwise,\r\n    //             Set seek time to animation's associated effect end.\r\n\r\n    const playbackRate = details.animation.playbackRate;\r\n    const duration = effectEnd(details);\r\n\r\n    if (details.animation.currentTime === null) {\r\n      if (playbackRate >= 0) {\r\n        seekTime = 0;\r\n      } else if (duration == Infinity) {\r\n        // Let native implementation take care of throwing the exception.\r\n        details.animation.pause();\r\n        return;\r\n      } else {\r\n        seekTime = duration;\r\n      }\r\n    }\r\n\r\n    // 6. If seek time is resolved,\r\n    //        If has finite timeline is true,\r\n    //            Set animation's start time to seek time.\r\n    if (seekTime !== null)\r\n      details.startTime = seekTime;\r\n\r\n    // 7. Let has pending ready promise be a boolean flag that is initially\r\n    //    false.\r\n    // 8. If animation has a pending play task, cancel that task and let has\r\n    //    pending ready promise be true.\r\n    // 9. If has pending ready promise is false, set animation’s current ready\r\n    //    promise to a new promise in the relevant Realm of animation.\r\n    if (details.pendingTask == 'play')\r\n      details.pendingTask = null;\r\n    else\r\n      details.readyPromise = null;\r\n\r\n    // 10. Schedule a task to be executed at the first possible moment after the\r\n    //     user agent has performed any processing necessary to suspend the\r\n    //     playback of animation’s target effect, if any.\r\n    if (!details.readyPromise)\r\n      createReadyPromise(details);\r\n    details.pendingTask ='pause';\r\n  }\r\n\r\n  reverse() {\r\n    const details = proxyAnimations.get(this);\r\n    const playbackRate = effectivePlaybackRate(details);\r\n    const previousCurrentTime =\r\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\r\n    const inifiniteDuration = effectEnd(details) == Infinity;\r\n\r\n    // Let the native implementation handle throwing the exception in cases\r\n    // where reversal is not possible. Error cases will not change the state\r\n    // of the native animation.\r\n    const reversable =\r\n       (playbackRate != 0) &&\r\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\r\n    if (!details.timeline || !reversable) {\r\n      if (reversable)\r\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\r\n      details.animation.reverse();\r\n      return;\r\n    }\r\n\r\n    if (details.timeline.phase == 'inactive') {\r\n      throw new DOMException(\r\n          \"Cannot reverse an animation with no active timeline\",\r\n          \"InvalidStateError\");\r\n    }\r\n\r\n    this.updatePlaybackRate(-playbackRate);\r\n    playInternal(details, /* autoRewind */ true);\r\n  }\r\n\r\n  updatePlaybackRate(rate) {\r\n    const details = proxyAnimations.get(this);\r\n    details.pendingPlaybackRate = rate;\r\n    if (!details.timeline) {\r\n      details.animation.updatePlaybackRate(rate);\r\n      return;\r\n    }\r\n\r\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\r\n\r\n    // 1. Let previous play state be animation’s play state.\r\n    // 2. Let animation’s pending playback rate be new playback rate.\r\n    // Step 2 already performed as we need to record it even when using a\r\n    // monotonic timeline.\r\n    const previousPlayState = this.playState;\r\n\r\n    // 3. Perform the steps corresponding to the first matching condition from\r\n    //    below:\r\n    //\r\n    // 3a If animation has a pending play task or a pending pause task,\r\n    //    Abort these steps.\r\n    if (details.readyPromise && details.readyPromise.state == 'pending')\r\n      return;\r\n\r\n    switch(previousPlayState) {\r\n      // 3b If previous play state is idle or paused,\r\n      //    Apply any pending playback rate on animation.\r\n      case 'idle':\r\n      case 'paused':\r\n        applyPendingPlaybackRate(details);\r\n        break;\r\n\r\n      // 3c If previous play state is finished,\r\n      //    3c.1 Let the unconstrained current time be the result of calculating\r\n      //         the current time of animation substituting an unresolved time\r\n      //          value for the hold time.\r\n      //    3c.2 Let animation’s start time be the result of evaluating the\r\n      //         following expression:\r\n      //    timeline time - (unconstrained current time / pending playback rate)\r\n      // Where timeline time is the current time value of the timeline\r\n      // associated with animation.\r\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\r\n      //         timeline time.\r\n      //    3c.4 Apply any pending playback rate on animation.\r\n      //    3c.5 Run the procedure to update an animation’s finished state for\r\n      //         animation with the did seek flag set to false, and the\r\n      //         synchronously notify flag set to false.\r\n\r\n      case 'finished':\r\n        const timelineTime = details.timeline.currentTime;\r\n        const unconstrainedCurrentTime = timelineTime !== null ?\r\n            (timelineTime - details.startTime) * details.animation.playbackRate\r\n            : null;\r\n        if (rate == 0) {\r\n          details.startTime = timelineTime;\r\n        } else {\r\n          details.startTime =\r\n              timelineTime != null && unconstrainedCurrentTime != null ?\r\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\r\n        }\r\n        applyPendingPlaybackRate(details);\r\n        updateFinishedState(details, false, false);\r\n        syncCurrentTime(details);\r\n        break;\r\n\r\n      // 3d Otherwise,\r\n      // Run the procedure to play an animation for animation with the\r\n      // auto-rewind flag set to false.\r\n      default:\r\n        playInternal(details, false);\r\n    }\r\n  }\r\n\r\n  persist() {\r\n    proxyAnimations.get(this).animation.persist();\r\n  }\r\n\r\n  get id() {\r\n    return proxyAnimations.get(this).animation.id;\r\n  }\r\n\r\n  cancel() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline) {\r\n      details.animation.cancel();\r\n      return;\r\n    }\r\n\r\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\r\n    // 1. If animation’s play state is not idle, perform the following steps:\r\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\r\n    //         animation.\r\n    //    1.2 Reject the current finished promise with a DOMException named\r\n    //        \"AbortError\"\r\n    //    1.3 Let current finished promise be a new (pending) Promise object.\r\n    //    1.4+ Deferred to native implementation.\r\n    //         TODO: polyfill since timelineTime will be incorrect for the\r\n    //               cancel event. Also, should avoid sending a cancel event if\r\n    //               the native animation is canceled due to the scroll timeline\r\n    //               becoming inactive. This can likely be done by associating\r\n    //               the cancel event with the proxy and not the underlying\r\n    //               animation.\r\n    if (this.playState != 'idle') {\r\n      resetPendingTasks(details);\r\n      if (details.finishedPromise &&\r\n          details.finishedPromise.state == 'pending') {\r\n        details.finishedPromise.reject(createAbortError());\r\n      }\r\n      details.finishedPromise = new PromiseWrapper();\r\n      details.animation.cancel();\r\n    }\r\n\r\n    // 2. Make animation’s hold time unresolved.\r\n    // 3. Make animation’s start time unresolved.\r\n    details.startTime = null;\r\n    details.holdTime = null;\r\n\r\n    // Extra step in the polyfill the ensure the animation stops ticking.\r\n    removeAnimation(details.timeline, details.animation);\r\n  }\r\n\r\n  get onfinish() {\r\n    return proxyAnimations.get(this).animation.onfinish;\r\n  }\r\n  set onfinish(value) {\r\n    proxyAnimations.get(this).animation.onfinish = value;\r\n  }\r\n  get oncancel() {\r\n    return proxyAnimations.get(this).animation.oncancel;\r\n  }\r\n  set oncancel(value) {\r\n    proxyAnimations.get(this).animation.oncancel = value;\r\n  }\r\n  get onremove() {\r\n    return proxyAnimations.get(this).animation.onremove;\r\n  }\r\n  set onremove(value) {\r\n    proxyAnimations.get(this).animation.onremove = value;\r\n  }\r\n\r\n  get finished() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline)\r\n       return details.animation.finished;\r\n\r\n    if (!details.finishedPromise) {\r\n      details.finishedPromise = new PromiseWrapper();\r\n    }\r\n    return details.finishedPromise.promise;\r\n  }\r\n\r\n  get ready() {\r\n    const details = proxyAnimations.get(this);\r\n    if (!details.timeline)\r\n      return details.animation.ready;\r\n\r\n    if (!details.readyPromise) {\r\n      details.readyPromise = new PromiseWrapper();\r\n      details.readyPromise.resolve(this);\r\n    }\r\n    return details.readyPromise.promise;\r\n  }\r\n\r\n  // --------------------------------------------------\r\n  // Event target API\r\n  // --------------------------------------------------\r\n\r\n  addEventListener(type, callback, options) {\r\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\r\n                                                         options);\r\n  }\r\n\r\n  removeEventListener(type, callback, options) {\r\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\r\n                                                            options);\r\n  }\r\n\r\n  dispatchEvent(event) {\r\n    proxyAnimations.get(this).animation.dispatchEvent(event);\r\n  }\r\n};\r\n\r\nexport function animate(keyframes, options) {\r\n  const timeline = options.timeline;\r\n\r\n  if (timeline instanceof ScrollTimeline)\r\n    delete options.timeline;\r\n\r\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\r\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\r\n\r\n  if (timeline instanceof ScrollTimeline) {\r\n    animation.pause();\r\n    proxyAnimation.play();\r\n  }\r\n\r\n  return proxyAnimation;\r\n};\r\n","// Copyright 2019 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     https://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\nimport { parseLength } from \"./utils\";\r\n\r\nlet IntersectionOptions = new WeakMap();\r\n\r\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\r\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\r\n// various length inputs to their components.\r\nconst TOP = 0;\r\nconst RIGHT = 1;\r\nconst BOTTOM = 2;\r\nconst LEFT = 3;\r\nconst MARGIN_MAP = [\r\n  // 1 length maps to all positions.\r\n  [[TOP, RIGHT, BOTTOM, LEFT]],\r\n  // 2 lengths maps to vertical and horizontal margins.\r\n  [\r\n    [TOP, BOTTOM],\r\n    [RIGHT, LEFT],\r\n  ],\r\n  // 3 lengths maps to top, horizontal, bottom margins.\r\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\r\n  // 4 lengths maps to each component.\r\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\r\n];\r\n\r\nclass IntersectionBasedOffset {\r\n  constructor(value) {\r\n    IntersectionOptions.set(this, {\r\n      target: null,\r\n      edge: \"start\",\r\n      threshold: 0,\r\n      rootMargin: [\r\n        [0, \"px\"],\r\n        [0, \"px\"],\r\n        [0, \"px\"],\r\n        [0, \"px\"],\r\n      ],\r\n    });\r\n    this.target = value.target;\r\n    this.edge = value.edge || \"start\";\r\n    this.threshold = value.threshold || 0;\r\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\r\n    this.clamp = value.clamp || false;\r\n  }\r\n\r\n  set target(element) {\r\n    if (!(element instanceof Element)) {\r\n      IntersectionOptions.get(this).target = null;\r\n      throw Error(\"Intersection target must be an element.\");\r\n    }\r\n    IntersectionOptions.get(this).target = element;\r\n  }\r\n\r\n  get target() {\r\n    return IntersectionOptions.get(this).target;\r\n  }\r\n\r\n  set edge(value) {\r\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\r\n    IntersectionOptions.get(this).edge = value;\r\n  }\r\n\r\n  get edge() {\r\n    return IntersectionOptions.get(this).edge;\r\n  }\r\n\r\n  set threshold(value) {\r\n    let threshold = parseFloat(value);\r\n    // Throw a TypeError for a parse error.\r\n    if (threshold != threshold)\r\n      throw TypeError(\"Invalid threshold.\");\r\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\r\n    // consistent with the intersection observer spec but the current\r\n    // test expectations are looking for a TypeError.\r\n    if (threshold < 0 || threshold > 1)\r\n      throw TypeError(\"threshold must be in the range [0, 1]\");\r\n    IntersectionOptions.get(this).threshold = threshold;\r\n  }\r\n\r\n  get threshold() {\r\n    return IntersectionOptions.get(this).threshold;\r\n  }\r\n\r\n  set rootMargin(value) {\r\n    let margins = value.split(/ +/);\r\n    if (margins.length < 1 || margins.length > 4)\r\n      throw TypeError(\r\n        \"rootMargin must contain between 1 and 4 length components\"\r\n      );\r\n    let parsedMargins = [[], [], [], []];\r\n    for (let i = 0; i < margins.length; i++) {\r\n      let parsedValue = parseLength(margins[i], true);\r\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\r\n      let positions = MARGIN_MAP[margins.length - 1][i];\r\n      for (let j = 0; j < positions.length; j++) {\r\n        parsedMargins[positions[j]] = [\r\n          parseFloat(parsedValue.value),\r\n          parsedValue.unit,\r\n        ];\r\n      }\r\n    }\r\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\r\n  }\r\n\r\n  get rootMargin() {\r\n    // TODO: Simplify to the shortest matching specification for the given margins.\r\n    return IntersectionOptions.get(this)\r\n      .rootMargin.map((margin) => {\r\n        return margin.join(\"\");\r\n      })\r\n      .join(\" \");\r\n  }\r\n\r\n  set clamp(value) {\r\n    // This is just for testing alternative proposals - not intended to be part\r\n    // of the specification.\r\n    IntersectionOptions.get(this).clamp = !!value;\r\n  }\r\n}\r\n\r\nexport function parseOffset(value) {\r\n  if (value.target) return new IntersectionBasedOffset(value);\r\n}\r\n\r\nfunction resolveLength(length, containerSize) {\r\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\r\n  // Assumption is only px or % will be passed in.\r\n  // TODO: Support other length types (e.g. em, vh, etc).\r\n  return length[0];\r\n}\r\n\r\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\r\n  // TODO: Support other writing directions.\r\n  if (orientation == \"block\") orientation = \"vertical\";\r\n  else if (orientation == \"inline\") orientation = \"horizontal\";\r\n  let originalViewport =\r\n    scrollSource == document.scrollingElement\r\n      ? {\r\n          left: 0,\r\n          right: scrollSource.clientWidth,\r\n          top: 0,\r\n          bottom: scrollSource.clientHeight,\r\n          width: scrollSource.clientWidth,\r\n          height: scrollSource.clientHeight,\r\n        }\r\n      : scrollSource.getBoundingClientRect();\r\n\r\n  // Resolve margins and offset viewport.\r\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\r\n  let computedMargins = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    computedMargins.push(\r\n      resolveLength(\r\n        parsedMargins[i],\r\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\r\n      )\r\n    );\r\n  }\r\n  let viewport = {\r\n    left: originalViewport.left - computedMargins[LEFT],\r\n    right: originalViewport.right + computedMargins[RIGHT],\r\n    width:\r\n      originalViewport.right -\r\n      originalViewport.left +\r\n      computedMargins[LEFT] +\r\n      computedMargins[RIGHT],\r\n    top: originalViewport.top - computedMargins[TOP],\r\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\r\n    height:\r\n      originalViewport.bottom -\r\n      originalViewport.top +\r\n      computedMargins[TOP] +\r\n      computedMargins[BOTTOM],\r\n  };\r\n\r\n  let clamped = IntersectionOptions.get(offset).clamp;\r\n  let target = offset.target.getBoundingClientRect();\r\n  let threshold = offset.threshold;\r\n  // Invert threshold for start position.\r\n  if (offset.edge == \"start\") threshold = 1 - threshold;\r\n  // Projected point into the scroller scroll range.\r\n  if (orientation == \"vertical\") {\r\n    let point =\r\n      target.top +\r\n      target.height * threshold -\r\n      viewport.top +\r\n      scrollSource.scrollTop;\r\n    if (clamped) {\r\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\r\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\r\n    } else {\r\n      if (offset.edge == \"end\") return point - viewport.height;\r\n      return point;\r\n    }\r\n  } else {\r\n    // orientation == 'horizontal'\r\n    let point =\r\n      target.left +\r\n      target.width * threshold -\r\n      viewport.left +\r\n      scrollSource.scrollLeft;\r\n    if (clamped) {\r\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\r\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\r\n    } else {\r\n      if (offset.edge == \"end\") return point - viewport.width;\r\n      return point;\r\n    }\r\n  }\r\n}\r\n","// Copyright 2019 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     https://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\nimport {\r\n  ScrollTimeline,\r\n  installScrollOffsetExtension\r\n} from \"./scroll-timeline-base\";\r\nimport {\r\n  animate,\r\n  ProxyAnimation\r\n} from \"./proxy-animation.js\";\r\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\r\n\r\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\r\n\r\nif (\r\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\r\n) {\r\n  throw Error(\r\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\r\n  );\r\n}\r\n\r\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\r\n  throw Error(\r\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\r\n  );\r\n}\r\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\r\n  throw Error(\"Error installing Animation constructor.\");\r\n}\r\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","calculateScrollOffset","autoValue","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","resolveScrollOffsets","scrollOffsets","fns","effectiveScrollOffsets","firstOffset","push","effectiveOffset","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","set","this","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","input","result","parse","evaluate","parsed","data","range","Number","isFinite","scrollerStyle","display","overflow","maxOffset","startOffset","endOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","offsetIndex","ComputeProgress","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","details","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}