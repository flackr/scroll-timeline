{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set startScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid start offset.\");\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    if (offset == \"auto\")\n      offset = AUTO;\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    if (offset != AUTO && !scrollTimelineOptions.get(this).startScrollOffsetFunction) {\n      let parsed = parseLength(offset);\n      // TODO: This should check CSSMathSum values as well.\n      if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n        throw TypeError(\"Invalid end offset.\");\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n    //   if source's layout box is not a scroll container\"\n    if (scrollerStyle.overflow == \"visible\" || scrollerStyle.overflow == \"clip\")\n      return \"inactive\";\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    //   if source's effective scroll range is null\n    if (startOffset === null || endOffset === null)\n      return \"inactive\";\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let startOffset = calculateScrollOffset(\n      new CSSUnitValue(0, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\n\n/**\n * Creates a ready promise with a pending task, to be executed at the time\n * the promise is resolved. The promise will auto-resolve in the next animation\n * frame, but may be resolved or rejected earlier as a result of API calls that\n * change the state of the animation. The state of the promise\n * (pending|resolved|rejected) may be queried to determine when a replacement\n * promise is needed.\n * @param details {Ojbect}\n * @param task {function}\n */\nfunction createReadyPromise(details, task) {\n  let nativeResolve = undefined;\n  let nativeReject = undefined;\n  let pendingTask = task;\n  let state = 'pending';\n  const p = new Promise((resolve, reject) => {\n    nativeResolve = resolve;\n    nativeReject = reject;\n  });\n\n  p.resolve = () => {\n    state = 'resolved';\n    pendingTask = null;\n    nativeResolve(details.proxy);\n  }\n  p.reject = () => {\n    state = 'rejected';\n    pendingTask = null;\n    nativeReject(details.proxy);\n  }\n  p.cancelTask = () => {\n    pendingTask = null;\n  }\n  p.queueTask = (task) => {\n    pendingTask = task;\n  }\n  p.state = () => {\n    return state;\n  }\n\n  const runOrRequeueTask = () => {\n    if (!pendingTask)\n      return;\n\n    if (details.timeline.currentTime !== null) {\n      pendingTask();\n      pendingTask = null;\n      return;\n    }\n    requestAnimationFrame(runOrRequeueTask);\n  }\n\n  // Run the pending task in the next animation frame. The task is responsible\n  // for resolving the promise. The pending task will not run while the timeline\n  // is inactive.\n  requestAnimationFrame(runOrRequeueTask);\n\n  details.readyPromise = p;\n  return p;\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction updateFinishedState(details) {\n  if (!details.timeline)\n    return;\n\n  // No change in play state if idle or paused.\n  if (details.playState != 'running' && details.playState != 'finished')\n    return;\n\n  const isFinished = () => {\n    const playbackRate = effectivePlaybackRate(details);\n    const currentTime = details.animation.currentTime;\n    if (playbackRate < 0 && currentTime <= 0)\n      return true;\n    if (playbackRate > 0 &&\n        currentTime >= details.animation.effect.getTiming().duration)\n      return true;\n\n    return false;\n  };\n\n  const newPlayState = isFinished() ? 'finished' : 'running';\n  if (newPlayState == details.playSAtate)\n    return;\n\n  details.playState = newPlayState;\n  if (newPlayState == 'finished') {\n    requestAnimationFrame(() => {\n      // Finished state may have been temporary. Ensure that we are still in the\n      // 'finished' state.\n      if (details.playState == 'finished') {\n        // Resolve the finished promise and queue the onfinished event.\n        // Finish snaps to the boundary. Restore current time after the finish\n        // call.\n        const previousCurrentTime = details.aniamtion.currentTime;\n        details.animation.finish();\n        details.animation.pause();\n        details.animation.currentTime = previousCurrentTime;\n      }\n    });\n  }\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.readyPromise || !details.readyPromise.state() == 'pending')\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.readyPromise.cancelTask();\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject();\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  details.readyPromise = null;\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (this.playState == 'running') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n    updateFinishedState(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      proxy: this,\n      sequence: 0, /* Used to track ready promises. */\n      aborted: new Set(), /* Aborted sequences. */\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    const details = proxyAnimations.get(this);\n\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n    const previousCurrentTime = this.currentTime;\n    const previousPlayState = this.playState;\n    const playbackRate = effectivePlaybackRate(details);\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    details.resetCurrentTimeOnResume = false;\n    if (toScrollTimeline) {\n      details.timeline = newTimeline;\n      applyPendingPlaybackRate(details);\n      details.animation.pause();\n      switch(previousPlayState) {\n        case 'idle':\n          details.playState = 'idle';\n          details.holdTime = null;\n          details.startTime = null;\n          break;\n\n        case 'paused':\n          details.playState = 'paused';\n          details.resetCurrentTimeOnResume = true;\n          details.animation.currentTime = previousCurrentTime;\n          removeAnimation(details.timeline, details.animation);\n          break;\n\n        case 'running':\n        case 'finished':\n          details.playState = previousPlayState;\n          details.startTime =\n              playbackRate < 0 ? details.animation.effect.getTiming().duration\n                               : 0;\n          details.holdTime =\n              previousPlayState == 'finished' ? previousCurrentTime : null;\n          addAnimation(details.timeline, details.animation,\n              tickAnimation.bind(this));\n          break;\n      }\n      if (pending)\n        createReadyPromise(details);\n      return;\n    }\n\n    if (details.animation.timeline == newTimeline) {\n      if (fromScrollTimeline) {\n        details.timeline = null;\n        details.animation.currentTime = previousCurrentTime;\n        switch (details.playbackRate) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeilne: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // TODO: handle hold phase.\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime === null && value !== null)\n      details.holdTime = null;\n\n    const previousCurrentTime = this.currentTime;\n    applyPendingPlaybackRate(details);\n    details.startTime = value;\n    details.resetCurrentTimeOnResume = false;\n    details.readyPromise = null;\n\n    if (value === null) {\n      details.holdTime = previousCurrentTime;\n      details.playState = (previousCurrentTime === null) ? 'idle' : 'paused';\n    } else {\n      details.playState = 'running';\n      if (timelineTime !== null) {\n        details.animation.currentTime =\n            (timelineTime - value) * this.playbackRate;\n        updateFinishedState(details);\n      }\n    }\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (!details.playState || details.playState == 'idle')\n      return null;\n    if (details.playState == 'running' &&\n        details.timeline.phase == 'inactive')\n      return null;\n\n   return details.animation.currentTime;\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    details.animation.currentTime = value;\n    details.resetCurrentTimeOnResume = false;\n    if (details.timeline) {\n       // Update the start or the hold time of the proxy animation depending\n       // on the play sate.\n       const timelineTime = details.timeline.currentTime;\n       const playbackRate = this.playbackRate;\n       switch(details.playState) {\n        case 'running':\n        case 'finished':\n          // TODO: handle value == null or playbackRate == 0.\n          details.startTime = timelineTime - value / playbackRate;\n          details.holdTime = null;\n          break;\n\n        default:\n           details.playState = value ? 'paused' : 'idle';\n           details.holdTime = value;\n           details.startTime = null;\n           break;\n       }\n       updateFinishedState(details);\n    }\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n    details.animation.playbackRate = value;\n    details.pendingPlaybackRate = null;\n    updateFinishedState(details);\n  }\n\n  get playState() {\n    proxy = proxyAnimations.get(this);\n    if (proxy.timeline)\n      return proxy.playState;\n\n    return proxy.animation.playState;\n  }\n\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.readyPromise && details.readyPromise.state() == 'pending';\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = details.animation.effect.getTiming().duration;\n    if (playbackRate == 0 || (playbackRate < 0 && duration == Infinity)) {\n      // Let native implementation handle throwing the exception. This should\n      // not affect the state of the native animation.\n      details.animation.finish();\n      return;\n    }\n\n    applyPendingPlaybackRate(details);\n    const seekTime = playbackRate < 0 ? 0 : duration;\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime = seekTime;\n\n    if (hasActiveTimeline(details)) {\n      details.startTime = timelineTime - seekTime / playbackRate;\n      details.holdTime = seekTime;\n      details.playState = 'finished';\n      removeAnimation(details.timeline, details.animation);\n      if (details.readyPromise && details.readyPromise.state() == 'pending')\n        details.readyPromise.resolve();\n      // Resolve the finished promise and fire the finished event.\n      details.animation.finish();\n    } else {\n      details.startTime = null;\n      details.holdTime = seekTime;\n      details.playState = 'paused';\n    }\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n    // 1. Let aborted pause be a boolean flag that is true if animation has a\n    //    pending pause task, and false otherwise.\n    // 2. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: this value will always true at this point in the polyfill.\n    //    Following steps are pruned based on the procedure for scroll\n    //    timelines.\n    const abortedPause = details.playState == 'paused' && this.pending;\n\n    let hasPendingReadyPromise = false;\n    let seekTime = null;\n\n    // 5. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n    //\n    // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n    //    true and either animation’s:\n    //      current time is unresolved, or\n    //      current time < zero, or\n    //      current time >= target effect end,\n    //    5a1. Set seek time to zero.\n    //\n    // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n    //    true and either animation’s:\n    //      current time is unresolved, or\n    //      current time ≤ zero, or\n    //      current time > target effect end,\n    //    5b1. If associated effect end is positive infinity,\n    //         throw an \"InvalidStateError\" DOMException and abort these steps.\n    //    5b2. Otherwise,\n    //         5b2a Set seek time to animation's associated effect end.\n    //\n    // 5c If animation’s effective playback rate = 0 and animation’s current time\n    //    is unresolved,\n    //    5c1. Set seek time to zero.\n    // Note: the auto-rewind flag is always true if directly calling play.\n\n    let previousCurrentTime = details.animation.currentTime;\n\n    // Resume of a paused animation after a timeline change snaps to the scroll\n    // position.\n    if (details.resetCurrentTimeOnResume) {\n      previousCurrentTime = null;\n      details.resetCurrentTimeOnResume = false;\n    }\n\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = details.animation.effect.getTiming().duration;\n    if (playbackRate > 0 && (previousCurrentTime == null ||\n                             previousCurrentTime < 0 ||\n                             previousCurrentTime >= duration)) {\n      seekTime = 0;\n    } else if (playbackRate < 0 && (previousCurrentTime == null ||\n                                    previousCurrentTime <= 0 ||\n                                    previousCurrentTime > duration)) {\n      if (duration == Infinity) {\n        // Defer to native implementation to handle throwing the exception.\n        details.animation.play();\n        return;\n      }\n      seekTime = duration;\n    } else if (playbackRate == 0 && previousCurrentTime == null) {\n      seekTime = 0;\n    }\n\n    // 6. If seek time is resolved,\n    //        6a1. Set animation's start time to seek time.\n    //        6a2. Let animation's hold time be unresolved.\n    //        6a3. Apply any pending playback rate on animation.\n    if (seekTime != null) {\n      details.startTime = seekTime;\n      details.holdTime = null;\n      applyPendingPlaybackRate(details);\n    }\n\n    // Additional steps for the polyfill.\n    details.playState = \"running\";\n    addAnimation(details.timeline, details.animation,\n                 tickAnimation.bind(this));\n\n    // 7. If animation's hold time is resolved, let its start time be\n    //    unresolved.\n    if (details.holdTime) {\n      details.startTime = null;\n    }\n\n    // 8. If animation has a pending play task or a pending pause task,\n    //   8.1 Cancel that task.\n    //   8.2 Set has pending ready promise to true.\n    if (details.readyPromise && this.pending) {\n      details.readyPromise.cancelTask();\n      hasPendingReadyPromise = true;\n    }\n\n    // 9. If the following three conditions are all satisfied:\n    //      animation’s hold time is unresolved, and\n    //      seek time is unresolved, and\n    //      aborted pause is false, and\n    //      animation does not have a pending playback rate,\n    //    abort this procedure.\n    if (details.holdTime === null && seekTime === null &&\n        !abortedPause && details.pendingPlaybackRate === null)\n    return;\n\n    // 10. If has pending ready promise is false, let animation’s current ready\n    //    promise be a new promise in the relevant Realm of animation.\n    if (details.readyPromise && !hasPendingReadyPromise)\n      details.readyPromise = null;\n\n    // Additional polyfill step to ensure that the native animation has the\n    // correct value for current time.\n    syncCurrentTime(details);\n\n    // 11. Schedule a task to run as soon as animation is ready.\n    const commitPendingPlay = () => {\n      const timelineTime = details.timeline.currentTime;\n      if (details.holdTime != null) {\n        // A: If animation’s hold time is resolved,\n        // A.1. Apply any pending playback rate on animation.\n        // A.2. Let new start time be the result of evaluating:\n        //        ready time - hold time / playback rate for animation.\n        //      If the playback rate is zero, let new start time be simply ready\n        //      time.\n        // A.3. Set the start time of animation to new start time.\n        // A.4. If animation’s playback rate is not 0, make animation’s hold\n        //      time unresolved.\n        applyPendingPlaybackRate(details);\n        if (playbackRate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime\n              = timelineTime -\n                  details.holdTime / details.animation.playbackRate;\n          details.holdTime = null;\n        }\n      } else if (details.startTime !== null &&\n                 details.pendingPlaybackRate !== null) {\n        // B: If animation’s start time is resolved and animation has a pending\n        //    playback rate,\n        // B.1. Let current time to match be the result of evaluating:\n        //        (ready time - start time) × playback rate for animation.\n        // B.2 Apply any pending playback rate on animation.\n        // B.3 If animation’s playback rate is zero, let animation’s hold time\n        //     be current time to match.\n        // B.4 Let new start time be the result of evaluating:\n        //       ready time - current time to match / playback rate\n        //     for animation.\n        //     If the playback rate is zero, let new start time be simply ready\n        //     time.\n        // B.5 Set the start time of animation to new start time.\n        const currentTimeToMatch =\n            (timelineTime - details.startTime) * details.animation.playbackRate;\n        applyPendingPlaybackRate(details);\n        const playbackRate = details.animation.playbackRate;\n        if (playbackRate == 0) {\n          details.holdTime = null;\n          details.startTime = timelineTime;\n        } else {\n          details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n        }\n      }\n\n      // 8.4 Resolve animation’s current ready promise with animation.\n      if (details.readyPromise && details.readyPromise.state() == 'pending')\n         details.readyPromise.resolve();\n\n      // 8.5 Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously notify flag set to false.\n      updateFinishedState(details);\n\n      // Additional polyfill step to update the native animation's current time.\n      syncCurrentTime(details);\n    };\n\n    if (!details.readyPromise) {\n      createReadyPromise(details, commitPendingPlay);\n    } else {\n      details.readyPromise.queueTask(commitPendingPlay);\n    }\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (details.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = details.animation.effect.getTiming().duration;\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.playState == 'running' && details.readyPromise &&\n        details.readyPromise.state() == 'pending') {\n      details.readyPromise.cancelTask();\n    } else {\n      details.readyPromise = null;\n    }\n\n    // Extra step for the polyfill.\n    details.playState = 'paused';\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any. The task shall perform\n    //     the following steps:\n    const commitPendingPause = () => {\n      // 1. Let ready time be the time value of the timeline associated with\n      //    animation at the moment when the user agent completed processing\n      //    necessary to suspend playback of animation’s target effect.\n      const readyTime = details.timeline.currentTime;\n\n      console.log('commitPendingPause');\n      console.log('readyTime: ' + readyTime);\n      console.log('startTime: ' + details.startTime);\n      console.log('holdTime: ' + details.holdTime);\n\n      // 2. If animation’s start time is resolved and its hold time is not\n      //    resolved, let animation’s hold time be the result of evaluating\n      //    (ready time - start time) × playback rate.\n      if (details.startTime != null && details.holdTime == null) {\n        details.holdTime =\n            (readyTime - details.startTime) * details.animation.playbackRate;\n      }\n\n      // 3. Apply any pending playback rate on animation.\n      applyPendingPlaybackRate(details);\n\n      // 4. Make animation’s start time unresolved.\n      details.startTime = null;\n\n      // 5. Resolve animation’s current ready promise with animation.\n      details.readyPromise.resolve();\n\n      // 6. Run the procedure to update an animation’s finished state for\n      // animation with the did seek flag set to false, and the synchronously\n      //  notify flag set to false.\n      updateFinishedState(details);\n\n      // Additional polyfill step to update the native animation's current time.\n      syncCurrentTime(details);\n    };\n\n    if (details.readyPromise)\n      details.readyPromise.queueTask(commitPendingPause);\n    else\n      createReadyPromise(details, commitPendingPause);\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.reverse();\n      return;\n    }\n\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = details.animation.effect.getTiming().duration;\n    if (playbackRate == 0 || (playbackRate > 0 && duration == Infinity)) {\n      // Let native implementation handle throwing the exception.\n      details.animation.reverse();\n      return;\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    this.play();\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    const previousPlayState = details.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state() == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (value == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / value : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        this.play();\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    details.animation.cancel();\n\n    if (!details.timeline)\n      return;\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2+ Handled by native implementation.\n    if (details.playState == 'idle')\n      return;\n    resetPendingTasks(details);\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n    details.playState = 'idle';\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    proxyAnimations.get(this).animation.finished;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      if (!details.readyPromise) {\n        createReadyPromise(details, /* pendingTask */ null);\n        details.readyPromise.resolve(details.proxy);\n      }\n      return details.readyPromise;\n    }\n    return details.animation.ready;\n  }\n\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAniamtion.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","AUTO","CSSKeywordValue","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","timelineTime","currentTime","i","tickAnimation","calculateScrollOffset","autoValue","orientation","offset","fn","value","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolvePx","cssValue","resolvedLength","unit","TypeError","total","values","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","set","this","startScrollOffset","endScrollOffset","scrollOffsets","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","fns","input","result","parse","evaluate","parsed","data","currentStlOptions","startScrollOffsetFunction","endScrollOffsetFunction","range","Number","isFinite","scrollerStyle","getComputedStyle","display","overflow","startOffset","endOffset","maxOffset","currentScrollOffset","scrollTop","scrollLeft","phase","Math","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","nativeElementAnimate","window","Element","prototype","animate","nativeAnimation","Animation","createReadyPromise","details","task","nativeResolve","nativeReject","pendingTask","state","p","Promise","resolve","reject","proxy","cancelTask","queueTask","requestAnimationFrame","runOrRequeueTask","timeline","readyPromise","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","updateFinishedState","playState","newPlayState","getTiming","duration","playSAtate","previousCurrentTime","aniamtion","finish","pause","syncCurrentTime","startTime","holdTime","proxyAnimations","cancel","ProxyAnimation","animationTimeline","isScrollAnimation","resetCurrentTimeOnResume","sequence","aborted","Set","seekTime","hasActiveTimeline","play","abortedPause","pending","hasPendingReadyPromise","bind","commitPendingPlay","currentTimeToMatch","commitPendingPause","readyTime","console","log","reverse","updatePlaybackRate","rate","previousPlayState","unconstrainedCurrentTime","persist","resetPendingTasks","newEffect","newTimeline","oldTimeline","fromScrollTimeline","toScrollTimeline","id","onfinish","oncancel","onremove","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","margins","split","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation","proxyAniamtion"],"mappings":"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"}