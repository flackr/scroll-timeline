{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  if (!window.CSSUnitValue) {\n    function displayUnit(unit) {\n      switch(unit) {\n        case 'percent':\n          return '%';\n        case 'number':\n          return '';\n        default:\n          return unit.toLowerCase();\n      }\n    }\n    class ProxyCSSUnitValue {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    }\n    window.CSSUnitValue = ProxyCSSUnitValue;\n  }\n\n  if (!window.CSSKeywordValue) {\n    class ProxyCSSKeywordValue {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    }\n    window.CSSKeywordValue = ProxyCSSKeywordValue;\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class ProxyMathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  if (!window.CSSMathSum) {\n    class ProxyCSSMathSum extends ProxyMathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    }\n    window.CSSMathSum = ProxyCSSMathSum;\n  }\n\n  if (!window.CSSMathProduct) {\n    class ProxyCSSMathProduct extends ProxyMathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    }\n    window.CSSMathProduct = ProxyCSSMathProduct;\n  }\n\n  if (!window.CSSMathNegate) {\n    class ProxyCSSMathNegate extends ProxyMathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    }\n    window.CSSMathNegate = ProxyCSSMathNegate;\n  }\n\n  if (!window.CSSMathInvert) {\n    class ProxyCSSMathNegate extends ProxyMathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    }\n    window.CSSMathNegate = ProxyCSSMathNegate;\n  }\n\n  if (!window.CSSMathMax) {\n    class ProxyCSSMathMax extends ProxyMathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    }\n    window.CSSMathMax = ProxyCSSMathMax;\n  }\n\n  if (!window.CSSMathMin) {\n    class ProxyCSSMathMin extends ProxyMathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n    window.CSSMathMin = ProxyCSSMathMin;\n  }\n\n  if (!window.CSS)\n    window.CSS = {};\n\n  [\n    'number',\n    'percent',\n    // Length units\n    'em',\n    'ex',\n    'px',\n    'cm',\n    'mm',\n    'in',\n    'pt',\n    'pc',  // Picas\n    'Q',  // Quarter millimeter\n    'vw',\n    'vh',\n    'vmin',\n    'vmax',\n    'rems',\n    \"ch\",\n    // Angle units\n    'deg',\n    'rad',\n    'grad',\n    'turn',\n    // Time units\n    'ms',\n    's',\n    'Hz',\n    'kHz',\n    // Resolution\n    'dppx',\n    'dpi',\n    'dpcm',\n    // Other units\n    \"fr\"\n  ].forEach((name) => {\n    if (!CSS[name]) {\n      CSS[name] = (value) => {\n        return new CSSUnitValue(value, name);\n      }\n    }\n  });\n\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange,\n                           calculateTargetEffectEnd(animations[i].animation));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(scrollSource, orientation) {\n  const style = getComputedStyle(scrollSource);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = scrollSource.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(scrollSource.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(this.scrollSource).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue.value == 0 ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  return resolvePx(parsed, maxValue);\n}\n\n/**\n * Resolve scroll offsets per\n * https://drafts.csswg.org/scroll-animations-1/#effective-scroll-offsets-algorithm\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @param scrollOffsets {Array}\n * @param fns {Array}\n * @returns {Array}\n */\nexport function resolveScrollOffsets(\n  scrollSource,\n  orientation,\n  scrollOffsets,\n  fns\n) {\n  // 1. Let effective scroll offsets be an empty list of effective scroll\n  // offsets.\n  let effectiveScrollOffsets = [];\n  // 2. Let first offset be true.\n  let firstOffset = true;\n\n  // 3. If scrollOffsets is empty\n  if(scrollOffsets.length == 0) {\n    // 3.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 3.2 Set first offset to false.\n    firstOffset = false;\n    // 3.3 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(100, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n  }\n  // 4. If scrollOffsets has exactly one element\n  else if(scrollOffsets.length == 1) {\n    // 4.1 Run the procedure to resolve a scroll timeline offset for auto with\n    // the is first flag set to first offset and add the resulted value into\n    // effective scroll offsets.\n    effectiveScrollOffsets.push(\n      calculateScrollOffset(\n        new CSSUnitValue(0, 'percent'),\n        scrollSource,\n        orientation,\n        AUTO\n    ));\n    // 4.2 Set first offset to false.\n    firstOffset = false;\n  }\n  // 5. For each scroll offset in the list of scrollOffsets, perform the\n  // following steps:\n  for (let i = 0; i < scrollOffsets.length; i++) {\n    // 5.1 Let effective offset be the result of applying the procedure\n    // to resolve a scroll timeline offset for scroll offset with the is\n    // first flag set to first offset.\n    let effectiveOffset = calculateScrollOffset(\n      firstOffset ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'),\n      scrollSource,\n      orientation,\n      scrollOffsets[i],\n      fns[i]);\n    //  5.2 If effective offset is null, the effective scroll offsets is empty and abort the remaining steps.\n    if(effectiveOffset === null)\n      return [];\n    // 5.3 Add effective offset into effective scroll offsets.\n    effectiveScrollOffsets.push(effectiveOffset);\n    // 5.4 Set first offset to false.\n    firstOffset = false;\n  }\n  // 6. Return effective scroll offsets.\n  return effectiveScrollOffsets;\n}\n\n/**\n * Compute scroll timeline progress per\n * https://drafts.csswg.org/scroll-animations-1/#progress-calculation-algorithm\n * @param offset {number}\n * @param scrollOffsets {Array}\n * @returns {number}\n */\nexport function ComputeProgress(\n  offset,\n  scrollOffsets\n) {\n  // 1. Let scroll offsets be the result of applying the procedure to resolve\n  // scroll timeline offsets for scrollOffsets.\n  // 2. Let offset index correspond to the position of the last offset in\n  // scroll offsets whose value is less than or equal to offset and the value\n  // at the following position greater than offset.\n  let offsetIndex;\n  for (offsetIndex = scrollOffsets.length - 2;\n       offsetIndex >= 0 && \n         !(scrollOffsets[offsetIndex] <= offset && offset < scrollOffsets[offsetIndex + 1]);\n       offsetIndex--) {\n  }\n  // 3. Let start offset be the offset value at position offset index in\n  // scroll offsets.\n  let startOffset = scrollOffsets[offsetIndex];\n  // 4. Let end offset be the value of next offset in scroll offsets after\n  // start offset.\n  let endOffset = scrollOffsets[offsetIndex + 1];\n  // 5. Let size be the number of offsets in scroll offsets.\n  let size = scrollOffsets.length;\n  // 6. Let offset weight be the result of evaluating 1 / (size - 1).\n  let offsetWeight = 1 / (size - 1);\n  // 7. Let interval progress be the result of evaluating\n  // (offset - start offset) / (end offset - start offset).\n  let intervalProgress =  (offset - startOffset) / (endOffset - startOffset);\n  // 8. Return the result of evaluating\n  // (offset index + interval progress) × offset weight.\n  return (offsetIndex + intervalProgress) * offsetWeight;\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      scrollOffsets: [],\n      timeRange: AUTO,\n\n      // Internal members\n      animations: [],\n      scrollOffsetFns: [],\n    });\n    this.scrollSource =\n      options && options.scrollSource !== undefined ? options.scrollSource : document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.scrollOffsets = options && options.scrollOffsets !== undefined ? options.scrollOffsets : [];\n    this.timeRange = options && options.timeRange !== undefined ? options.timeRange : \"auto\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    scrollTimelineOptions.get(this).scrollSource = element;\n    if (element) {\n      scrollEventSource(element).addEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    }\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set scrollOffsets(value) {\n    let offsets = [];\n    let fns = [];\n    for (let input of value) {\n      let fn = null;\n      let offset = undefined;\n      if (input == \"auto\")\n        input = AUTO;\n      for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n        let result = extensionScrollOffsetFunctions[i].parse(input);\n        if (result !== undefined) {\n          offset = result;\n          fn = extensionScrollOffsetFunctions[i].evaluate;\n          break;\n        }\n      }\n      if (!fn) {\n        if (input != AUTO) {\n          let parsed = parseLength(input);\n          // TODO: This should check CSSMathSum values as well.\n          if (!parsed || (parsed instanceof CSSUnitValue && parsed.unit == \"number\"))\n            throw TypeError(\"Invalid scrollOffsets entry.\");\n        }\n        offset = input;\n      }\n      offsets.push(offset);\n      fns.push(fn);\n    }\n    if (offsets.length == 1 && offsets[0] == AUTO)\n      throw TypeError(\"Invalid scrollOffsets value.\");\n    let data = scrollTimelineOptions.get(this);\n    data.scrollOffsets = offsets;\n    data.scrollOffsetFns = fns;\n    updateInternal(this);\n  }\n\n  get scrollOffsets() {\n    let data = scrollTimelineOptions.get(this);\n    return data.scrollOffsets;\n  }\n\n  set timeRange(range) {\n    if (range != \"auto\") {\n      // Check for a valid number, which if finite and not NaN.\n      if (typeof(range) != \"number\" || !Number.isFinite(range) || range != range)\n        throw TypeError(\"Invalid timeRange value\");\n    }\n    scrollTimelineOptions.get(this).timeRange = range;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    let unresolved = null;\n    //   if source is null\n    if (!this.scrollSource) return \"inactive\";\n    let scrollerStyle = getComputedStyle(this.scrollSource);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (this.scrollSource != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n\n    //   if source's effective scroll range is null\n    if (effectiveScrollOffsets.length == 0)\n      return \"inactive\";\n\n    let maxOffset = calculateScrollOffset(\n      new CSSUnitValue(100, 'percent'),\n      this.scrollSource,\n      this.orientation,\n      new CSSUnitValue(100, 'percent'),\n      null\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return \"before\";\n    if (currentScrollOffset >= endOffset && endOffset < maxOffset)\n      return \"after\";\n    return \"active\"\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    let effectiveScrollOffsets = resolveScrollOffsets(\n      this.scrollSource,\n      this.orientation,\n      this.scrollOffsets,\n      scrollTimelineOptions.get(this).scrollOffsetFns\n    );\n    let startOffset = effectiveScrollOffsets[0];\n    let endOffset = effectiveScrollOffsets[effectiveScrollOffsets.length - 1];\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    const currentScrollOffset =\n        directionAwareScrollOffset(this.scrollSource, this.orientation);\n\n    // Step 3\n    if (currentScrollOffset < startOffset)\n      return 0;\n\n    // Step 4\n    if (currentScrollOffset >= endOffset)\n      return timeRange;\n\n    // Step 5\n    let progress = ComputeProgress(\n      currentScrollOffset,\n      effectiveScrollOffsets\n    );\n    return progress * timeRange;\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = details.timeline.currentTime;\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = details.timeline.currentTime;\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n  // Handle the finished event via the native animation.\n  // TODO: consider polyfilling queuing the event.\n  details.animation.finish();\n  details.animation.pause();\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = details.timeline.currentTime;\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  const unconstrainedCurrentTime =\n      didSeek ? details.proxy.currentTime : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    // TODO: Support hold phase.\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = details.proxy.currentTime;\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = details.animation.effect.getTiming();\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n  return Math.max(0, totalDuration);\n}\n\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    details.animation.currentTime =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n  } else if (details.holdTime !== null) {\n    details.animation.currentTime = details.holdTime;\n  }\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = details.proxy.currentTime;\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    details.animation.currentTime =\n        (timelineTime - this.startTime) * this.playbackRate;\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    const details = proxyAnimations.get(this);\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime = previousCurrentTime;\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousCurrentTime;\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return details.startTime;\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = details.timeline.currentTime;\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = this.currentTime;\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return details.holdTime;\n\n    return calculateCurrentTime(details);\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = this.currentTime;\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = limit;\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = details.timeline.currentTime;\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ? null :  this.currentTime;\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = details.timeline.currentTime;\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a TypeError for a parse error.\n    if (threshold != threshold)\n      throw TypeError(\"Invalid threshold.\");\n    // TODO(https://crbug.com/1136516): This should throw a RangeError\n    // consistent with the intersection observer spec but the current\n    // test expectations are looking for a TypeError.\n    if (threshold < 0 || threshold > 1)\n      throw TypeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i], true);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"percent\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","obj","acceptStr","CSSUnitValue","CSSMathSum","matches","trim","match","privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","window","value","unit","set","this","toString","details","get","toLowerCase","displayUnit","CSSKeywordValue","ProxyMathOperation","operator","opt_name","opt_delimiter","name","delimiter","join","arguments","CSSMathProduct","CSSMathNegate","CSSMathInvert","CSSMathMax","CSSMathMin","CSS","forEach","installCSSOM","AUTO","scrollTimelineOptions","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","resolvePx","cssValue","resolvedLength","TypeError","total","calculateScrollOffset","autoValue","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","resolveScrollOffsets","scrollOffsets","fns","effectiveScrollOffsets","firstOffset","push","effectiveOffset","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","timeRange","scrollOffsetFns","undefined","_createClass","element","removeEventListener","_this","addEventListener","indexOf","offsets","input","parse","evaluate","parsed","data","range","Number","isFinite","scrollerStyle","display","overflow","maxOffset","startOffset","endOffset","phase","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","offsetIndex","ComputeProgress","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","timeline","notifyReady","createAbortError","DOMException","commitFinishedNotification","finishedPromise","proxy","playState","finish","pause","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","effectEnd","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","getTiming","delay","endDelay","iterations","duration","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","play","bind","pendingTask","proxyAnimations","cancel","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animationTimeline","isScrollAnimation","limit","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","type","callback","dispatchEvent","event","newEffect","newTimeline","oldTimeline","previousPlayState","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","parseFloat","map","margin","margins","split","parsedMargins","parsedValue","positions","j","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}