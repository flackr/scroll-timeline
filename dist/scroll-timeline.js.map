{"version":3,"file":"scroll-timeline.js","sources":["../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/scroll-timeline-css-parser.js","../src/scroll-timeline-css.js","../src/index.js"],"sourcesContent":["// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nimport { installCSSOM } from \"./proxy-cssom.js\";\ninstallCSSOM();\n\nconst AUTO = new CSSKeywordValue(\"auto\");\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(source) {\n  if (source === document.scrollingElement) return document;\n  return source;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  validateSource(scrollTimelineInstance);\n  const details = scrollTimelineOptions.get(scrollTimelineInstance);\n  let animations = details.animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical orientation.\n * @param scrollTimeline {ScrollTimeline}\n * @param orientation {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(source, orientation) {\n  if (!source)\n    return null;\n\n  const style = getComputedStyle(source);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset  = source.scrollTop;\n  if (orientation == 'horizontal' ||\n     (orientation == 'inline' && horizontalWritingMode) ||\n     (orientation == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(source.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Calculates scroll offset based on orientation and source geometry\n * @param source {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(source, orientation) {\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(source).writingMode == 'horizontal-tb';\n  if (orientation === \"block\")\n    orientation = horizontalWritingMode ? \"vertical\" : \"horizontal\";\n  else if (orientation === \"inline\")\n    orientation = horizontalWritingMode ? \"horizontal\" : \"vertical\";\n  if (orientation === \"vertical\")\n    return source.scrollHeight - source.clientHeight;\n  else if (orientation === \"horizontal\")\n    return source.scrollWidth - source.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\n// Detects if the cached source is obsolete, and updates if required\n// to ensure the new source has a scroll listener.\nfunction validateSource(timeline) {\n  if (!(timeline instanceof ViewTimeline))\n    return;\n\n  const node = timeline.subject;\n  if (!node) {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const display  = getComputedStyle(node).display;\n  if (display == 'none') {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const source = getScrollParent(node);\n  updateSource(timeline, source);\n}\n\nfunction updateSource(timeline, source) {\n  const details = scrollTimelineOptions.get(timeline);\n  const oldSource = details.source;\n  const oldScrollListener = details.scrollListener;\n  if (oldSource == source)\n    return;\n\n  if (oldSource && oldScrollListener) {\n    scrollEventSource(oldSource).removeEventListener(\"scroll\",\n                                                     oldScrollListener);\n  }\n  scrollTimelineOptions.get(timeline).source = source;\n  if (source) {\n    const listener = () => {\n      updateInternal(timeline);\n    };\n    scrollEventSource(source).addEventListener(\"scroll\", listener);\n    details.scrollListener = listener;\n  }\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      source: null,\n      orientation: \"block\",\n\n      // View timeline\n      subject: null,\n      inset: (options ? options.inset : null),\n\n      // Internal members\n      animations: [],\n      scrollListener: null\n    });\n    const source =\n      options && options.source !== undefined ? options.source\n                                              : document.scrollingElement;\n    updateSource(this, source);\n    this.orientation = (options && options.orientation) || \"block\";\n    updateInternal(this);\n  }\n\n  set source(element) {\n    updateSource(this, element);\n    updateInternal(this);\n  }\n\n  get source() {\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    ) {\n      throw TypeError(\"Invalid orientation\");\n    }\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  get duration() {\n    return CSS.percent(100);\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    const unresolved = null;\n    //   if source is null\n    const container = this.source;\n    if (!container) return \"inactive\";\n    let scrollerStyle = getComputedStyle(container);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (container != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    return \"active\"\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const container = this.source;\n    if (!container) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n\n    const orientation = this.orientation;\n    const scrollPos = directionAwareScrollOffset(container, orientation);\n    const maxScrollPos = calculateMaxScrollOffset(container, orientation);\n\n    return maxScrollPos > 0 ? CSS.percent(100 * scrollPos / maxScrollPos)\n                            : CSS.percent(100);\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n\n// Methods for calculation of the containing block.\n// See https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block.\n\nfunction findClosestAncestor(element, matcher) {\n  let candidate = element.parentElement;\n  while(candidate != null) {\n    if (matcher(candidate))\n      return candidate;\n    candidate = candidate.parentElement;\n  }\n}\n\nfunction isBlockContainer(element) {\n  const style = getComputedStyle(element);\n  switch (style.display) {\n    case 'block':\n    case 'inline-block':\n    case 'list-item':\n    case 'table':\n    case 'table-caption':\n    case 'flow-root':\n    case 'flex':\n    case 'grid':\n      return true;\n  }\n\n  return false;\n}\n\nfunction isFixedElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.transform != 'none' || style.perspective != 'none')\n    return true;\n\n  if (style.willChange == 'transform' || style.willChange == 'perspective')\n    return true;\n\n  if (style.filter != 'none' || style.willChange == 'filter')\n    return true;\n\n  if (style.backdropFilter != 'none')\n    return true;\n\n  return false;\n}\n\nfunction isAbsoluteElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.position != 'static')\n    return true;\n\n  return isFixedElementContainer(element);\n}\n\nfunction getContainingBlock(element) {\n  switch (getComputedStyle(element).position) {\n    case 'static':\n    case 'relative':\n    case 'sticky':\n      return findClosestAncestor(element, isBlockContainer);\n\n    case 'absolute':\n      return findClosestAncestor(element, isAbsoluteElementContainer);\n\n    case 'fixed':\n      return findClosestAncestor(element, isFixedElementContainer);\n  }\n}\n\nexport function getScrollParent(node) {\n  if (!node)\n    return undefined;\n\n  while (node = getContainingBlock(node)) {\n    const style = getComputedStyle(node);\n    switch(style['overflow-x']) {\n      case 'auto':\n      case 'scroll':\n      case 'hidden':\n        // https://drafts.csswg.org/css-overflow-3/#overflow-propagation\n        // The UA must apply the overflow from the root element to the viewport;\n        // however, if the overflow is visible in both axis, then the overflow\n        // of the first visible child body is applied instead.\n        if (node == document.body &&\n            getComputedStyle(document.scrollingElement).overflow == \"visible\")\n          return  document.scrollingElement;\n\n        return node;\n    }\n  }\n  return document.scrollingElement;\n}\n\n// ---- View timelines -----\n\n// Computes the scroll offsets corresponding to the [0, 100]% range for a\n// specific phase on a view timeline.\n// TODO: Track changes to determine when associated animations require their\n// timing to be renormalized.\nfunction range(timeline, phase) {\n  const details = scrollTimelineOptions.get(timeline);\n\n  const unresolved = null;\n  if (timeline.phase === 'inactive')\n    return unresolved;\n\n  if (!(timeline instanceof ViewTimeline))\n    return unresolved;\n\n  // Compute the offset of the top-left corner of subject relative to\n  // top-left corner of the container.\n  const container = timeline.source;\n  const target = timeline.subject;\n\n  return calculateRange(phase, container, target, details.orientation, details.inset);\n}\n\nexport function calculateRange(phase, container, target, orientation, optionsInset) {\n  let top = 0;\n  let left = 0;\n  let node = target;\n  const ancestor = container.offsetParent;\n  while (node && node != ancestor) {\n    left += node.offsetLeft;\n    top += node.offsetTop;\n    node = node.offsetParent;\n  }\n  left -= container.offsetLeft + container.clientLeft;\n  top -= container.offsetTop + container.clientTop;\n\n  // Determine the view and container size based on the scroll direction.\n  // The view position is the scroll position of the logical starting edge\n  // of the view.\n  const style = getComputedStyle(container);\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  const rtl = style.direction == 'rtl' || style.writingMode == 'vertical-rl';\n  let viewSize = undefined;\n  let viewPos = undefined;\n  let containerSize = undefined;\n  if (orientation == 'horizontal' ||\n      (orientation == 'inline' && horizontalWritingMode) ||\n      (orientation == 'block' && !horizontalWritingMode)) {\n    viewSize = target.clientWidth;\n    viewPos = left;\n    if (rtl)\n      viewPos += container.scrollWidth - container.clientWidth;\n    containerSize = container.clientWidth;\n  } else {\n    // TODO: support sideways-lr\n    viewSize = target.clientHeight;\n    viewPos = top;\n    containerSize = container.clientHeight;\n  }\n\n  const inset = parseInset(optionsInset, containerSize);\n\n  // Cover:\n  // 0% progress represents the position at which the start border edge of the\n  // element’s principal box coincides with the end edge of its view progress\n  // visibility range.\n  // 100% progress represents the position at which the end border edge of the\n  // element’s principal box coincides with the start edge of its view progress\n  // visibility range.\n  const coverStartOffset = viewPos - containerSize + inset.end;\n  const coverEndOffset = viewPos + viewSize - inset.start;\n\n  // Contain:\n  // The 0% progress represents the earlier of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //    the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  // The 100% progress represents the greater of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //  the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  const alignStartOffset = coverStartOffset + viewSize;\n  const alignEndOffset = coverEndOffset - viewSize;\n  const containStartOffset = Math.min(alignStartOffset, alignEndOffset);\n  const containEndOffset = Math.max(alignStartOffset, alignEndOffset);\n\n  // Enter and Exit bounds align with cover and contains bounds.\n\n  let startOffset = undefined;\n  let endOffset = undefined;\n\n  switch(phase) {\n    case 'cover':\n      startOffset = coverStartOffset;\n      endOffset = coverEndOffset;\n      break;\n\n    case 'contain':\n      startOffset = containStartOffset;\n      endOffset = containEndOffset;\n      break;\n\n    case 'enter':\n      startOffset = coverStartOffset;\n      endOffset = containStartOffset;\n      break;\n\n    case 'exit':\n      startOffset = containEndOffset;\n      endOffset = coverEndOffset;\n      break;\n  }\n\n  return { start: startOffset, end: endOffset };\n}\n\nfunction parseInset(value, containerSize) {\n  const inset = { start: 0, end: 0 };\n\n  if(!value)\n    return inset;\n\n  const parts = value.split(' ');\n  const insetParts = [];\n  parts.forEach(part => {\n    // TODO: Add support for relative lengths (e.g. em)\n    if(part.endsWith(\"%\"))\n      insetParts.push(containerSize / 100 * parseFloat(part));\n    else if(part.endsWith(\"px\"))\n      insetParts.push(parseFloat(part));\n    else if(part === \"auto\")\n      insetParts.push(0);\n  });\n\n  if (insetParts.length > 2) {\n    throw TypeError(\"Invalid inset\");\n  }\n\n  if(insetParts.length == 1) {\n    inset.start = insetParts[0];\n    inset.end = insetParts[0];\n  } else if(insetParts.length == 2) {\n    inset.start = insetParts[0];\n    inset.end = insetParts[1];\n  }\n\n  return inset;\n}\n\n// Calculate the fractional offset of a (phase, percent) pair relative to the\n// full cover range.\nexport function relativePosition(timeline, phase, percent) {\n  const phaseRange = range(timeline, phase);\n  const coverRange = range(timeline, 'cover');\n  return calculateRelativePosition(phaseRange, percent, coverRange);\n}\n\nexport function calculateRelativePosition(phaseRange, percent, coverRange) {\n  if (!phaseRange || !coverRange)\n    return 0;\n\n  const fraction = percent.value / 100;\n  const offset =\n      (phaseRange.end - phaseRange.start) * fraction + phaseRange.start;\n  return (offset - coverRange.start) / (coverRange.end - coverRange.start);\n}\n\n// https://drafts.csswg.org/scroll-animations-1/rewrite#view-progress-timelines\nexport class ViewTimeline extends ScrollTimeline {\n  // As specced, ViewTimeline has a subject and a source, but\n  // ViewTimelineOptions only has source. Furthermore, there is a strict\n  // relationship between subject and source (source is nearest scrollable\n  // ancestor of subject).\n\n  // Proceeding under the assumption that subject will be added to\n  // ViewTimelineOptions. Inferring the source from the subject if not\n  // explicitly set.\n  constructor(options) {\n    if (options.axis) {\n      // Orientation called axis for a view timeline. Internally we can still\n      // call this orientation, since the internal naming is not exposed.\n      options.orientation = options.axis;\n    }\n    super(options);\n    const details = scrollTimelineOptions.get(this);\n    details.subject = options && options.subject ? options.subject : undefined;\n    // TODO: Handle insets.\n\n    validateSource(this);\n    updateInternal(this);\n  }\n\n  get source() {\n    validateSource(this);\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set source(source) {\n    throw new Error(\"Cannot set the source of a view timeline\");\n  }\n\n  get subject() {\n    return scrollTimelineOptions.get(this).subject;\n  }\n\n  // The orientation is called \"axis\" for a view timeline.\n  // Internally we still call it orientation.\n  get axis() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const scrollPos = directionAwareScrollOffset(this.source, this.orientation);\n    if (scrollPos == unresolved)\n      return unresolved;\n\n    const offsets = range(this, 'cover');\n    if (!offsets)\n      return unresolved;\n    const progress =\n        (scrollPos - offsets.start) / (offsets.end - offsets.start);\n\n    return CSS.percent(100 * progress);\n  }\n\n}\n","import {\n  ScrollTimeline,\n  addAnimation,\n  removeAnimation,\n  relativePosition\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nexport const ANIMATION_DELAY_NAMES = ['enter', 'exit', 'cover', 'contain'];\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime !== null)\n      notifyReady(details);\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\n// Converts a time from its internal representation to a percent. For a\n// monotonic timeline, time is reported as a double with implicit units of\n// milliseconds. For progress-based animations, times are reported as\n// percentages.\nfunction toCssNumberish(details, value) {\n  if (value === null)\n    return value;\n\n  if (typeof value !== 'number') {\n      throw new DOMException(\n          `Unexpected value: ${value}.  Cannot convert to CssNumberish`,\n          \"InvalidStateError\");\n  }\n\n  const limit = effectEnd(details);\n  const percent = limit ? 100 * value / limit : 0;\n  return CSS.percent(percent);\n}\n\n// Covnerts a time to its internal representation. Progress-based animations\n// use times expressed as percentages. Each progress-based animation is backed\n// by a native animation with a document timeline in the polyfill. Thus, we\n// need to convert the timing from percent to milliseconds with implicit units.\nfunction fromCssNumberish(details, value) {\n  if (!details.timeline) {\n    // Document timeline\n    if (value == null || typeof value === 'number')\n      return value;\n\n    const convertedTime = value.to('ms');\n    if (convertTime)\n      return convertedTime.value;\n\n    throw new DOMException(\n        \"CSSNumericValue must be either a number or a time value for \" +\n        \"time based animations.\",\n        \"InvalidStateError\");\n  } else {\n    // Scroll timeline.\n    if (value === null)\n      return value;\n\n    if (value.unit === 'percent') {\n      const duration = effectEnd(details);\n      return value.value * duration / 100;\n    }\n\n    throw new DOMException(\n        \"CSSNumericValue must be a percentage for progress based animations.\",\n        \"NotSupportedError\");\n  }\n}\n\nfunction normalizedTiming(details) {\n  // Used normalized timing in the case of a progress-based animation or\n  // specified timing with a document timeline.  The normalizedTiming property\n  // is initialized and cached when fetching the timing information.\n  const timing = details.proxy.effect.getTiming();\n  return details.normalizedTiming || timing;\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = fromCssNumberish(details, details.timeline.currentTime);\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n\n  details.animation.pause();\n\n  // Event times are speced as doubles in web-animations-1.\n  // Cannot dispatch a proxy to an event since the proxy is not a fully\n  // transparent replacement. As a workaround, use a custom event and inject\n  // the necessary getters.\n  const finishedEvent =\n    new CustomEvent('finish',\n                    { detail: {\n                      currentTime: details.proxy.currentTime,\n                      timelineTime: details.proxy.timeline.currentTime\n                    }});\n  Object.defineProperty(finishedEvent, 'currentTime', {\n    get: function() { return this.detail.currentTime; }\n  });\n  Object.defineProperty(finishedEvent, 'timelineTime', {\n    get: function() { return this.detail.timelineTime; }\n  });\n\n  requestAnimationFrame(() => {\n    queueMicrotask(() => {\n      details.animation.dispatchEvent(finishedEvent);\n    });\n  });\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  let unconstrainedCurrentTime =\n      didSeek ? fromCssNumberish(details, details.proxy.currentTime)\n              : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = fromCssNumberish(details,\n                                                 details.proxy.currentTime);\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = normalizedTiming(details);\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n\n  return Math.max(0, totalDuration);\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime == null)\n      return;\n\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(details,\n                         (timelineTimeMs - details.startTime) *\n                             details.animation.playbackRate);\n  } else if (details.holdTime !== null) {\n    setNativeCurrentTime(details, details.holdTime);\n  }\n}\n\n// Sets the time of the underlying animation, nudging the time slightly if at\n// a scroll-timeline boundary to remain in the active phase.\nfunction setNativeCurrentTime(details, time) {\n  const timeline = details.timeline;\n  const playbackRate = details.animation.playbackRate;\n  const atScrollTimelineBoundary =\n      timeline.currentTime &&\n      timeline.currentTime.value == (playbackRate < 0 ? 0 : 100);\n  const delta =\n      atScrollTimelineBoundary ? (playbackRate < 0 ? 0.001 : -0.001) : 0;\n\n  details.animation.currentTime = time + delta;\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let seek time be a time value that is initially unresolved.\n  let seekTime = null;\n\n  // 4. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n\n  // 5. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 5a If animation’s effective playback rate > 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time < zero, or\n  //      current time >= target effect end,\n  //    5a1. Set seek time to zero.\n  //\n  // 5b If animation’s effective playback rate < 0, the auto-rewind flag is\n  //    true and either animation’s:\n  //      current time is unresolved, or\n  //      current time ≤ zero, or\n  //      current time > target effect end,\n  //    5b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    5b2. Otherwise,\n  //         5b2a Set seek time to animation's associated effect end.\n  //\n  // 5c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    5c1. Set seek time to zero.\n  let previousCurrentTime = fromCssNumberish(details,\n                                             details.proxy.currentTime);\n\n  // Resume of a paused animation after a timeline change snaps to the scroll\n  // position.\n  if (details.resetCurrentTimeOnResume) {\n    previousCurrentTime = null;\n    details.resetCurrentTimeOnResume = false;\n  }\n\n  const playbackRate = effectivePlaybackRate(details);\n  const upperBound = effectEnd(details);\n  if (playbackRate > 0 && autoRewind && (previousCurrentTime == null ||\n                                         previousCurrentTime < 0 ||\n                                         previousCurrentTime >= upperBound)) {\n    seekTime = 0;\n  } else if (playbackRate < 0 && autoRewind &&\n             (previousCurrentTime == null || previousCurrentTime <= 0 ||\n             previousCurrentTime > upperBound)) {\n    if (upperBound == Infinity) {\n      // Defer to native implementation to handle throwing the exception.\n      details.animation.play();\n      return;\n    }\n    seekTime = upperBound;\n  } else if (playbackRate == 0 && previousCurrentTime == null) {\n    seekTime = 0;\n  }\n\n  // 6. If seek time is resolved,\n  //        6a1. Set animation's start time to seek time.\n  //        6a2. Let animation's hold time be unresolved.\n  //        6a3. Apply any pending playback rate on animation.\n  if (seekTime != null) {\n    details.startTime = seekTime;\n    details.holdTime = null;\n    applyPendingPlaybackRate(details);\n  }\n\n  // Additional step for the polyfill.\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 7. If animation's hold time is resolved, let its start time be\n  //    unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 8. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 9. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      seek time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  if (details.holdTime === null && seekTime === null &&\n      !abortedPause && details.pendingPlaybackRate === null)\n  return;\n\n  // 10. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 11. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // 12. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  if (details.pendingTask) {\n    notifyReady(details);\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(\n        details,\n        (timelineTimeMs - fromCssNumberish(details, this.startTime)) *\n            this.playbackRate);\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction notifyReady(details) {\n  if (details.pendingTask == 'pause') {\n    commitPendingPause(details);\n  } else if (details.pendingTask == 'play') {\n    commitPendingPlay(details);\n  }\n}\n\nfunction createProxyEffect(details) {\n  const effect = details.animation.effect;\n  const nativeUpdateTiming = effect.updateTiming;\n\n  // Generic pass-through handler for any method or attribute that is not\n  // explicitly overridden.\n  const handler = {\n    get: function(obj, prop) {\n      const result = obj[prop];\n      if (typeof result === 'function')\n        return result.bind(effect);\n      return result;\n    },\n\n    set: function(obj, prop, value) {\n      obj[prop] = value;\n      return true;\n    }\n  };\n  // Override getComputedTiming to convert to percentages when using a\n  // progress-based timeline.\n  const getComputedTimingHandler = {\n    apply: function(target) {\n      // Ensure that the native animation is using normalized values.\n      effect.getTiming();\n\n      const timing = target.apply(effect);\n\n      if (details.timeline) {\n        const preConvertLocalTime = timing.localTime;\n        timing.localTime = toCssNumberish(details, timing.localTime);\n        timing.endTime = toCssNumberish(details, timing.endTime);\n        timing.activeDuration =\n            toCssNumberish(details, timing.activeDuration);\n        const limit = effectEnd(details);\n        const iteration_duration = timing.iterations ?\n            (limit - timing.delay - timing.endDelay) / timing.iterations : 0;\n        timing.duration = limit ?\n            CSS.percent(100 * iteration_duration / limit) :\n            CSS.percent(0);\n\n        // Correct for inactive timeline.\n        if (details.timeline.currentTime === undefined) {\n          timing.localTime = null;\n        }\n      }\n      return timing;\n    }\n  };\n  // Override getTiming to normalize the timing. EffectEnd for the animation\n  // align with the timeline duration.\n  const getTimingHandler = {\n    apply: function(target, thisArg) {\n      // Arbitrary conversion of 100% to ms.\n      const INTERNAL_DURATION_MS = 100000;\n\n      if (details.specifiedTiming)\n        return details.specifiedTiming;\n\n      details.specifiedTiming = target.apply(effect);\n      let timing = Object.assign({}, details.specifiedTiming);\n\n      const timeline = details.timeline;\n      let computedDelays = false;\n      let startDelay;\n      let endDelay;\n      if (timeline instanceof ViewTimeline) {\n        // Compute start and end delay to align with start and end times.\n        // If times not specified use cover 0% to cover 100%.\n        startDelay = fractionalStartDelay(details);\n        endDelay = fractionalEndDelay(details);\n        computedDelays = true;\n      }\n\n      let totalDuration;\n\n      // Duration 'auto' case.\n      if (timing.duration === null || timing.duration === 'auto' ||\n          computedDelays) {\n        if (details.timeline) {\n          if (computedDelays) {\n            timing.delay = startDelay * INTERNAL_DURATION_MS;\n            timing.endDelay = endDelay * INTERNAL_DURATION_MS;\n          } else {\n            // TODO: start and end delay are specced as doubles and currently\n            // ignored for a progress based animation. Support delay and endDelay\n            // once CSSNumberish.\n            timing.delay = 0;\n            timing.endDelay = 0;\n          }\n          totalDuration = timing.iterations ? INTERNAL_DURATION_MS : 0;\n          timing.duration = timing.iterations\n             ? (totalDuration - timing.delay - timing.endDelay) /\n                 timing.iterations\n             : 0;\n          // Set the timing on the native animation to the normalized values\n          // while preserving the specified timing.\n          nativeUpdateTiming.apply(effect, [timing]);\n        }\n      }\n      details.normalizedTiming = timing;\n      return details.specifiedTiming;\n    }\n  };\n  const updateTimingHandler = {\n    apply: function(target, thisArg, argumentsList) {\n      // Additional validation that is specific to scroll timelines.\n      if (details.timeline) {\n        const options = argumentsList[0];\n        const duration = options.duration;\n        if (duration === Infinity) {\n          throw TypeError(\n              \"Effect duration cannot be Infinity when used with Scroll \" +\n              \"Timelines\");\n        }\n        const iterations = options.iterations;\n        if (iterations === Infinity) {\n          throw TypeError(\n            \"Effect iterations cannot be Infinity when used with Scroll \" +\n            \"Timelines\");\n        }\n      }\n\n      // Apply updates on top of the original specified timing.\n      if (details.specifiedTiming) {\n        target.apply(effect, [details.specifiedTiming]);\n      }\n      target.apply(effect, argumentsList);\n      // Force renormalization.\n      details.specifiedTiming = null;\n    }\n  };\n  const proxy = new Proxy(effect, handler);\n  proxy.getComputedTiming = new Proxy(effect.getComputedTiming,\n                                      getComputedTimingHandler);\n  proxy.getTiming = new Proxy(effect.getTiming, getTimingHandler);\n  proxy.updateTiming = new Proxy(effect.updateTiming, updateTimingHandler);\n  return proxy;\n}\n\n// Computes the start delay as a fraction of the active cover range.\nfunction fractionalStartDelay(details) {\n  if (!(details.timeline instanceof ViewTimeline))\n    return 0;\n\n  const startTime = details.timeRange.start;\n  return relativePosition(details.timeline, startTime.name, startTime.offset);\n}\n\n// Computes the ends delay as a fraction of the active cover range.\nfunction fractionalEndDelay(details) {\n  if (!(details.timeline instanceof ViewTimeline))\n    return 0;\n\n  const endTime = details.timeRange.end;\n  return 1 - relativePosition(details.timeline, endTime.name, endTime.offset);\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\n\nexport class ProxyAnimation {\n  constructor(effect, timeline, animOptions={}) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position. These values are represented as floating point\n      // numbers in milliseconds.\n      startTime: null,\n      holdTime: null,\n      previousCurrentTime: null,\n      // When changing the timeline on a paused animation, we defer updating the\n      // start time until the animation resumes playing.\n      resetCurrentTimeOnResume: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      // Record the specified timing since it may be different than the timing\n      // actually used for the animation. When fetching the timing, this value\n      // will be returned, however, the native animation will use normalized\n      // values.\n      specifiedTiming: null,\n      // The normalized timing has the corrected timing with the intrinsic\n      // iteration duration resolved.\n      normalizedTiming: null,\n      // Effect proxy that performs the necessary time conversions when using a\n      // progress-based timelines.\n      effect: null,\n      // Range when using a view-timeline. The default range is cover 0% to\n      // 100%.\n      timeRange: timeline instanceof ViewTimeline ? parseAnimationDelays(animOptions) : null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.effect;\n\n    // Proxy the effect to support timing conversions for progress based\n    // animations.\n    if (!details.effect)\n      details.effect = createProxyEffect(details);\n\n    return details.effect;\n  }\n  set effect(newEffect) {\n    proxyAnimations.get(this).animation.effect = newEffect;\n    // Reset proxy to force re-initialization the next time it is accessed.\n    details.effect = null;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    const details = proxyAnimations.get(this);\n    const end = effectEnd(details);\n    const progress =\n        end > 0 ? fromCssNumberish(details, previousCurrentTime) / end : 0;\n\n    // 5. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 6. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 7. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // 8. Set the flag reset current time on resume to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 9. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 7.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Let seek time be zero if playback rate >= 0, and animation’s\n      //    associated effect end otherwise.\n      const seekTime =\n          details.animation.playbackRate >= 0 ? 0 : effectEnd(details);\n\n      // 3.  Update the animation based on the first matching condition if any:\n      switch (previousPlayState) {\n        //   If either of the following conditions are true:\n        //     * previous play state is running or,\n        //     * previous play state is finished\n        //   Set animation’s start time to seek time.\n        case 'running':\n        case 'finished':\n          details.startTime = seekTime;\n          // Additional polyfill step needed to associate the animation with\n          // the scroll timeline.\n          addAnimation(details.timeline, details.animation,\n                       tickAnimation.bind(this));\n          break;\n\n        //   If previous play state is paused:\n        //     If previous current time is resolved:\n        //       * Set the flag reset current time on resume to true.\n        //       * Set start time to unresolved.\n        //       * Set hold time to previous current time.\n        case 'paused':\n          details.resetCurrentTimeOnResume = true;\n          details.startTime = null;\n          details.holdTime =\n              fromCssNumberish(details, CSS.percent(100 * progress));\n          break;\n\n        // Oterwise\n        default:\n          details.holdTime = null;\n          details.startTime = null;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 10. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 11. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 7 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = progress * effectEnd(details);\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return toCssNumberish(details, details.startTime);\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 1. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    // 2. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 3. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n\n    // 4. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 5. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 6. Set the reset current time on resume flag to false.\n    details.resetCurrentTimeOnResume = false;\n\n    // 7. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 7. If animation has a pending play task or a pending pause task, cancel\n    //    that task and resolve animation’s current ready promise with\n    //    animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 8. Run the procedure to update an animation’s finished state for animation\n   //    with the did seek flag set to true, and the synchronously notify flag\n   //    set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return toCssNumberish(details, details.holdTime);\n\n    return toCssNumberish(details, calculateCurrentTime(details));\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    value = fromCssNumberish(details, value);\n    if (!details.timeline || value == null) {\n      details.animation.currentTime = value;\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-current-time-of-an-animation\n    const previouStartTime = details.startTime;\n    const previousHoldTime = details.holdTime;\n    const timelinePhase = details.timeline.phase;\n\n    // Update either the hold time or the start time.\n    if (details.holdTime !== null || details.startTime === null ||\n        timelinePhase == 'inactive' || details.animation.playbackRate == 0) {\n      // TODO: Support hold phase.\n      details.holdTime = value;\n    } else {\n      details.startTime = calculateStartTime(details, value);\n    }\n    details.resetCurrentTimeOnResume = false;\n\n    // Preserve invariant that we can only set a start time or a hold time in\n    // the absence of an active timeline.\n    if (timelinePhase == 'inactive')\n      details.startTime = null;\n\n    // Reset the previous current time.\n    details.previousCurrentTime = null;\n\n    // Synchronously resolve pending pause task.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = value;\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // Update the finished state.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = fromCssNumberish(details, this.currentTime);\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = toCssNumberish(details, limit);\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // 3. Let seek time be a time value that is initially unresolved.\n    // 4. Let has finite timeline be true if animation has an associated\n    //    timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    let seekTime = null;\n\n    // 5.  If the animation’s current time is unresolved, perform the steps\n    //     according to the first matching condition from below:\n    // 5a. If animation’s playback rate is ≥ 0,\n    //       Set seek time to zero.\n    // 5b. Otherwise,\n    //         If associated effect end for animation is positive infinity,\n    //             throw an \"InvalidStateError\" DOMException and abort these\n    //             steps.\n    //         Otherwise,\n    //             Set seek time to animation's associated effect end.\n\n    const playbackRate = details.animation.playbackRate;\n    const duration = effectEnd(details);\n\n    if (details.animation.currentTime === null) {\n      if (playbackRate >= 0) {\n        seekTime = 0;\n      } else if (duration == Infinity) {\n        // Let native implementation take care of throwing the exception.\n        details.animation.pause();\n        return;\n      } else {\n        seekTime = duration;\n      }\n    }\n\n    // 6. If seek time is resolved,\n    //        If has finite timeline is true,\n    //            Set animation's start time to seek time.\n    if (seekTime !== null)\n      details.startTime = seekTime;\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment after the\n    //     user agent has performed any processing necessary to suspend the\n    //     playback of animation’s target effect, if any.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime =\n        details.resetCurrentTimeOnResume ?\n            null : fromCssNumberish(details, this.currentTime);\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = fromCssNumberish(details,\n                                              details.timeline.currentTime);\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\n// animation-delay or animation-end-delay should be in the form of a name and an optional percentage\nfunction parseOneAnimationDelay(delay, defaultOffset) {\n  if(!delay) return null;\n\n  const parts = delay.split(' ');\n\n  if(!ANIMATION_DELAY_NAMES.includes(parts[0]) ||\n    (parts.length == 2 && !parts[1].endsWith('%')))\n    throw TypeError(\"Invalid animation delay\");\n\n  let offset = defaultOffset;\n  if(parts.length == 2) {\n    const percentage = parseFloat(parts[1]);\n    if(Number.isNaN(percentage))\n      throw TypeError(`\\\"${parts[1]}\\\" is not a valid percentage for animation delay`);\n\n    offset = CSS.percent(percentage);\n  }\n\n  return { name: parts[0], offset: offset };\n}\n\nfunction defaultAnimationDelay() { return { name: 'cover', offset: CSS.percent(0) }; }\n\nfunction defaultAnimationEndDelay() { return { name: 'cover', offset: CSS.percent(100) }; }\n\nfunction parseAnimationDelays(animOptions) {\n  const timeRange = parseTimeRange(animOptions['animation-time-range']);\n\n  if(animOptions['animation-delay'])\n    timeRange.start = parseOneAnimationDelay(animOptions['animation-delay'], defaultAnimationDelay().offset);\n\n  if(animOptions['animation-end-delay'])\n    timeRange.end = parseOneAnimationDelay(animOptions['animation-end-delay'], defaultAnimationEndDelay().offset);\n\n  return timeRange;\n}\n\nfunction parseTimeRange(value) {\n  const timeRange = {\n    start: defaultAnimationDelay(),\n    end: defaultAnimationEndDelay()\n  };\n\n  if (!value)\n    return timeRange;\n\n  // Format:\n  // <start-name> <start-offset> <end-name> <end-offset>\n  // <name> --> <name> 0% <name> 100%\n  // <name> <start-offset> <end-offset> --> <name> <start-offset>\n  //                                        <name> <end-offset>\n  // <start-offset> <end-offset> --> cover <start-offset> cover <end-offset>\n  // TODO: Support all formatting options once ratified in the spec.\n  const parts = value.split(' ');\n  const names = [];\n  const offsets = [];\n\n  parts.forEach(part => {\n    if (part.endsWith('%'))\n      offsets.push(parseFloat(part));\n    else\n      names.push(part);\n  });\n\n  if (names.length > 2 || offsets.length > 2 || offsets.length == 1) {\n    throw TypeError(\"Invalid time range\");\n  }\n\n  if (names.length) {\n    timeRange.start.name = names[0];\n    timeRange.end.name = names.length > 1 ? names[1] : names[0];\n  }\n\n  if (offsets.length > 1) {\n    timeRange.start.offset = CSS.percent(offsets[0]);\n    timeRange.end.offset = CSS.percent(offsets[1]);\n  }\n\n  return timeRange;\n}\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const timelineOffset = (options, property) => {\n     if (property in options) {\n        const value = options[property];\n        if (typeof value != 'number') {\n          delete options[property];\n          return value;\n        }\n        return null;\n     }\n  };\n\n  const updateDelay = (timelineOffset, value) => {\n    if (!value)\n      return;\n\n    // TODO(kevers): Update property names once ratified.\n    // https://github.com/w3c/csswg-drafts/issues/7589\n    if (value.phase)\n      timelineOffset.name = value.phase;\n\n    if (value.percent)\n      timelineOffset.offset = value.percent;\n  };\n\n  const delayTimelineOffset = timelineOffset(options, 'delay');\n  const endDelayTimelineOffset = timelineOffset(options, 'endDelay');\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    if (timeline instanceof ViewTimeline) {\n      const details = proxyAnimations.get(proxyAnimation);\n      details.timeRange = parseTimeRange(options.timeRange);\n      updateDelay(details.timeRange.start, delayTimelineOffset);\n      updateDelay(details.timeRange.end, endDelayTimelineOffset);\n    }\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n};\n","import { ANIMATION_DELAY_NAMES } from './proxy-animation';\n\n// This is also used in scroll-timeline-css.js\nexport const RegexMatcher = {\n  IDENTIFIER: /[\\w\\\\\\@_-]+/g,\n  WHITE_SPACE: /\\s*/g,\n  NUMBER: /^[0-9]+/,\n  TIME: /^[0-9]+(s|ms)/,\n  VIEW_TIMELINE: /view-timeline\\s*:([^;}]+)/,\n  VIEW_TIMELINE_NAME: /view-timeline-name\\s*:([^;}]+)/,\n  VIEW_TIMELINE_AXIS: /view-timeline-axis\\s*:([^;}]+)/,\n  ANIMATION_TIMELINE: /animation-timeline\\s*:([^;}]+)/,\n  ANIMATION_DELAY: /animation-delay\\s*:([^;}]+)/,\n  ANIMATION_END_DELAY: /animation-end-delay\\s*:([^;}]+)/,\n  ANIMATION_TIME_RANGE: /animation-time-range\\s*:([^;}]+)/,\n  ANIMATION_NAME: /animation-name\\s*:([^;}]+)/,\n  ANIMATION: /animation\\s*:([^;}]+)/,\n  SOURCE_ELEMENT: /selector\\(#([^)]+)\\)/,\n};\n\n// Used for ANIMATION_TIMELINE, ANIMATION_NAME and ANIMATION regex\nconst VALUES_CAPTURE_INDEX = 1;\n\nconst WHOLE_MATCH_INDEX = 0;\n\nconst ANIMATION_KEYWORDS = [\n  'normal', 'reverse', 'alternate', 'alternate-reverse',\n  'none', 'forwards', 'backwards', 'both',\n  'running', 'paused',\n  'ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out'\n];\n\nconst VIEW_TIMELINE_AXIS_TYPES = ['block', 'inline',  'vertical', 'horizontal'];\n\n// 1 - Extracts @scroll-timeline and saves it in scrollTimelineOptions.\n// 2 - If we find any animation-timeline in any of the CSS Rules, \n// we will save objects in a list named cssRulesWithTimelineName\nexport class StyleParser {\n  constructor() {\n    this.cssRulesWithTimelineName = [];\n    this.scrollTimelineOptions = new Map(); // save options by name\n    this.subjectSelectorToViewTimeline = [];\n    this.keyframeNamesSelectors = new Map();\n  }\n\n  // Inspired by\n  // https://drafts.csswg.org/css-syntax/#parser-diagrams\n  // https://github.com/GoogleChromeLabs/container-query-polyfill/blob/main/src/engine.ts\n  // This function is called twice, in the first pass we are interested in saving\n  // @scroll-timeline and @keyframe names, in the second pass\n  // we will parse other rules\n  transpileStyleSheet(sheetSrc, firstPass, srcUrl) {\n    // AdhocParser\n    const p = {\n      sheetSrc: sheetSrc,\n      index: 0,\n      name: srcUrl,\n    };\n\n    while (p.index < p.sheetSrc.length) {\n      this.eatWhitespace(p);\n      if (p.index >= p.sheetSrc.length) break;\n      if (this.lookAhead(\"/*\", p)) {\n        while (this.lookAhead(\"/*\", p)) {\n          this.eatComment(p);\n          this.eatWhitespace(p);\n        }\n        continue;\n      }\n\n      if (this.lookAhead(\"@scroll-timeline\", p)) {\n        const { scrollTimeline, startIndex, endIndex } = this.parseScrollTimeline(p);\n        if (firstPass) this.scrollTimelineOptions.set(scrollTimeline.name, scrollTimeline);\n      } else {\n        const rule = this.parseQualifiedRule(p);\n        if (!rule) continue;\n        if (firstPass) {\n          this.parseKeyframesAndSaveNameMapping(rule, p);\n        } else {\n          this.handleScrollTimelineProps(rule, p);\n        }\n      }\n    }\n\n    // If this sheet has no srcURL (like from a <style> tag), we are done.\n    // TODO: Otherwise, we have to find `url()` functions and resolve\n    // relative and path-absolute URLs to absolute URLs.\n    return p.sheetSrc;\n  }\n\n  getAnimationTimelineOptions(animationName, target) {\n    // Rules are pushed to cssRulesWithTimelineName list in the same order as they appear in style sheet.\n    // We are traversing backwards to take the last sample of a rule in a style sheet.\n    // TODO: Rule specificity should be taken into account, i.e. don't just take the last\n    // rule that matches, instead take the one with the most specifity among those that match\n    for (let i = this.cssRulesWithTimelineName.length - 1; i >= 0; i--) {\n      const current = this.cssRulesWithTimelineName[i];\n      if (target.matches(current.selector)) {\n        if (!current['animation-name'] || current['animation-name'] == animationName) {\n          return {\n            'animation-timeline': current['animation-timeline'],\n            'animation-delay': current['animation-delay'],\n            'animation-end-delay': current['animation-end-delay'],\n            'animation-time-range': current['animation-time-range']\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  // This implementation is based on https://drafts.csswg.org/scroll-animations-1/\n  // TODO: Should update accordingly when new spec lands.\n  getSourceElement(source) {\n    const matches = RegexMatcher.SOURCE_ELEMENT.exec(source);\n    const SOURCE_CAPTURE_INDEX = 1;\n    if (matches)\n      return document.getElementById(matches[SOURCE_CAPTURE_INDEX]);\n    else if (source === \"auto\")\n      return document.scrollingElement;\n    else\n      return null;\n  }\n\n  getScrollTimelineOptions(timelineName) {\n    const options = this.scrollTimelineOptions.get(timelineName);\n\n    if(options?.source) {\n      const sourceElement = this.getSourceElement(options.source);\n      return {\n        ...(sourceElement ? { source: sourceElement } : {}),\n        ...(options.orientation != \"auto\" ? { orientation: options.orientation } : {}),\n      };\n    }\n\n    return null;\n  }\n\n  findPreviousSiblingOrAncestorMatchingSelector(target, selector) {\n    // Target self\n    let candidate = target;\n    \n    // Walk the DOM tree: preceding siblings and ancestors\n    while (candidate) {\n      if (candidate.matches(selector)) \n        return candidate;\n      candidate = candidate.previousElementSibling || candidate.parentElement;\n    }\n\n    // No match\n    return null;\n  }\n\n  getViewTimelineOptions(timelineName, target) {\n    for (let i = this.subjectSelectorToViewTimeline.length - 1; i >= 0; i--) {\n      const options = this.subjectSelectorToViewTimeline[i];\n      if(options.name == timelineName) {\n        const subject = this.findPreviousSiblingOrAncestorMatchingSelector(target, options.selector);\n        if(subject) {\n          return {\n            subject,\n            axis: options.axis,\n            inset: options.inset\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  parseScrollTimeline(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"@scroll-timeline\");\n    this.eatWhitespace(p);\n    let name = this.parseIdentifier(p);\n    this.eatWhitespace(p);\n    this.assertString(p, \"{\"); // eats {\n    this.eatWhitespace(p);\n\n    let scrollTimeline = {\n      name: name,\n      source: \"auto\",\n      orientation: undefined,\n    };\n\n    while (this.peek(p) !== \"}\") {\n      const property = this.parseIdentifier(p);\n      this.eatWhitespace(p);\n      this.assertString(p, \":\");\n      this.eatWhitespace(p);\n      scrollTimeline[property] = this.removeEnclosingDoubleQuotes(this.eatUntil(\";\", p));\n      this.assertString(p, \";\");\n      this.eatWhitespace(p);\n    }\n\n    this.assertString(p, \"}\");\n    const endIndex = p.index;\n    this.eatWhitespace(p);\n    return {\n      scrollTimeline,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  handleScrollTimelineProps(rule, p) {\n    // The animation-timeline property may not be used in keyframes\n    if (rule.selector.includes(\"@keyframes\")) {\n      return;\n    }\n\n    // TODO is it enough to check with \"includes()\"\n    const hasAnimationName = rule.block.contents.includes(\"animation-name:\");\n    const hasAnimationTimeline = rule.block.contents.includes(\"animation-timeline:\");\n    const hasAnimation = rule.block.contents.includes(\"animation:\");\n\n    this.saveSubjectSelectorToViewTimeline(rule);\n\n    let timelineNames = [];\n    let animationNames = [];\n\n    if (hasAnimationTimeline)\n      timelineNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_TIMELINE);\n\n    if (hasAnimationName)\n      animationNames = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_NAME);\n\n    if (hasAnimationTimeline && hasAnimationName) {\n      this.saveRelationInList(rule, timelineNames, animationNames);\n      return;\n    }\n\n    if (hasAnimation) {\n      this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION)\n        .forEach(shorthand => {\n          const animationName = this.extractAnimationName(shorthand);\n          const timelineName = this.extractTimelineName(shorthand);\n          if (animationName) animationNames.push(animationName);\n          if (timelineName) {\n            timelineNames.push(timelineName);\n            // Remove timeline name from animation shorthand\n            // so the native implementation works with the rest of the properties\n            // Retain length of original name though, to play nice with multiple\n            // animations that might have been applied\n            rule.block.contents = rule.block.contents.replace(\n              timelineName,\n              \" \".repeat(timelineName.length)\n            );\n            this.replacePart(\n              rule.block.startIndex,\n              rule.block.endIndex,\n              rule.block.contents,\n              p\n            );\n          }\n\n          // If there is no duration, animationstart will not happen,\n          // and polyfill will not work which is based on animationstart.\n          // Add 1s as duration to fix this.\n          if(timelineName || hasAnimationTimeline) {\n            if(!this.hasDuration(shorthand)) {\n              // TODO: Should keep track of whether duration is artificial or not,\n              // so that we can later track that we need to update timing to\n              // properly see duration as 'auto' for the polyfill.\n              rule.block.contents = rule.block.contents.replace(\n                \"animation:\",\n                \"animation: 1s \"\n              );\n              this.replacePart(\n                rule.block.startIndex,\n                rule.block.endIndex,\n                rule.block.contents,\n                p\n              );\n            }\n          }\n        });\n    }\n\n    this.saveRelationInList(rule, timelineNames, animationNames);\n  }\n\n  saveSubjectSelectorToViewTimeline(rule) {\n    const hasViewTimeline = rule.block.contents.includes(\"view-timeline:\");\n    const hasViewTimelineName = rule.block.contents.includes(\"view-timeline-name:\");\n    const hasViewTimelineAxis = rule.block.contents.includes(\"view-timeline-axis:\");\n\n    if(!hasViewTimeline && !hasViewTimelineName) return;\n\n    let viewTimeline = {selector: rule.selector, name: '', axis: 'block'};\n\n    if(hasViewTimeline) {\n      const parts = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE, separator=' ');\n      if(parts.length == 1) {\n        viewTimeline.name = parts[0];\n      } else if(parts.length == 2) {\n        if(VIEW_TIMELINE_AXIS_TYPES.includes(parts[0]))\n          viewTimeline.axis = parts[0], viewTimeline.name = parts[1];\n        else\n          viewTimeline.axis = parts[1], viewTimeline.name = parts[0];\n      }\n    }\n\n    if(hasViewTimelineName) {\n      const parts = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_NAME);\n      viewTimeline.name = parts[0];\n    }\n\n    if(hasViewTimelineAxis) {\n      const parts = this.extractMatches(rule.block.contents, RegexMatcher.VIEW_TIMELINE_AXIS);\n      if(VIEW_TIMELINE_AXIS_TYPES.includes(parts[0]))\n        viewTimeline.axis = parts[0];\n    }\n\n    this.subjectSelectorToViewTimeline.push(viewTimeline);\n  }\n\n  hasDuration(shorthand) {\n    return shorthand.split(\" \").filter(part => isTime(part)).length >= 1;\n  }\n\n  saveRelationInList(rule, timelineNames, animationNames) {\n    const hasAnimationDelay = rule.block.contents.includes(\"animation-delay:\");\n    const hasAnimationEndDelay = rule.block.contents.includes(\"animation-end-delay:\");\n    const hasAnimationTimeRange = rule.block.contents.includes(\"animation-time-range:\");\n\n    let animationDelays = [];\n    let animationEndDelays = [];\n    let animationTimeRanges = [];\n\n    if (hasAnimationDelay)\n      animationDelays = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_DELAY);\n\n    if (hasAnimationEndDelay)\n      animationEndDelays = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_END_DELAY);\n\n    if (hasAnimationTimeRange)\n      animationTimeRanges = this.extractMatches(rule.block.contents, RegexMatcher.ANIMATION_TIME_RANGE);\n\n    const maxLength = Math.max(timelineNames.length, animationNames.length,\n      animationDelays.length, animationEndDelays.length, animationTimeRanges.length);\n\n    for (let i = 0; i < maxLength; i++) {\n      this.cssRulesWithTimelineName.push({\n        selector: rule.selector,\n        'animation-timeline': timelineNames[i % timelineNames.length],\n        ...(animationNames.length ? {'animation-name': animationNames[i % animationNames.length]}: {}),\n        ...(animationDelays.length ? {'animation-delay': animationDelays[i % animationDelays.length]}: {}),\n        ...(animationEndDelays.length ? {'animation-end-delay': animationEndDelays[i % animationEndDelays.length]}: {}),\n        ...(animationTimeRanges.length ? {'animation-time-range': animationTimeRanges[i % animationTimeRanges.length]}: {}),\n      });\n    }\n  }\n\n  extractAnimationName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.keyframeNamesSelectors);\n  }\n\n  extractTimelineName(shorthand) {\n    return this.findMatchingEntryInContainer(shorthand, this.scrollTimelineOptions);\n  }\n\n  findMatchingEntryInContainer(shorthand, container) {\n    const matches = shorthand.split(\" \").filter(part => container.has(part))\n    return matches ? matches[0] : null;\n  }\n\n\n  parseIdentifier(p) {\n    RegexMatcher.IDENTIFIER.lastIndex = p.index;\n    const match = RegexMatcher.IDENTIFIER.exec(p.sheetSrc);\n    if (!match) {\n      throw this.parseError(p, \"Expected an identifier\");\n    }\n    p.index += match[WHOLE_MATCH_INDEX].length;\n    return match[WHOLE_MATCH_INDEX];\n  }\n\n  parseKeyframesAndSaveNameMapping(rule, p) {\n    if (rule.selector.startsWith(\"@keyframes\")) {\n      const mapping = this.replaceKeyframesAndGetMapping(rule, p);\n      rule.selector.split(\" \").forEach((item, index) => {\n        if (index > 0)\n          this.keyframeNamesSelectors.set(item, mapping);\n      })\n    }\n  }\n\n  /*\n  Replaces this:\n    {\n      0% { opacity: 0 }\n      enter 100% { opacity: 1 }\n      exit 0% { opacity: 1 }\n      exit 100% { opacity: 0 }\n      to { opacity: 1 }\n    }\n  with this:\n    {\n      0% { opacity: 0 }\n      20% { opacity: 1 }\n      40% { opacity: 1 }\n      60% { opacity: 0 }\n      80% { opacity: 1 }\n    }\n  and returns a mapping of { \"0.00%\": \"0%\", \"20.00%\" : \"enter 100%\", \"40.00%\" : \"exit 0%\", ... }\n  If there are no phases in the keyframe selectors, nothing will happen\n  and an empty map is returned.\n  This change in keyframes is temporary, and when we are creating ScrollTimeline,\n  if the underlying animation has a mapping, we will calculate new offsets and set new keyframes.\n  */\n  replaceKeyframesAndGetMapping(rule, p) {\n    function hasPhase(selector) {\n      return ANIMATION_DELAY_NAMES.some(phase => selector.startsWith(phase));\n    }\n\n    function cleanFrameSelector(selector) {\n      return selector.split(\" \").map(h => h.trim()).filter(p => p != \"\").join(\" \");\n    }\n\n    function getFrameSelectorIndexes(contents) {\n      let open = 0;\n      let startIndex = -1;\n      let endIndex = -1;\n      const indexes = [];\n\n      for(let i = 0; i < contents.length; i++) {\n        if(contents[i] == '{')\n          open++;\n        else if(contents[i] == '}')\n          open--;\n\n        if(open == 1 && contents[i] != '{' && contents[i] != '}') {\n          if(startIndex == -1)\n            startIndex = i;\n        }\n\n        if(open == 2 && contents[i] == '{') {\n          endIndex = i;\n          indexes.push({start: startIndex, end: endIndex});\n          startIndex = endIndex = -1;\n        }\n      }\n      return indexes;\n    }\n\n    const contents = rule.block.contents;\n    const parts = getFrameSelectorIndexes(contents);\n\n    if(parts.length == 0)\n      return new Map();\n\n    const mapping = new Map();\n    let foundPhaseLinkedOffset = false;\n    const newContents = [];\n    newContents.push(contents.substring(0, parts[0].start));\n    for(let i = 0; i < parts.length; i++) {\n      const currentFrameSelector = contents.substring(parts[i].start, parts[i].end);\n      const trimmedFrameSelector = cleanFrameSelector(currentFrameSelector);\n      // There is no need to treat 'from' and 'to' differently,\n      // Let's say some implicit keyframes for 'from' and 'to' are added to the\n      // keyframes, after we are converting keyframes back, we will ignore them\n      // because they have no presence in the mapping.\n      // TODO: total number of keyframes > 100 is not supported at the moment.\n      const newFrameSelector = mapping.size;\n      mapping.set(newFrameSelector, trimmedFrameSelector);\n      newContents.push(`${newFrameSelector}%`);\n\n      if(hasPhase(trimmedFrameSelector))\n        foundPhaseLinkedOffset = true;\n\n      if(i == parts.length-1)\n        newContents.push(contents.substring(parts[i].end));\n      else\n        newContents.push(contents.substring(parts[i].end, parts[i+1].start));\n    }\n\n    if(foundPhaseLinkedOffset) {\n      rule.block.contents = newContents.join(\"\");\n      this.replacePart(\n        rule.block.startIndex,\n        rule.block.endIndex,\n        rule.block.contents,\n        p\n      );\n      return mapping;\n    } else {\n      return new Map();\n    }\n  }\n\n  parseQualifiedRule(p) {\n    const startIndex = p.index;\n    const selector = this.parseSelector(p).trim();\n    if (!selector) return;\n    const block = this.eatBlock(p);\n    const endIndex = p.index;\n    return {\n      selector,\n      block,\n      startIndex,\n      endIndex,\n    };\n  }\n\n  removeEnclosingDoubleQuotes(s) {\n    let startIndex = s[0] == '\"' ? 1 : 0;\n    let endIndex = s[s.length - 1] == '\"' ? s.length - 1 : s.length;\n    return s.substring(startIndex, endIndex);\n  }\n\n  assertString(p, s) {\n    if (p.sheetSrc.substr(p.index, s.length) != s) {\n      throw this.parseError(p, `Did not find expected sequence ${s}`);\n    }\n    p.index += s.length;\n  }\n\n  replacePart(start, end, replacement, p) {\n    p.sheetSrc = p.sheetSrc.slice(0, start) + replacement + p.sheetSrc.slice(end);\n    // If we are pointing past the end of the affected section, we need to\n    // recalculate the string pointer. Pointing to something inside the section\n    // that’s being replaced is undefined behavior. Sue me.\n    if (p.index >= end) {\n      const delta = p.index - end;\n      p.index = start + replacement.length + delta;\n    }\n  }\n\n  eatComment(p) {\n    this.assertString(p, \"/*\");\n    this.eatUntil(\"*/\", p, true);\n    this.assertString(p, \"*/\");\n  }\n\n  eatBlock(p) {\n    const startIndex = p.index;\n    this.assertString(p, \"{\");\n    let level = 1;\n    while (level != 0) {\n      if(this.lookAhead(\"/*\", p)) {\n        this.eatComment(p);\n        continue;\n      }\n\n      if (p.sheetSrc[p.index] === \"{\") {\n        level++;\n      } else if (p.sheetSrc[p.index] === \"}\") {\n        level--;\n      }\n      this.advance(p);\n    }\n    const endIndex = p.index;\n    const contents = p.sheetSrc.slice(startIndex, endIndex);\n\n    return { startIndex, endIndex, contents };\n  }\n\n  advance(p) {\n    p.index++;\n    if (p.index > p.sheetSrc.length) {\n      throw this.parseError(p, \"Advanced beyond the end\");\n    }\n  }\n\n  eatUntil(s, p, replaceWithSpace=false) {\n    const startIndex = p.index;\n    while (!this.lookAhead(s, p)) {\n      this.advance(p);\n    }\n\n    if(replaceWithSpace) {\n      p.sheetSrc = p.sheetSrc.slice(0, startIndex)\n        + \" \".repeat(p.index - startIndex)\n        + p.sheetSrc.slice(p.index);\n    }\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  parseSelector(p) {\n    let startIndex = p.index;\n    this.eatUntil(\"{\", p);\n    if (startIndex === p.index) {\n      throw Error(\"Empty selector\");\n    }\n\n    return p.sheetSrc.slice(startIndex, p.index);\n  }\n\n  eatWhitespace(p) {\n    // Start matching at the current position in the sheet src\n    RegexMatcher.WHITE_SPACE.lastIndex = p.index;\n    const match = RegexMatcher.WHITE_SPACE.exec(p.sheetSrc);\n    if (match) {\n      p.index += match[WHOLE_MATCH_INDEX].length;\n    }\n  }\n\n  lookAhead(s, p) {\n    return p.sheetSrc.substr(p.index, s.length) == s;\n  }\n\n  peek(p) {\n    return p.sheetSrc[p.index];\n  }\n\n  extractMatches(contents, matcher, separator=',') {\n    return matcher.exec(contents)[VALUES_CAPTURE_INDEX].trim().split(separator).map(item => item.trim());\n  }\n}\n\nfunction isTime(s) {\n  return RegexMatcher.TIME.exec(s);\n}\n\nfunction isNumber(s) {\n  return RegexMatcher.NUMBER.exec(s);\n}\n\nexport function removeKeywordsFromAnimationShorthand(anim) {\n  return anim.split(' ').filter(\n    (item, index, array) => index == array.length - 1 || !ANIMATION_KEYWORDS.includes(item))\n    .filter(item => !isTime(item) && !isNumber(item));\n}\n","import { StyleParser, RegexMatcher } from \"./scroll-timeline-css-parser\";\nimport { ProxyAnimation } from \"./proxy-animation\"\nimport { ScrollTimeline, ViewTimeline, getScrollParent, calculateRange,\n  calculateRelativePosition } from \"./scroll-timeline-base\";\n\nconst parser = new StyleParser();\n\nfunction initMutationObserver() {\n  const sheetObserver = new MutationObserver((entries) => {\n    for (const entry of entries) {\n      for (const addedNode of entry.addedNodes) {\n        if (addedNode instanceof HTMLStyleElement) {\n          handleStyleTag(addedNode);\n        }\n        if (addedNode instanceof HTMLLinkElement) {\n          handleLinkedStylesheet(addedNode);\n        }\n      }\n    }\n\n    // TODO: Proxy element.style similar to how we proxy element.animate.\n    // We accomplish this by swapping out Element.prototype.style.\n  });\n\n  sheetObserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n  });\n\n  /**\n   * @param {HtmlStyleElement} el style tag to be parsed\n   */\n  function handleStyleTag(el) {\n    // Don’t touch empty style tags.\n    if (el.innerHTML.trim().length === 0) {\n      return;\n    }\n    // TODO: Do with one pass for better performance\n    let newSrc = parser.transpileStyleSheet(el.innerHTML, true);\n    newSrc = parser.transpileStyleSheet(newSrc, false);\n    el.innerHTML = newSrc;\n  }\n\n  function handleLinkedStylesheet(el) {\n    // TODO\n  }\n\n  document.querySelectorAll(\"style\").forEach((tag) => handleStyleTag(tag));\n  document\n    .querySelectorAll(\"link\")\n    .forEach((tag) => handleLinkedStylesheet(tag));\n}\n\nfunction relativePosition(phase, container, target, orientation, optionsInset, percent) {\n  const phaseRange = calculateRange(phase, container, target, orientation, optionsInset);\n  const coverRange = calculateRange('cover', container, target, orientation, optionsInset);\n  return calculateRelativePosition(phaseRange, percent, coverRange);\n}\n\nfunction isDescendant(child, parent) {\n  while (child) {\n    if (child == parent) return true;\n    child = child.parentNode;\n  }\n  return false;\n}\n\nfunction createScrollTimeline(anim, animationName, target) {\n  const animOptions = parser.getAnimationTimelineOptions(animationName, target);\n  const timelineName = animOptions['animation-timeline'];\n  if(!timelineName) return null;\n\n  let options = parser.getScrollTimelineOptions(timelineName) ||\n    parser.getViewTimelineOptions(timelineName, target);\n  if (!options) return null;\n\n  // If this is a ViewTimeline\n  if(options.subject)\n    updateKeyframesIfNecessary(anim, options);\n\n  return {\n    timeline: options.source ? new ScrollTimeline(options) : new ViewTimeline(options),\n    animOptions: animOptions\n  };\n}\n\nfunction updateKeyframesIfNecessary(anim, options) {\n  const container = getScrollParent(options.subject);\n  const orientation = (options.axis || options.orientation);\n\n  function calculateNewOffset(mapping, keyframe) {\n    let newOffset = null;\n    for(const [key, value] of mapping) {\n      if(key == keyframe.offset * 100) {\n        if(value == 'from') {\n          newOffset = 0;\n        } else if(value == 'to') {\n          newOffset = 100;\n        } else {\n          const tokens = value.split(\" \");\n          if(tokens.length == 1) {\n            newOffset = parseFloat(tokens[0]);\n          } else {\n            newOffset = relativePosition(tokens[0], container, options.subject,\n              orientation, options.inset, CSS.percent(parseFloat(tokens[1]))) * 100;\n          }\n        }\n        break;\n      }\n    }\n\n    return newOffset;\n  }\n\n  const mapping = parser.keyframeNamesSelectors.get(anim.animationName);\n  // mapping is empty when none of the keyframe selectors contains a phase\n  if(mapping && mapping.size) {\n    const newKeyframes = [];\n    anim.effect.getKeyframes().forEach(keyframe => {\n      const newOffset = calculateNewOffset(mapping, keyframe);\n      if(newOffset !== null && newOffset >= 0 && newOffset <= 100) {\n        keyframe.offset = newOffset / 100.0;\n        newKeyframes.push(keyframe);\n      }\n    });\n\n    const sortedKeyframes = newKeyframes.sort((a, b) => {\n      if(a.offset < b.offset) return -1;\n      if(a.affset > b.offset) return 1;\n      return 0;\n    });\n\n    anim.effect.setKeyframes(sortedKeyframes);\n    // Since the mapping has been applied to these @keyframes, we no longer need them.\n    parser.keyframeNamesSelectors.set(anim.animationName, null);\n  }\n}\n\nexport function initCSSPolyfill() {\n  // Don't load if browser claims support\n  if (CSS.supports(\"animation-timeline: works\")) {\n    return;\n  }\n\n  initMutationObserver();\n\n  // We are not wrapping capturing 'animationstart' by a 'load' event,\n  // because we may lose some of the 'animationstart' events by the time 'load' is completed.\n  window.addEventListener('animationstart', (evt) => {\n    evt.target.getAnimations().filter(anim => anim.animationName === evt.animationName).forEach(anim => {\n      const result = createScrollTimeline(anim, anim.animationName, evt.target);\n      if (result.timeline && anim.timeline != result.timeline) {\n        const proxyAnimation = new ProxyAnimation(anim, result.timeline, result.animOptions);\n        anim.pause();\n        proxyAnimation.play();\n      }\n    });\n  });\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  ViewTimeline,\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\n\nimport { initCSSPolyfill } from \"./scroll-timeline-css\"\n\ninitCSSPolyfill();\n\nif ([...document.styleSheets].filter(s => s.href !== null).length) {\n  console.warn(\"Non-Inline StyleSheets detected: ScrollTimeline polyfill currently only\" +\n    \" supports inline styles within style tags\");\n}\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\nif (\n  !Reflect.defineProperty(window, \"ViewTimeline\", { value: ViewTimeline })\n) {\n  throw Error(\n    \"Error installing ViewTimeline polyfill: could not attach ViewTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["privateDetails","WeakMap","toCssNumericArray","values","v","result","i","length","CSSUnitValue","MathOperation","operator","opt_name","opt_delimiter","set","this","name","delimiter","toString","details","get","join","cssOMTypes","value","unit","toLowerCase","displayUnit","CSSKeywordValue","CSSMathSum","arguments","CSSMathProduct","CSSMathNegate","window","CSS","Reflect","defineProperty","Error","type","forEach","installCSSOM","scrollTimelineOptions","scrollEventSource","source","document","scrollingElement","updateInternal","scrollTimelineInstance","validateSource","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","orientation","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","Math","abs","scrollLeft","timeline","ViewTimeline","node","subject","display","updateSource","getScrollParent","oldSource","oldScrollListener","scrollListener","removeEventListener","listener","addEventListener","removeAnimation","scrollTimeline","animation","splice","addAnimation","push","ScrollTimeline","options","inset","undefined","_createClass","element","indexOf","TypeError","percent","container","scrollerStyle","overflow","phase","scrollPos","maxScrollPos","scrollHeight","clientHeight","scrollWidth","clientWidth","calculateMaxScrollOffset","findClosestAncestor","matcher","candidate","parentElement","isBlockContainer","isFixedElementContainer","style","transform","perspective","willChange","filter","backdropFilter","isAbsoluteElementContainer","position","getContainingBlock","body","range","calculateRange","target","optionsInset","top","left","ancestor","offsetParent","offsetLeft","offsetTop","clientLeft","clientTop","viewSize","viewPos","containerSize","direction","start","end","parts","split","insetParts","part","endsWith","parseFloat","parseInset","coverStartOffset","coverEndOffset","alignStartOffset","alignEndOffset","containStartOffset","min","containEndOffset","max","startOffset","endOffset","relativePosition","calculateRelativePosition","phaseRange","coverRange","axis","_this","unresolved","offsets","nativeElementAnimate","Element","prototype","animate","nativeAnimation","Animation","ANIMATION_DELAY_NAMES","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","requestAnimationFrame","notifyReady","createAbortError","DOMException","toCssNumberish","limit","effectEnd","fromCssNumberish","duration","convertedTime","to","convertTime","commitFinishedNotification","finishedPromise","proxy","playState","pause","finishedEvent","CustomEvent","detail","Object","queueMicrotask","dispatchEvent","effectivePlaybackRate","pendingPlaybackRate","playbackRate","applyPendingPlaybackRate","calculateCurrentTime","startTime","calculateStartTime","updateFinishedState","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","boundary","previousCurrentTime","holdTime","syncCurrentTime","then","timing","effect","getTiming","normalizedTiming","delay","endDelay","iterations","setNativeCurrentTime","time","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","seekTime","resetCurrentTimeOnResume","Infinity","play","bind","pendingTask","proxyAnimations","cancel","readyTime","commitPendingPause","currentTimeToMatch","commitPendingPlay","ProxyAnimation","animOptions","animationTimeline","isScrollAnimation","specifiedTiming","timeRange","parseAnimationDelays","finish","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","event","nativeUpdateTiming","updateTiming","getComputedTimingHandler","apply","localTime","endTime","activeDuration","getTimingHandler","thisArg","INTERNAL_DURATION_MS","startDelay","assign","computedDelays","offset","fractionalStartDelay","fractionalEndDelay","updateTimingHandler","argumentsList","Proxy","obj","prop","getComputedTiming","createProxyEffect","newEffect","newTimeline","oldTimeline","previousPlayState","progress","fromScrollTimeline","toScrollTimeline","timelinePhase","id","onfinish","oncancel","onremove","finished","ready","parseOneAnimationDelay","defaultOffset","includes","percentage","Number","isNaN","defaultAnimationDelay","defaultAnimationEndDelay","parseTimeRange","names","RegexMatcher","IDENTIFIER","WHITE_SPACE","NUMBER","TIME","VIEW_TIMELINE","VIEW_TIMELINE_NAME","VIEW_TIMELINE_AXIS","ANIMATION_TIMELINE","ANIMATION_DELAY","ANIMATION_END_DELAY","ANIMATION_TIME_RANGE","ANIMATION_NAME","ANIMATION","SOURCE_ELEMENT","VIEW_TIMELINE_AXIS_TYPES","parser","cssRulesWithTimelineName","Map","subjectSelectorToViewTimeline","keyframeNamesSelectors","transpileStyleSheet","sheetSrc","firstPass","srcUrl","p","index","eatWhitespace","lookAhead","eatComment","parseScrollTimeline","rule","parseQualifiedRule","parseKeyframesAndSaveNameMapping","handleScrollTimelineProps","getAnimationTimelineOptions","animationName","current","matches","selector","animation-timeline","animation-delay","animation-end-delay","animation-time-range","getSourceElement","exec","getElementById","getScrollTimelineOptions","timelineName","sourceElement","findPreviousSiblingOrAncestorMatchingSelector","previousElementSibling","getViewTimelineOptions","startIndex","assertString","parseIdentifier","peek","property","removeEnclosingDoubleQuotes","eatUntil","endIndex","hasAnimationName","block","contents","hasAnimationTimeline","hasAnimation","saveSubjectSelectorToViewTimeline","timelineNames","animationNames","extractMatches","shorthand","extractAnimationName","extractTimelineName","replace","repeat","replacePart","hasDuration","saveRelationInList","hasViewTimeline","hasViewTimelineName","hasViewTimelineAxis","viewTimeline","separator","hasAnimationDelay","hasAnimationEndDelay","hasAnimationTimeRange","animationDelays","animationEndDelays","animationTimeRanges","maxLength","animation-name","findMatchingEntryInContainer","has","lastIndex","match","parseError","startsWith","mapping","replaceKeyframesAndGetMapping","item","_this2","hasPhase","some","open","indexes","getFrameSelectorIndexes","foundPhaseLinkedOffset","newContents","substring","trimmedFrameSelector","map","h","trim","newFrameSelector","size","parseSelector","eatBlock","s","substr","replacement","slice","level","advance","replaceWithSpace","supports","handleStyleTag","el","innerHTML","newSrc","MutationObserver","entries","addedNodes","addedNode","HTMLStyleElement","observe","documentElement","childList","subtree","querySelectorAll","tag","initMutationObserver","evt","getAnimations","anim","newKeyframes","getKeyframes","keyframe","newOffset","tokens","calculateNewOffset","sortedKeyframes","sort","a","b","affset","setKeyframes","updateKeyframesIfNecessary","createScrollTimeline","proxyAnimation","styleSheets","href","console","warn","keyframes","timelineOffset","updateDelay","delayTimelineOffset","endDelayTimelineOffset"],"mappings":"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"}