function e(e,t){if(e instanceof CSSUnitValue||e instanceof CSSMathSum)return e;if(!t)return null;let n=e.trim().match(/^(-?[0-9]*\.?[0-9]*)(px|%)$/);return n?new CSSUnitValue(n[1],"%"==n[2]?"percent":n[2]):null}!function(){let e=new WeakMap;function t(e){const t=[];for(let i=0;i<e.length;i++)t[i]="number"==typeof(n=e[i])?new CSSUnitValue(n,"number"):n;var n;return t}class n{constructor(n,i,r,s){e.set(this,{values:t(n),operator:i,name:r||i,delimiter:s||", "})}get operator(){return e.get(this).operator}get values(){return e.get(this).values}toString(){const t=e.get(this);return`${t.name}(${t.values.join(t.delimiter)})`}}const i={CSSUnitValue:class{constructor(t,n){e.set(this,{value:t,unit:n})}get value(){return e.get(this).value}set value(t){e.get(this).value=t}get unit(){return e.get(this).unit}toString(){const t=e.get(this);return`${t.value}${function(e){switch(e){case"percent":return"%";case"number":return"";default:return e.toLowerCase()}}(t.unit)}`}},CSSKeywordValue:class{constructor(e){this.value=e}toString(){return this.value.toString()}},CSSMathSum:class extends n{constructor(e){super(arguments,"sum","calc"," + ")}},CSSMathProduct:class extends n{constructor(e){super(arguments,"product","calc"," * ")}},CSSMathNegate:class extends n{constructor(e){super([arguments[0]],"negate","-")}},CSSMathNegate:class extends n{constructor(e){super([1,arguments[0]],"invert","calc"," / ")}},CSSMathMax:class extends n{constructor(){super(arguments,"max")}},CSSMathMin:class extends n{constructor(){super(arguments,"min")}}};if(!window.CSS&&!Reflect.defineProperty(window,"CSS",{value:{}}))throw Error("Error installing CSSOM support");window.CSSUnitValue||["number","percent","em","ex","px","cm","mm","in","pt","pc","Q","vw","vh","vmin","vmax","rems","ch","deg","rad","grad","turn","ms","s","Hz","kHz","dppx","dpi","dpcm","fr"].forEach(e=>{if(!Reflect.defineProperty(CSS,e,{value:t=>new CSSUnitValue(t,e)}))throw Error(`Error installing CSS.${e}`)});for(let e in i)if(!(e in window)&&!Reflect.defineProperty(window,e,{value:i[e]}))throw Error(`Error installing CSSOM support for ${e}`)}();const t=new CSSKeywordValue("auto");let n=new WeakMap,i=[];function r(e){return e===document.scrollingElement?document:e}function s(e){let t=n.get(e).animations;if(0===t.length)return;let i=e.currentTime;for(let e=0;e<t.length;e++)t[e].tickAnimation(i)}function a(e,t){const n="horizontal-tb"==getComputedStyle(e).writingMode;let i=e.scrollTop;return("horizontal"==t||"inline"==t&&n||"block"==t&&!n)&&(i=Math.abs(e.scrollLeft)),i}function l(e,t){if(e instanceof CSSUnitValue){if("percent"==e.unit)return e.value*t/100;if("px"==e.unit)return e.value;throw TypeError("Unhandled unit type "+e.unit)}if(e instanceof CSSMathSum){let n=0;for(let i of e.values)n+=l(i,t);return n}throw TypeError("Unsupported value type: "+typeof e)}function o(n,i,r,s,a){if(a)return a(i,r,s,0==n.value?"start":"end");"block"===r?r="vertical":"inline"===r&&(r="horizontal");let o="vertical"===r?i.scrollHeight-i.clientHeight:i.scrollWidth-i.clientWidth;return l(e(s===t?n:s),o)}function c(e,n,i,r){let s=[],a=!0;0==i.length?(s.push(o(new CSSUnitValue(0,"percent"),e,n,t)),a=!1,s.push(o(new CSSUnitValue(100,"percent"),e,n,t))):1==i.length&&(s.push(o(new CSSUnitValue(0,"percent"),e,n,t)),a=!1);for(let t=0;t<i.length;t++){let l=o(a?new CSSUnitValue(0,"percent"):new CSSUnitValue(100,"percent"),e,n,i[t],r[t]);if(null===l)return[];s.push(l),a=!1}return s}function u(e,t){let i=n.get(e).animations;for(let e=0;e<i.length;e++)i[e].animation==t&&i.splice(e,1)}function m(e,t,i){let r=n.get(e).animations;for(let e=0;e<r.length;e++)if(r[e].animation==t)return;r.push({animation:t,tickAnimation:i}),s(e)}class h{constructor(e){n.set(this,{source:null,orientation:"block",scrollOffsets:[],animations:[],scrollOffsetFns:[]}),this.source=e&&void 0!==e.source?e.source:document.scrollingElement,this.orientation=e&&e.orientation||"block",this.scrollOffsets=e&&void 0!==e.scrollOffsets?e.scrollOffsets:[]}set source(e){this.source&&r(this.source).removeEventListener("scroll",()=>s(this)),n.get(this).source=e,e&&r(e).addEventListener("scroll",()=>s(this)),s(this)}get source(){return n.get(this).source}set orientation(e){if(-1===["block","inline","horizontal","vertical"].indexOf(e))throw TypeError("Invalid orientation");n.get(this).orientation=e,s(this)}get orientation(){return n.get(this).orientation}set scrollOffsets(r){let a=[],l=[];for(let n of r){let r,s=null;"auto"==n&&(n=t);for(let e=0;e<i.length;e++){let t=i[e].parse(n);if(void 0!==t){r=t,s=i[e].evaluate;break}}if(!s){if(n!=t){let t=e(n);if(!t||t instanceof CSSUnitValue&&"number"==t.unit)throw TypeError("Invalid scrollOffsets entry.")}r=n}a.push(r),l.push(s)}if(1==a.length&&a[0]==t)throw TypeError("Invalid scrollOffsets value.");let o=n.get(this);o.scrollOffsets=a,o.scrollOffsetFns=l,s(this)}get scrollOffsets(){return n.get(this).scrollOffsets}get duration(){return CSS.percent(100)}get phase(){if(!this.source)return"inactive";let e=getComputedStyle(this.source);if("none"==e.display)return"inactive";if(this.source!=document.scrollingElement&&("visible"==e.overflow||"clip"==e.overflow))return"inactive";let t=c(this.source,this.orientation,this.scrollOffsets,n.get(this).scrollOffsetFns);if(0==t.length)return"inactive";let i=o(new CSSUnitValue(100,"percent"),this.source,this.orientation,new CSSUnitValue(100,"percent"),null),r=t[0],s=t[t.length-1];const l=a(this.source,this.orientation);return l<r?"before":l>=s&&s<i?"after":"active"}get currentTime(){if(!this.source)return null;if("inactive"==this.phase)return null;let e=c(this.source,this.orientation,this.scrollOffsets,n.get(this).scrollOffsetFns),t=e[0],i=e[e.length-1];const r=a(this.source,this.orientation);if(r<t)return CSS.percent(0);if(r>=i)return CSS.percent(100);let s=function(e,t){let n;for(n=t.length-2;n>=0&&!(t[n]<=e&&e<t[n+1]);n--);let i=t[n];return(n+(e-i)/(t[n+1]-i))*(1/(t.length-1))}(r,e);return CSS.percent(100*s)}get __polyfill(){return!0}}function d(e){if(e)switch(getComputedStyle(e)["overflow-x"]){case"auto":case"scroll":case"hidden":return e;default:return d(e.parentNode)}}const f=window.Element.prototype.animate,p=window.Animation;class g{constructor(){this.state="pending",this.nativeResolve=this.nativeReject=null,this.promise=new Promise((e,t)=>{this.nativeResolve=e,this.nativeReject=t})}resolve(e){this.state="resolved",this.nativeResolve(e)}reject(e){this.state="rejected",this.promise.catch(()=>{}),this.nativeReject(e)}}function T(e){e.readyPromise=new g,requestAnimationFrame(()=>{null!==e.timeline.currentTime&&O(e)})}function y(){return new DOMException("The user aborted a request","AbortError")}function S(e,t){if(null===t)return t;if("number"!=typeof t)throw new DOMException(`Unexpected value: ${t}.  Cannot convert to CssNumberish`,"InvalidStateError");const n=C(e);return CSS.percent(n?100*t/n:0)}function v(e,t){if(e.timeline){if(null===t)return t;if("percent"===t.unit){const n=C(e);return t.value*n/100}throw new DOMException("CSSNumericValue must be a percentage for progress based animations.","NotSupportedError")}{if(null==t||"number"==typeof t)return t;const e=t.to("ms");if(convertTime)return e.value;throw new DOMException("CSSNumericValue must be either a number or a time value for time based animations.","InvalidStateError")}}function w(e){if(!e.finishedPromise||"pending"!=e.finishedPromise.state)return;if("finished"!=e.proxy.playState)return;e.finishedPromise.resolve(e.proxy),e.animation.pause();const t=new CustomEvent("finish",{detail:{currentTime:e.proxy.currentTime,timelineTime:e.proxy.timeline.currentTime}});Object.defineProperty(t,"currentTime",{get:function(){return this.detail.currentTime}}),Object.defineProperty(t,"timelineTime",{get:function(){return this.detail.timelineTime}}),requestAnimationFrame(()=>{queueMicrotask(()=>{e.animation.dispatchEvent(t)})})}function b(e){return null!==e.pendingPlaybackRate?e.pendingPlaybackRate:e.animation.playbackRate}function k(e){null!==e.pendingPlaybackRate&&(e.animation.playbackRate=e.pendingPlaybackRate,e.pendingPlaybackRate=null)}function x(e){if(!e.timeline)return null;const t=v(e,e.timeline.currentTime);if(null===t)return null;if(null===e.startTime)return null;let n=(t-e.startTime)*e.animation.playbackRate;return-0==n&&(n=0),n}function E(e,t){if(!e.timeline)return null;const n=v(e,e.timeline.currentTime);return null==n?null:n-t/e.animation.playbackRate}function P(e,t,n){if(!e.timeline)return;let i=t?v(e,e.proxy.currentTime):x(e);if(i&&null!=e.startTime&&!e.proxy.pending){const n=b(e),r=C(e);let s=e.previousCurrentTime;n>0&&i>=r?((null===s||s<r)&&(s=r),e.holdTime=t?i:s):n<0&&i<=0?((null==s||s>0)&&(s=0),e.holdTime=t?i:s):0!=n&&(t&&null!==e.holdTime&&(e.startTime=E(e,e.holdTime)),e.holdTime=null)}R(e),e.previousCurrentTime=v(e,e.proxy.currentTime),"finished"==e.proxy.playState?(e.finishedPromise||(e.finishedPromise=new g),"pending"==e.finishedPromise.state&&(n?w(e):Promise.resolve().then(()=>{w(e)}))):(e.finishedPromise&&"resolved"==e.finishedPromise.state&&(e.finishedPromise=new g),"paused"!=e.animation.playState&&e.animation.pause())}function C(e){const t=function(e){const t=e.proxy.effect.getTiming();return e.normalizedTiming||t}(e);return Math.max(0,t.delay+t.endDelay+t.iterations*t.duration)}function R(e){if(e.timeline)if(null!==e.startTime){const t=v(e,e.timeline.currentTime);e.animation.currentTime=(t-e.startTime)*e.animation.playbackRate}else null!==e.holdTime&&(e.animation.currentTime=e.holdTime)}function M(e,t){if(!e.timeline)return;const n="paused"==e.proxy.playState&&e.proxy.pending;let i=!1,r=null,s=v(e,e.proxy.currentTime);e.resetCurrentTimeOnResume&&(s=null,e.resetCurrentTimeOnResume=!1);const a=b(e),l=C(e);if(a>0&&t&&(null==s||s<0||s>=l))r=0;else if(a<0&&t&&(null==s||s<=0||s>l)){if(Infinity==l)return void e.animation.play();r=l}else 0==a&&null==s&&(r=0);null!=r&&(e.startTime=r,e.holdTime=null,k(e)),m(e.timeline,e.animation,I.bind(e.proxy)),e.holdTime&&(e.startTime=null),e.pendingTask&&(e.pendingTask=null,i=!0),(null!==e.holdTime||null!==r||n||null!==e.pendingPlaybackRate)&&(e.readyPromise&&!i&&(e.readyPromise=null),R(e),e.readyPromise||T(e),e.pendingTask="play",P(e,!1,!1))}function I(e){const t=N.get(this);if(null==e)return void("idle"!=t.animation.playState&&t.animation.cancel());t.pendingTask&&O(t);const n=this.playState;if("running"==n||"finished"==n){const i=v(t,e);t.animation.currentTime=(i-v(t,this.startTime))*this.playbackRate,"finished"==n&&0!=b(t)&&(t.holdTime=null),P(t,!1,!1)}}function O(e){"pause"==e.pendingTask?function(e){const t=v(e,e.timeline.currentTime);null!=e.startTime&&null==e.holdTime&&(e.holdTime=(t-e.startTime)*e.animation.playbackRate),k(e),e.startTime=null,e.readyPromise.resolve(e.proxy),P(e,!1,!1),R(e),e.pendingTask=null}(e):"play"==e.pendingTask&&function(e){const t=v(e,e.timeline.currentTime);if(null!=e.holdTime)k(e),0==e.animation.playbackRate?e.startTime=t:(e.startTime=t-e.holdTime/e.animation.playbackRate,e.holdTime=null);else if(null!==e.startTime&&null!==e.pendingPlaybackRate){const n=(t-e.startTime)*e.animation.playbackRate;k(e);const i=e.animation.playbackRate;0==i?(e.holdTime=null,e.startTime=t):e.startTime=t-n/i}e.readyPromise&&"pending"==e.readyPromise.state&&e.readyPromise.resolve(e.proxy),P(e,!1,!1),R(e),e.pendingTask=null}(e)}let N=new WeakMap;class A{constructor(e,t){const n=e instanceof p?e:new p(e,r),i=t instanceof h,r=i?void 0:t;N.set(this,{animation:n,timeline:i?t:void 0,playState:i?"idle":null,readyPromise:null,finishedPromise:null,startTime:null,holdTime:null,previousCurrentTime:null,resetCurrentTimeOnResume:!1,pendingPlaybackRate:null,pendingTask:null,specifiedTiming:null,normalizedTiming:null,effect:null,proxy:this})}get effect(){const e=N.get(this);return e.timeline?(e.effect||(e.effect=function(e){const t=e.animation.effect,n=t.updateTiming,i={apply:function(n){t.getTiming();const i=n.apply(t);if(e.timeline){i.localTime=S(e,i.localTime),i.endTime=S(e,i.endTime),i.activeDuration=S(e,i.activeDuration);const t=C(e),n=i.iterations?(t-i.delay-i.endDelay)/i.iterations:0;i.duration=t?CSS.percent(100*n/t):CSS.percent(0);const r=e.timeline.phase,s=i.fill;"before"==r&&"backwards"!=s&&"both"!=s&&(i.progress=null),"after"==r&&"forwards"!=s&&"both"!=s&&(i.progress=null),void 0===e.timeline.currentTime&&(i.localTime=null)}return i}},r={apply:function(i,r){if(e.specifiedTiming)return e.specifiedTiming;e.specifiedTiming=i.apply(t);let s,a=Object.assign({},e.specifiedTiming);return null!==a.duration&&"auto"!==a.duration||e.timeline&&(a.delay=0,a.endDelay=0,s=a.iterations?1e5:0,a.duration=a.iterations?s/a.iterations:0,n.apply(t,[a])),e.normalizedTiming=a,e.specifiedTiming}},s={apply:function(n,i,r){if(e.timeline){const e=r[0];if(Infinity===e.duration)throw TypeError("Effect duration cannot be Infinity when used with Scroll Timelines");if(Infinity===e.iterations)throw TypeError("Effect iterations cannot be Infinity when used with Scroll Timelines")}e.specifiedTiming&&n.apply(t,[e.specifiedTiming]),n.apply(t,r),e.specifiedTiming=null}},a=new Proxy(t,{get:function(e,n){const i=e[n];return"function"==typeof i?i.bind(t):i},set:function(e,t,n){return e[t]=n,!0}});return a.getComputedTiming=new Proxy(t.getComputedTiming,i),a.getTiming=new Proxy(t.getTiming,r),a.updateTiming=new Proxy(t.updateTiming,s),a}(e)),e.effect):e.animation.effect}set effect(e){N.get(this).animation.effect=e,details.effect=null}get timeline(){const e=N.get(this);return e.timeline||e.animation.timeline}set timeline(e){const t=this.timeline;if(t==e)return;const n=this.playState,i=this.currentTime,r=N.get(this),s=C(r),a=s>0?v(r,i)/s:0,l=t instanceof h,o=e instanceof h;r.resetCurrentTimeOnResume=!1;const c=this.pending;if(l&&u(r.timeline,r.animation),o){r.timeline=e,k(r);const t=r.animation.playbackRate>=0?0:C(r);switch(n){case"running":case"finished":r.startTime=t,m(r.timeline,r.animation,I.bind(this));break;case"paused":r.resetCurrentTimeOnResume=!0,r.startTime=null,r.holdTime=v(r,CSS.percent(100*a));break;default:r.holdTime=null,r.startTime=null}return c&&(r.readyPromise&&"resolved"!=r.readyPromise.state||T(r),r.pendingTask="paused"==n?"pause":"play"),null!==r.startTime&&(r.holdTime=null),void P(r,!1,!1)}if(r.animation.timeline!=e)throw TypeError("Unsupported timeline: "+e);if(u(r.timeline,r.animation),r.timeline=null,l)switch(null!==i&&(r.animation.currentTime=a*C(r)),n){case"paused":r.animation.pause();break;case"running":case"finished":r.animation.play()}}get startTime(){const e=N.get(this);return e.timeline?S(e,e.startTime):e.animation.startTime}set startTime(e){const t=N.get(this);if(e=v(t,e),!t.timeline)return void(t.animation.startTime=e);null==v(t,t.timeline.currentTime)&&null!=t.startTime&&(t.holdTime=null,R(t));const n=v(t,this.currentTime);k(t),t.startTime=e,t.resetCurrentTimeOnResume=!1,t.holdTime=null!==t.startTime&&0!=t.animation.playbackRate?null:n,t.pendingTask&&(t.pendingTask=null,t.readyPromise.resolve(this)),P(t,!0,!1),R(t)}get currentTime(){const e=N.get(this);return e.timeline?S(e,null!=e.holdTime?e.holdTime:x(e)):e.animation.currentTime}set currentTime(e){const t=N.get(this);if(e=v(t,e),!t.timeline||null==e)return void(t.animation.currentTime=e);const n=t.timeline.phase;null!==t.holdTime||null===t.startTime||"inactive"==n||0==t.animation.playbackRate?t.holdTime=e:t.startTime=E(t,e),t.resetCurrentTimeOnResume=!1,"inactive"==n&&(t.startTime=null),t.previousCurrentTime=null,"pause"==t.pendingTask&&(t.holdTime=e,k(t),t.startTime=null,t.pendingTask=null,t.readyPromise.resolve(this)),P(t,!0,!1)}get playbackRate(){return N.get(this).animation.playbackRate}set playbackRate(e){const t=N.get(this);if(!t.timeline)return void(t.animation.playbackRate=e);t.pendingPlaybackRate=null;const n=this.currentTime;t.animation.playbackRate=e,null!==n&&(this.currentTime=n)}get playState(){const e=N.get(this);if(!e.timeline)return e.animation.playState;const t=v(e,this.currentTime);if(null===t&&null===e.startTime&&null==e.pendingTask)return"idle";if("pause"==e.pendingTask||null===e.startTime&&"play"!=e.pendingTask)return"paused";if(null!=t){if(e.animation.playbackRate>0&&t>=C(e))return"finished";if(e.animation.playbackRate<0&&t<=0)return"finished"}return"running"}get replaceState(){return N.get(this).animation.pending}get pending(){const e=N.get(this);return e.timeline?!!e.readyPromise&&"pending"==e.readyPromise.state:e.animation.pending}finish(){const e=N.get(this);if(!e.timeline)return void e.animation.finish();const t=b(e),n=C(e);if(0==t)throw new DOMException("Cannot finish Animation with a playbackRate of 0.","InvalidStateError");if(t>0&&Infinity==n)throw new DOMException("Cannot finish Animation with an infinite target effect end.","InvalidStateError");k(e);const i=t<0?0:n;this.currentTime=S(e,i);const r=v(e,e.timeline.currentTime);null===e.startTime&&null!==r&&(e.startTime=r-i/e.animation.playbackRate),"pause"==e.pendingTask&&null!==e.startTime&&(e.holdTime=null,e.pendingTask=null,e.readyPromise.resolve(this)),"play"==e.pendingTask&&null!==e.startTime&&(e.pendingTask=null,e.readyPromise.resolve(this)),P(e,!0,!0)}play(){const e=N.get(this);e.timeline?M(e,!0):e.animation.play()}pause(){const e=N.get(this);if(!e.timeline)return void e.animation.pause();if("paused"==this.playState)return;let t=null;const n=e.animation.playbackRate,i=C(e);if(null===e.animation.currentTime)if(n>=0)t=0;else{if(Infinity==i)return void e.animation.pause();t=i}null!==t&&(e.startTime=t),"play"==e.pendingTask?e.pendingTask=null:e.readyPromise=null,e.readyPromise||T(e),e.pendingTask="pause"}reverse(){const e=N.get(this),t=b(e),n=e.resetCurrentTimeOnResume?null:v(e,this.currentTime),i=Infinity==C(e),r=0!=t&&(t<0||n>0||!i);if(!e.timeline||!r)return r&&(e.pendingPlaybackRate=-b(e)),void e.animation.reverse();if("inactive"==e.timeline.phase)throw new DOMException("Cannot reverse an animation with no active timeline","InvalidStateError");this.updatePlaybackRate(-t),M(e,!0)}updatePlaybackRate(e){const t=N.get(this);if(t.pendingPlaybackRate=e,t.timeline){if(!t.readyPromise||"pending"!=t.readyPromise.state)switch(this.playState){case"idle":case"paused":k(t);break;case"finished":const n=v(t,t.timeline.currentTime),i=null!==n?(n-t.startTime)*t.animation.playbackRate:null;t.startTime=0==e?n:null!=n&&null!=i?(n-i)/e:null,k(t),P(t,!1,!1),R(t);break;default:M(t,!1)}}else t.animation.updatePlaybackRate(e)}persist(){N.get(this).animation.persist()}get id(){return N.get(this).animation.id}cancel(){const e=N.get(this);e.timeline?("idle"!=this.playState&&(function(e){e.pendingTask&&(e.pendingTask=null,k(e),e.readyPromise.reject(y()),T(e),e.readyPromise.resolve(e.proxy))}(e),e.finishedPromise&&"pending"==e.finishedPromise.state&&e.finishedPromise.reject(y()),e.finishedPromise=new g,e.animation.cancel()),e.startTime=null,e.holdTime=null,u(e.timeline,e.animation)):e.animation.cancel()}get onfinish(){return N.get(this).animation.onfinish}set onfinish(e){N.get(this).animation.onfinish=e}get oncancel(){return N.get(this).animation.oncancel}set oncancel(e){N.get(this).animation.oncancel=e}get onremove(){return N.get(this).animation.onremove}set onremove(e){N.get(this).animation.onremove=e}get finished(){const e=N.get(this);return e.timeline?(e.finishedPromise||(e.finishedPromise=new g),e.finishedPromise.promise):e.animation.finished}get ready(){const e=N.get(this);return e.timeline?(e.readyPromise||(e.readyPromise=new g,e.readyPromise.resolve(this)),e.readyPromise.promise):e.animation.ready}addEventListener(e,t,n){N.get(this).animation.addEventListener(e,t,n)}removeEventListener(e,t,n){N.get(this).animation.removeEventListener(e,t,n)}dispatchEvent(e){N.get(this).animation.dispatchEvent(e)}}let W=new WeakMap;const U=[[[0,1,2,3]],[[0,2],[1,3]],[[0],[1,3],[2]],[[0],[1],[2],[3]]];class j{constructor(e){W.set(this,{target:null,edge:"start",threshold:0,rootMargin:[[0,"px"],[0,"px"],[0,"px"],[0,"px"]]}),this.target=e.target,this.edge=e.edge||"start",this.threshold=e.threshold||0,this.rootMargin=e.rootMargin||"0px 0px 0px 0px",this.clamp=e.clamp||!1}set target(e){if(!(e instanceof Element))throw W.get(this).target=null,Error("Intersection target must be an element.");W.get(this).target=e}get target(){return W.get(this).target}set edge(e){-1!=["start","end"].indexOf(e)&&(W.get(this).edge=e)}get edge(){return W.get(this).edge}set threshold(e){let t=parseFloat(e);if(t!=t)throw TypeError("Invalid threshold.");if(t<0||t>1)throw TypeError("threshold must be in the range [0, 1]");W.get(this).threshold=t}get threshold(){return W.get(this).threshold}set rootMargin(t){let n=t.split(/ +/);if(n.length<1||n.length>4)throw TypeError("rootMargin must contain between 1 and 4 length components");let i=[[],[],[],[]];for(let t=0;t<n.length;t++){let r=e(n[t],!0);if(!r)throw TypeError("Unrecognized rootMargin length");let s=U[n.length-1][t];for(let e=0;e<s.length;e++)i[s[e]]=[parseFloat(r.value),r.unit]}W.get(this).rootMargin=i}get rootMargin(){return W.get(this).rootMargin.map(e=>e.join("")).join(" ")}set clamp(e){W.get(this).clamp=!!e}}function L(){return(L=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}const V={IDENTIFIER:/[\w\\\@_-]+/g,WHITE_SPACE:/\s*/g,NUMBER:/^[0-9]+/,TIME:/^[0-9]+(s|ms)/,ANIMATION_TIMELINE:/animation-timeline\s*:([^;}]+)/,ANIMATION_NAME:/animation-name\s*:([^;}]+)/,ANIMATION:/animation\s*:([^;}]+)/,SOURCE_ELEMENT:/selector\(#([^)]+)\)/},D=new class{constructor(){this.cssRulesWithTimelineName=[],this.scrollTimelineOptions=new Map,this.keyframeNames=new Set}transpileStyleSheet(e,t,n){const i={sheetSrc:e,index:0,name:n};for(;i.index<i.sheetSrc.length&&(this.eatWhitespace(i),!(i.index>=i.sheetSrc.length));)if(this.lookAhead("/*",i))for(;this.lookAhead("/*",i);)this.eatComment(i),this.eatWhitespace(i);else if(this.lookAhead("@scroll-timeline",i)){const{scrollTimeline:e}=this.parseScrollTimeline(i);t&&this.scrollTimelineOptions.set(e.name,e)}else{const e=this.parseQualifiedRule(i);if(!e)continue;t?this.extractAndSaveKeyframeName(e.selector):this.handleScrollTimelineProps(e,i)}return i.sheetSrc}getScrollTimelineName(e,t){for(let n=this.cssRulesWithTimelineName.length-1;n>=0;n--){const i=this.cssRulesWithTimelineName[n];if(t.matches(i.selector)&&(!i["animation-name"]||i["animation-name"]==e))return i["animation-timeline"]}return null}parseScrollTimeline(e){const t=e.index;this.assertString(e,"@scroll-timeline"),this.eatWhitespace(e);let n=this.parseIdentifier(e);this.eatWhitespace(e),this.assertString(e,"{"),this.eatWhitespace(e);let i={name:n,source:"auto",orientation:void 0};for(;"}"!==this.peek(e);){const t=this.parseIdentifier(e);this.eatWhitespace(e),this.assertString(e,":"),this.eatWhitespace(e),i[t]=this.removeEnclosingDoubleQuotes(this.eatUntil(";",e)),this.assertString(e,";"),this.eatWhitespace(e)}this.assertString(e,"}");const r=e.index;return this.eatWhitespace(e),{scrollTimeline:i,startIndex:t,endIndex:r}}handleScrollTimelineProps(e,t){if(e.selector.includes("@keyframes"))return;const n=e.block.contents.includes("animation-name:"),i=e.block.contents.includes("animation-timeline:"),r=e.block.contents.includes("animation:");let s=[],a=[];i&&(s=this.extractMatches(e.block.contents,V.ANIMATION_TIMELINE)),n&&(a=this.extractMatches(e.block.contents,V.ANIMATION_NAME)),i&&n||r&&this.extractMatches(e.block.contents,V.ANIMATION).forEach(n=>{const r=this.extractAnimationName(n),l=this.extractTimelineName(n);r&&a.push(r),l&&(s.push(l),e.block.contents=e.block.contents.replace(l," ".repeat(l.length)),this.replacePart(e.block.startIndex,e.block.endIndex,e.block.contents,t)),(l||i)&&(this.hasDuration(n)||(e.block.contents=e.block.contents.replace("animation:","animation: 1s "),this.replacePart(e.block.startIndex,e.block.endIndex,e.block.contents,t)))}),this.saveRelationInList(e,s,a)}hasDuration(e){return e.split(" ").filter(e=>V.TIME.exec(e)).length>=1}saveRelationInList(e,t,n){if(0==n.length)for(let n=0;n<t.length;n++)this.cssRulesWithTimelineName.push({selector:e.selector,"animation-name":void 0,"animation-timeline":t[n]});else for(let i=0;i<Math.max(t.length,n.length);i++)this.cssRulesWithTimelineName.push({selector:e.selector,"animation-name":n[i%n.length],"animation-timeline":t[i%t.length]})}extractAnimationName(e){return this.findMatchingEntryInContainer(e,this.keyframeNames)}extractTimelineName(e){return this.findMatchingEntryInContainer(e,this.scrollTimelineOptions)}findMatchingEntryInContainer(e,t){const n=e.split(" ").filter(e=>t.has(e));return n?n[0]:null}parseIdentifier(e){V.IDENTIFIER.lastIndex=e.index;const t=V.IDENTIFIER.exec(e.sheetSrc);if(!t)throw this.parseError(e,"Expected an identifier");return e.index+=t[0].length,t[0]}extractAndSaveKeyframeName(e){e.startsWith("@keyframes")&&e.split(" ").forEach((e,t)=>{t>0&&this.keyframeNames.add(e)})}parseQualifiedRule(e){const t=e.index,n=this.parseSelector(e).trim();if(n)return{selector:n,block:this.eatBlock(e),startIndex:t,endIndex:e.index}}removeEnclosingDoubleQuotes(e){return e.substring('"'==e[0]?1:0,'"'==e[e.length-1]?e.length-1:e.length)}assertString(e,t){if(e.sheetSrc.substr(e.index,t.length)!=t)throw this.parseError(e,`Did not find expected sequence ${t}`);e.index+=t.length}replacePart(e,t,n,i){i.sheetSrc=i.sheetSrc.slice(0,e)+n+i.sheetSrc.slice(t),i.index>=t&&(i.index=e+n.length+(i.index-t))}eatComment(e){this.assertString(e,"/*"),this.eatUntil("*/",e),this.assertString(e,"*/")}eatBlock(e){const t=e.index;this.assertString(e,"{");let n=1;for(;0!=n;)"{"===e.sheetSrc[e.index]?n++:"}"===e.sheetSrc[e.index]&&n--,this.advance(e);const i=e.index;return{startIndex:t,endIndex:i,contents:e.sheetSrc.slice(t,i)}}advance(e){if(e.index++,e.index>e.sheetSrc.length)throw this.parseError(e,"Advanced beyond the end")}eatUntil(e,t){const n=t.index;for(;!this.lookAhead(e,t);)this.advance(t);return t.sheetSrc.slice(n,t.index)}parseSelector(e){let t=e.index;if(this.eatUntil("{",e),t===e.index)throw Error("Empty selector");return e.sheetSrc.slice(t,e.index)}eatWhitespace(e){V.WHITE_SPACE.lastIndex=e.index;const t=V.WHITE_SPACE.exec(e.sheetSrc);t&&(e.index+=t[0].length)}lookAhead(e,t){return t.sheetSrc.substr(t.index,e.length)==e}peek(e){return e.sheetSrc[e.index]}extractMatches(e,t){return t.exec(e)[1].trim().split(",").map(e=>e.trim())}};function H(e){const t=V.SOURCE_ELEMENT.exec(e);return t?document.getElementById(t[1]):"auto"===e?document.scrollingElement:null}if(i.push({parse:function(e){if(e.target)return new j(e)},evaluate:function(e,t,n,i){"block"==t?t="vertical":"inline"==t&&(t="horizontal");let r=e==document.scrollingElement?{left:0,right:e.clientWidth,top:0,bottom:e.clientHeight,width:e.clientWidth,height:e.clientHeight}:e.getBoundingClientRect(),s=W.get(n).rootMargin,a=[];for(let e=0;e<4;e++)a.push("percent"==(l=s[e])[1]?l[0]*(e%2==0?r.height:r.width)/100:l[0]);var l;let o=r.left-a[3],c=r.right-r.left+a[3]+a[1],u=r.top-a[0],m=r.bottom-r.top+a[0]+a[2],h=W.get(n).clamp,d=n.target.getBoundingClientRect(),f=n.threshold;if("start"==n.edge&&(f=1-f),"vertical"==t){let t=d.top+d.height*f-u+e.scrollTop;return h?"end"==n.edge?Math.max(0,t-m):Math.min(t,e.scrollHeight-m):"end"==n.edge?t-m:t}{let t=d.left+d.width*f-o+e.scrollLeft;return h?"end"==n.edge?Math.max(0,t-c):Math.min(t,e.scrollWidth-c):"end"==n.edge?t-c:t}}}),CSS.supports("animation-timeline: works")||(function(){function e(e){if(0===e.innerHTML.trim().length)return;let t=D.transpileStyleSheet(e.innerHTML,!0);t=D.transpileStyleSheet(t,!1),e.innerHTML=t}new MutationObserver(t=>{for(const n of t)for(const t of n.addedNodes)t instanceof HTMLStyleElement&&e(t)}).observe(document.documentElement,{childList:!0,subtree:!0}),document.querySelectorAll("style").forEach(t=>e(t)),document.querySelectorAll("link").forEach(e=>{})}(),window.addEventListener("animationstart",e=>{e.target.getAnimations().filter(t=>t.animationName===e.animationName).forEach(t=>{const n=D.getScrollTimelineName(t.animationName,e.target);if(n){const e=function(e){const t=D.scrollTimelineOptions.get(e);if(!t)return null;const n=H(t.source);return new ScrollTimeline(L({},n?{source:H(t.source)}:{},"auto"!=t.orientation?{orientation:t.orientation}:{}))}(n);if(t.timeline!=e){const n=new A(t,e);t.pause(),n.play()}}})})),!Reflect.defineProperty(window,"ScrollTimeline",{value:h}))throw Error("Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window");if(!Reflect.defineProperty(window,"ViewTimeline",{value:class extends h{constructor(e){e.subject&&!e.source&&(e.source=d(e.subject.parentNode)),super(e);const t=n.get(this);t.subject=e&&e.subject?e.subject:void 0,t.range=e&&e.range?e.range:"cover"}get subject(){return n.get(this).subject}get phase(){if(!this.subject)return"inactive";const e=this.source;if(!e)return"inactive";let t=getComputedStyle(e);if("none"==t.display)return"inactive";if(e!=document.scrollingElement&&("visible"==t.overflow||"clip"==t.overflow))return"inactive";let n=this.subject;for(;n&&n!=e;)n=n.offsetParent;return n!=e?"inactive":"active"}get range(){return n.get(this).range}get currentTime(){if("inactive"===this.phase)return null;const e=this.source,t=this.subject;let n=0,i=0,r=t;for(;r&&r!=e;)i+=r.offsetLeft,n+=r.offsetTop,r=r.offsetParent;const s=getComputedStyle(e),l="horizontal-tb"==s.writingMode;let o,c,u;const m=this.orientation;"horizontal"==m||"inline"==m&&l||"block"==m&&!l?(o=t.clientWidth,c=i,"rtl"==s.direction&&(c+=e.scrollWidth-e.clientWidth),u=e.clientWidth):(o=t.clientHeight,c=n,u=e.clientHeight);const h=a(e,m);let d,f;switch(this.range){case"cover":d=c-u,f=c+o;break;case"contain":d=c+o-u,f=c;break;case"start":d=c-u,f=c+o-u;break;case"end":d=c,f=c+o}return d<f?CSS.percent((h-d)/(f-d)*100):null}}}))throw Error("Error installing ViewTimeline polyfill: could not attach ViewTimeline to window");if(!Reflect.defineProperty(Element.prototype,"animate",{value:function(e,t){const n=t.timeline;n instanceof h&&delete t.timeline;const i=f.apply(this,[e,t]),r=new A(i,n);return n instanceof h&&(i.pause(),r.play()),r}}))throw Error("Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element");if(!Reflect.defineProperty(window,"Animation",{value:A}))throw Error("Error installing Animation constructor.");
//# sourceMappingURL=scroll-timeline.modern.js.map
